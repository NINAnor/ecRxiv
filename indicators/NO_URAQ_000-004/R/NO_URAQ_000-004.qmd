---
title: "Urban Air Quality"
subtitle: "[NO_URAQ_000 to NO_URAQ_004] - Urban Air Quality - Particulate Matter 2.5 concentration in urban areas"
format: 
  html:
    embed-resources: true
    code-fold: true
    toc: true
    toc-title: Contents
    toc-depth: 3
    smooth-scroll: true
execute: 
  cache: true
author:
  - name: Sylvie Clappe # Enter name
    email: sylvie.clappe@nina.no  # Enter email
    affiliations:
      - id: myID
        name: Norwegian Institute for Nature Research # Enter affiliations
  - name: Bálint Czúcz            #  Enter subsequent authors like this, or remove if not relevant
    email: balint.czucz@nina.no
    affiliations:
      - ref: myID               # To reuse affiliations referecen the id like this
date: July 10, 2025# Enter date 
callout-icon: false
lightbox: true
css: ../../../style.css
code-links:
      - text: Add a review
        icon: github
        href: https://github.com/NINAnor/ecRxiv
---

<!--# This is a template for how to document the indicator analyses. Make sure also to not change the order, or modify, the headers, unless you really need to. This is because it easier to read if all the indicators are presented using the same layout. If there is one header where you don't have anything to write, just leave the header as is, and don't write anything below it. If you are providing code, be careful to annotate and comment on every step in the analysis. Before starting it is recommended to fill in as much as you can in the metadata file. This file will populate the initial table in your output.-->

<!--# Load all you dependencies here -->

```{r setup}
#| include: false
library(knitr)
library(tidyverse)
library(kableExtra)
library(terra)
library(sf)
library(dplyr)
library(readxl)
library(httr2)
library(glue)
library(tictoc)
library(duckdb)
library(duckdbfs)
library(duckspatial)
library(mirai)
library(purrr)
library(stringr)
library(exactextractr)
library(carrier)
library(DT)
library(numform)

knitr::opts_chunk$set(echo = TRUE)
```

```{r source}
#| echo: false
source(here::here("_common.R"))
```

```{r}
#| echo: false
meta <- readxl::read_xlsx("../metadata.xlsx")
st <- meta |>
  filter(Variable == "status") |>
  pull(Value)
version <- meta |>
  filter(Variable == "Version") |>
  pull(Value)
auth <- meta |>
  filter(Variable == "authors") |>
  pull(Value)
year <- meta |>
  filter(Variable == "yearAdded") |>
  pull(Value)
id <- meta |>
  filter(Variable == "indicatorID") |>
  pull(Value)
name <- meta |>
  filter(Variable == "indicatorName") |>
  pull(Value)
url <- meta |>
  filter(Variable == "url") |>
  pull(Value)

meta <- meta |>
  mutate(Variable = case_match(Variable,
    "indicatorID" ~ "Indicator ID" ,
    "indicatorName" ~ "Indicator Name",
    "country" ~ "Country",
    "continent" ~ "Continent",
    "ECT" ~ "Ecosystem Condition Typology Class",
    "yearAdded" ~ "Year added",
    "yearLastUpdate" ~ "Last update",
    .default = Variable
   )
  ) |>
  filter(Variable != "authors")

```

<!--# The following parts are autogenerated. Do not edit. -->

```{r}
#| echo: false
#| results: asis
status(st)
```

::: {layout-ncol="2"}



> **Recomended citation**: `r paste(auth, " ", year, ". ", name, " (ID: ", id, ") ", "v. ", version, ". ecRxiv: https://view.nina.no/ecRxiv/", sep="")`

> **Version**: `r version`

:::

```{=html}
<details>
<summary>Show metadata</summary>
```

```{r tbl-meta}
#| tbl-cap: 'Indicator metadata'
#| echo: false
#| warning: false

meta |>
  select(Variable, Value) |>
  kbl(col.names = NULL) 

```

```{=html}
</details>
```

::: {.callout-tip collapse="true"}

## Logg

<!--# Update this logg with short messages for each update -->
- 08 September 2025 - Original PR
:::


<hr />

<!--# Document you work below.  -->

## 1. Summary
<!--# With a maximum of 300 words, describe the indicator in general terms as you would to a non-expert. Think of this as a kind of commmon language summary. It is a good idea to include a bullet point list of the spesific steps in the workflow. Include a mention of the following aspects:
What does the metric represent?
Why is this relevant for describing ecosystem condition in this ecosystem?
What are the main anthropogenig impact factors?
What kind of data is used? 
Shortly, how is the data customized (modified, estimated, integarted) to fit its purpuse as an indicator?
What is the current status of  the metric (can it be used or is it still in development)?
How should the metric be used and interpretted, and how should it not be used/interpretted? -->

Air quality can be measured by the presence of various pollutants in the air. Here we focused on PM2.5, i.e. the concentration of very small solid particles (particulate matter) in the air, which have a diameter under 2.5 $\mu$m. This is in line with the EU Regualtion on Environmental Economic Accounting ([EU Reg. 2011/691](https://eur-lex.europa.eu/legal-content/EN/TXT/?uri=CELEX:02011R0691-20250624)), which lists PM2.5 among the mandatory ecosystem condition indicators to characterise the condition of the ecosystem type *settlements and other artificial areas* (ET01, henceforward "urban ecosystems" for short). The annual concentration of PM2.5 is also recognised national environmental indicator in Norway (Miljøindikator 4.6.2). 

In principle, there could be many other similar  air quality indicators calculated for urban ecosystems (one for each relevant pollutant). Nevertheless, these  indicators would definitely be correlated with each other, and the degree to which *air quality* metrics match the definition and selection criteria for *ecosystem condition* variables is also questionable (Czucz et al. 2025a). Accordingly, here we only present calculations for PM2.5.  

There are 2 major steps in calculating urban air quality indicators for a selected reference period and ecosystem accounting area (EAA):

1. Identify the '*target area*' for which the indicator should be calculated (cf. Czucz et al. 2025a).

2. Calculate the mean concentration of the selected pollutant (PM2.5) within this area (for the selected accounting period).

There are several ways of defining the *target area*. The EU Accordingly, in this document, we present five different variants of the indicator based on different definitions of the *target area*. Besides offering a flexible approach for performing the "right" calculation for every reporting context, these variants are also aligned across other *urban* ecosystem condition variables (URGR, TCCD), thus making it easier to establish consistency across the different variables and tehir policy use. 

### 1.1 Overview of the different indicator versions

* **URAQ_004**: The *target area* is the total area of the ecosystem type ET01 (*Settlements and other artificial areas*) in Norway. This is the option which is most aligned with the principles of SEEA EA (UN et al. 2024), where an ecosystem condition indicators are expected to be representative of their "parent" ecosystem type (see also Czucz et al. 2025a). 

* **URAQ_001**: The *target area* is the area of the ecosystem type ET01 (*Settlements and other artificial areas*) within the municipalities considered as *"cities"* according to Eurostat's degree of urbanisation (DEGURBA) classification (`DEGURBA = 1`). This is the preferred option for calculating the mandatory Eurostat indicator according to Eurostat's guidelines (Eurostat 2025). 

* **URAQ_002**: The *target area* is the area of the ecosystem type ET01 (*Settlements and other artificial areas*) within the municipalities considered as "towns and suburbs" according to Eurostat's DEGURBA classification (`DEGURBA = 2`).

* **URAQ_003**: The *target area* is the area of the ecosystem type ET01 (*Settlements and other artificial areas*) within the municipalities considered as "rural areas" according to Eurostat DEGURBA classification (`DEGURBA = 3`). URAQ_002 and URAQ_003 are complementary to URAQ_001, they present an overview of the air pollution status of the three main types of municipalities in Norway. The area-weighted mean of these three indicators (URAQ_001-URAQ_003, weigthed by the total area of settlements (ET01) in the respective categories) will be equal to URAQ_004 for any reporting period.  

* **URAQ_000**: The *target area* is the *entire area*(!!) of the municipalities considered as "cities" according to Eurostat DEGURBA classification (`DEGURBA = 1`). As the total area of Norwegian municipalities is typically dominated by natural ecosystems (forests, wetlands, mountains, etc.) this option actually contradicts key principles of ecosystem accounting (i.e., the pollutant concentrations in a forest should be considered as the condition of the forest, not that of a potentially distant urban area). Nevertheless this option is currently listed as the second (less recommended) option in Eurostat's guidelines (Eurostat 2025) for calculating the mandatory indicator in the EU regulation. 

For a national use we recommend to use URAQ_004, which is most aligned with SEEA EA among the five versions presented. Nevertheless, for official EU reporting the calculation of URAQ_001 may also be necessary, as long as the current draft guidance from Eurostat (Eurostat 2025) will stay unchanged. The calculation of URAQ_001--URAQ_003 for diverse ecossytem accounting areas (EAAs) might also be useful for the additional analytical insight offered by distinguishing the different types of settlements according to their degree of urbanisation.   


## 2. About the underlying data
<!--# Describe the data you have used in more detail, it's origin, biases, availabilit ect.-->

We use the following two main datasets for our calculations: 

* **PM2.5 concentration**: Raster maps with mean annual PM2.5 concentrations. The PM2.5 dataset is produced using pollution transport models based on measurements from Norwegian air quality monitoring stations by the Norwegian Meteorological Institute (Denby et al. 2020). It's important to note that air quality monitoring in Norway is focused on urban areas and high-traffic locations where pollution levels are a concern.

* **Grunnkart**: Norway's official *ecosystem type map* designed to support ecosystem accounting (Strand et al. 2024; Aune...). This map aims to implement Eurostat's EU ecosystem typology (Eurostat 2024b) for Norway. Here we use this map for delineating the area of ecosystem type ET01 (*Settlements and other artificial areas*).

In addition we use several further administrative datasets to delineate the individual municipalities (=Local Administrative Units, LAU), as well as to determine their "degree of urbanisation" (DEGURBA), and to assign them to regions (counties, "fylke").


### 2.1 Spatial and temporal resolution and extent
<!--# Describe the temporal and spatial resolution and extent of the data used -->

Data on annual mean *PM2.5 concentration* are available with a 100 m resolution for the total land area of each Norwegian municipality. The data only covers continental Norway, Svalbard is not included. 

All other spatial data files, including the *Grunnkart* and the *Local Administrative Units* (LAU) are vector data (polygons). Unlike traditional land cover maps (e.g., CORINE), the Grunnkart does not have a single, universal Minimum Mapping Unit (MMU). Instead, the spatial resolution of the Grunnkart is directly inherited from the underlying source datasets used in its creation. This is because the new map is a synthesis and reclassification of existing data rather than a new, independent mapping effort. As the majority of spatial information available in public datasets focusses on human settlements and infrastructure, urban ecosystems are relatively finely represented in NIBIO's Grunnkart, especially compared to seminatural and natural ecosystem types. This makes the contours of ET01 overly-detailed, often delineating individual buildings or roads passing through a forest as "urban ecosystems". This also makes the dataset somewhat unfit for its purpose (Rendon et al. 2025) and cumbersome to process. 



### 2.2 Original units
<!--# What are the original units for the most relevant variables in the data-->

PM2.5 concentrations are expressed in $\mu$g/m^3^, the values reflect estimated annual average concentration for each map pixel. 

### 2.3 Additional comments about the dataset

The actual boundaries of the municipalities were patched together from two sources (see more details in Section 9). The DEGURBA dataset we only used to classify the Norwegian municipalities into three categories (1: "cities", 2: "towns and suburbs", 3: "rural areas") based on their degree of urbanisation. 


#### 2.3.1 Instructions for citing, using and accessing data
<!--# Is the data openly available? If not, how can one access it? What are the key references to the datasets?   -->

||Publicly accessible| Data and metadata available Available at|
|----|--|--------|
| **PM2.5 concentration maps**  | Yes | Description available at [met.no](https://airquality-expert.met.no/) and in Denby et al. (2020). Data available via API at [met.no](https://airquality-expert.met.no/)  |
**Grunnkart**  | No, only upon request to NIBIO | We used testversion 0.2, description available in Aune-Lundberg et al. (2025) and Strand et al. (2024) |
| **EU data about the municipalities**  | Yes | Data and description available from Eurostat: [LAU](https://ec.europa.eu/eurostat/web/gisco/geodata/statistical-units/local-administrative-units) and [DEGURBA](https://ec.europa.eu/eurostat/web/nuts/local-administrative-units) |
| **Norwegian data about the municipalities**  | Yes | Data available from Kartverkert: [boundaries](https://kartkatalog.geonorge.no/metadata/administrative-enheter-kommuner/041f1e6e-bdbc-4091-b48f-8a5990f3cc5b) and [identifiers](https://www.kartverket.no/til-lands/fakta-om-norge/norske-fylke-og-kommunar) |


## 3. Indicator properties

### 3.1 Ecosystem Condition Typology Class (ECT)
<!--# Describe the rationale for assigning the indicator to the ECT class. See https://oneecosystem.pensoft.net/article/58218/
This doesnt need to be very long. Maybe just a single sentence. -->

The presence of chemical pollutants in urban ecosystems can be considered as a *pressure variable* (which then would imply that this variable should be excluded from ecosystem condition accounts). Alternatively, this variable can also be considered a *condition variable* under ECT type A2 (abiotic chemical condition characteristics).

### 3.2 Ecosystem condition characteristic
<!--# Describe the ecosystem condition characteristic represented in the indicator. See 10.3897/oneeco.6.e58218 for information on what these characteristics might be.
For example, and indicator called 'Trenching in mires' could be made to represent an ecosystem characteristic 'Intact hydrology'. The term 'characteristic' is used similar to the term 'criteria' in Multiple Criteria Decition Making.  -->

If the "local air mass" is considered to be part of the local ecosystem (as one of its "abiotic compartments"), then PM2.5 can chararcterise the chemical condition (pollutedness, intactness) of this compartment. 


### 3.3 Other standards
<!--# Optional: Add text about other spesific standards, e.g. national standards, and how the indicator relates to these -->
In this documentation, we present different variations of the air quality indicator based on PM2.5 concentration. We recommend to use URAQ_004 as it relies upon the most ecologically correct definition, in line with the System of Environmental Economic Accounting - Ecosystem Accounting (UN et al., 2024). It however does not follow the official guidance from the European Commission for national reporting under EU Regulation 2024/3024 (@eu-2024-3024). If users need to report this indicator in an official EU reporting, we recommend to use URAQ_000.



### 3.4 Collinearities with other indicators
<!--# Describe known collinearities with other metrices (indicators or variables) that could become problematic if they were also included in the same Ecosystem Condition Assessment as the indicator described here. -->
This indicator might present some correlations with the Tree Cover Density and Urban Green Areas indicators. Green urban ecosystems provide the air filtration service which allows to decrease the concentration of PM2.5 in that air. Hence a correlation between this indicators and any other condition indicators directly and indirectly including green urban ecosystems in their calculations.

If additional air pollutants (e.g., tropospheric ozone) were used to quantify separate ecosystem condition variables then these variables would definitely be highly correlated.    


### 3.5 Impact factors
<!--# Describe the main natural and anthropogenic factors that affects the metric -->
The concentration of PM2.5 in the air is entirely due to anthropogenic factors. A part of PM2.5 are emitted directly as solid particles from various sources, such as construction sites, unpaved roads, fields, smokestacks or fires. Another, potentially even more significant fraction of the PM2.5 particles are formed in the atmosphere from gaseous pollutants, such as sulfur dioxide or nitrogen oxides, emitted from power plants, industries, and automobiles. Vegetation, including (semi)natural ecosystem types, and urban green areas can positively impact (i.e. reduce) PM2.5 concentrations through the air filtration service provided by these ecosystems.


## 4. Reference condition and levels

### 4.1 Reference condition
<!--# Define the reference condition (or refer to where it is defined). Note the destinction between reference condition and reference levels 10.3897/oneeco.5.e58216  -->

In general it is difficult to set a *reference condition* for anthropogenic ecosystems. In such cases it is often recommended to consider a  theoretical "anthropogenically derived" (SEEA EA 5.72) or "best attainable" reference condition (Vallecillo et al. 2022) instead, for which there is often no "prototype" available, so the best way to operationalise this type of reference condition is to determine optimal reference levels (X~100~) for each variable independently (Czucz et al. 2025b), which is discussed below. 


### 4.2 Reference levels
<!--# If relevant (i.e. if you have normalised a variable), describe the reference levels used to normalise the variable. Use the terminology where X~0~ referes to the referece level (the variable value) denoting the worst possible condition; X~100~denotes the optimum or best possible condition; and X~*n*~, where in is between 0 and 100, denotes any other anchoring points linking the variable scale to the indicator scale (e.g. the threshold value between good and bad condition X~60~). 
Why was the current option chosen and how were the reference levels quantified? If the reference values are calculated as part of the analyses further down, please repeat the main information here. -->

Similarly to most other pollutants and other "negative" condition variables, a zero value (no pollutants present) can be considered as a meaningful value for the "optimal" *reference level* (X~100~) of PM2.5. 

In principle it could be possible to assign further reference levels (e.g. X~60~, X~0~) based on limit values (greseverdier), criteria (luftkvalitetskriterier), or national targets set by Norway's Pollution Control Regulations (Forurensningsforskriften), the Norwegian Institute of Public Health (Folkehelseinstituttet), the Norwegian Environment Agency (Miljødirektoratet), or the World Health Organization (WHO). Norway also has a national target related to the annual concentration of PM2.5, which is 8 $\mu$g/m^3^. Nevertheless, in the case of this variable, identifying the right values for the reference levels is not a purely ecologist task, and in the context of the current project the necessary interdisciplinary understanding was not achieved.    


#### 4.2.1 Spatial resolution and validity
<!--# Describe the spatial resolution of the reference levels. E.g. is it defined as a fixed value for all areas, or does it vary. Also, at what spatial scale are the reference levels valid? For example, if the reference levels have a regional resolution (varies between regions), it might mean that it is only valid and correct to use for normalising local variable values that are first aggregated to regional scale. However, sometimes the reference levels are insensitive to this and can be used to scale variables at the local (e.g. plot) scale. -->
X~100~ (the null value of PM2.5) can be seen as a universal reference level, which is valid for any occurrences and subtypes of ET01 (in any type of settlement) at any spatial resolution over all Norway. Nevertheless, If there will be any further reference levels determined for PM2.5 in the future they will also probably be universal reference levels -- nevertheless the environmental norms are defined at the local level (directly for the air quality station measurements), so if the reference levels will be linked to them, then they will also need to be applied at the local level. (I.e., pixel level data will need to be rescaled first, before spatial aggregation.) 

## 5. Uncertainties
<!--# Describe the main uncertainties or sources of error in the indicator or the underlying data. -->

There are several sources of uncertainties affecting the values of this indicator and its subsequent use:

- <u>data uncertainties in PM2.5</u>: The main input data (PM2.5) are model outputs relying on relatively few point-wise ground observations (according to Denby et al. 2025 there are only 33 PM2.5 monitoring stations in the netire country). Accordingly, the wall-to-wall dataset of modelled annual mean values will inevatiably contain a high level of uncertainty, especially farther away from the main urban centres where the monitoring stations lie. 

- <u>spatial, temporal and semantic uncertainties of the grunnkart</u>: the current Grunnkart combines many different static data sources with various temporal reference dates, which does not seem to present an easily reproducible and updatable data source. This means that the outlines of the urban ecosystems (ET01) contain an unknown amount of uncertainty ("ad-hoc-ness"). As Grunnkart is currently a static dataset, we used for the entire study period the only available timeline (which itself relies on temporally heterogeneous sources in an undocumented way). 

- <u>uncertainty of defining the target area</u>: the indicators presented in this document have been compiled in accordance with different interpretations of the urban areas, see more in Section 1.1. In particular, the instructions by Eurostat (2025) outline two different calcualtion methods for the indicator, neither of which aligns well with SEEA EA principles. From the perspective of consistent reporting this can be seen as a spectacular high level uncertainty.


## 6. References
<!--# You can add references manually or use a citation manager and add intext citations as with crossreferencing and hyperlinks. See https://quarto.org/docs/authoring/footnotes-and-citations.html -->

Aune-Lundberg, L., Steinnes, M., Lund, M.O., Arneberg, E. & Munsterhjelm, N. 2025. Testversjon 2 – Nasjonalt grunnkart for bruk i arealregnskap. NIBIO Rapport 11/50/2025. (in Norwegian)

Czúcz, B., Framstad, E., Clappe, S. & Nowell, M. 2025a. Exploring the use of Eurostat’s mandatory and voluntary indicators in Norway. NINA Report 2604. Norwegian Institute for Nature Research.

Czúcz, B., Lappalainen, M., Jernberg, S., Korpinen, S. 2025b. Report on definition of reference conditions that describe good ecosystem condition. SELINA Deliverable 3.3. https://project-selina.eu/ 

Denby, B. R., Gauss, M., Wind, P., Mu, Q., Grøtting Wærsted, E., Fagerli, H., Valdebenito, A., & Klein, H. (2020). Description of the uEMEP_v5 downscaling approach for the EMEP MSC-W chemistry transport model. Geoscientific Model Development, 13(12), 6303–6323. https://doi.org/10.5194/gmd-13-6303-2020

Eurostat 2024. EU Ecosystem typology. Technical Note. Version: September 2024. Eurostat. Supplementary document to Doc. ENV/EA/TF/2024_3/2a.

Eurostat 2025. Ecosystem Condition Accounts – Guidance Note, 6^th^ Draft. Eurostat Unit E2, Task Force on Ecosystem Accounting, 26-27 February 2025. Doc. ENV/EA/TF/2025_1/2. https://circabc.europa.eu/ui/group/922b4700-1c83-4099-b550-763badab3ec0/library/5074c555-99ea-4931-ace8-9351fa174f8b

Strand, G.-H., Steinnes, M., Arneberg, E., Lund, M.O., Munsterhjelm, N., Aune-Lundberg, L. & Rørholt, A. 2024. Grunnkart for bruk i arealregnskap. NIBIO Rapport 10/28/2024. (in Norwegian)

UN et al. 2024. System of Environmental Economic Accounting – Ecosystem Accounting. United Nations, Department of Economic and Social Affairs, Statistics Division. Statistical Papers, Series F No. 124.



## 7. Datasets
<!--# Describe the unique datasets seperately under seperate headers (Dataset A, Dataset B, etc.-->

All the datasets used to compile the different versions of the URAQ indicators have been thoroughly described in the previous sections, links to them are also provided for more information.

We used the following six datasets: 

* **D-1**: *PM2.5 data* (met.no): a series of raster datasets used to calculate mean PM2.5 concentration over different spatial scales. 
* **D-2**: *Grunnkart* (NIBIO): a high-resolution vector dataset used to delineate urban areas (ET01: settlements and other artificial areas)
* **D-3** *LAU data* (Local Administrative Units, Eurostat GISCO): a vector dataset was used as the primary data source to delineate the  municipalities 
* **D-4** *DEGURBA*  (Degree of urbanisation) A tabular dataset assigning one of three DEGURBA classes (1: "cities"; 2: "towns and suburbs"; 3: "rural areas") to each municipality. These classes were used to breakdown the results for URAQ_001-003.
* **D-5**: Norwegian *administrative boundaries for municipalities* (Kartverkert) were applied to update the *LAU data* to reflect recent boundary changes (Ålesund municipality divided into two smaller municipalities)
* **D-6**: Norwegian *administrative identifiers for municipalities and fylke* was used to correct the municipalities' ID numbers and to add fylke (county) IDs too. 

## 8. Spatial units
<!--# Describe the spatial units that you rely on in your analyses. Highlight the spatial units (the resolution) that the indicator values should be interpretted at. Potential spatial delineation data should eb introduced under 7.1. Datasets. We recomend using the SEEA EA terminology opf Basic Spatial Units (BSU), Ecosystem Asses (EA) and Ecosystem Accounting Area (EAA). -->

The indicator values of the PM2.5 variable can be interpreted at any spatial scale, including the original (100x100 m) raster maps (basic spatial unit, BSU). The smallest policy-relevant spatial units for all variables characterising ET01 are probably the contiguous settlement areas (bydeler: ecosystem assets, EA) and municipalities. Nevertheless, coarser ecosystem accounting areas (EAA), like the *fylke*s or the *entire country* can also be highly relevant as reporting areas.  


## 9. Analyses
<!--# Use this header for documenting the analyses. Put code in seperate code chunks, and annotate the code in between using normal text (i.e. between the chunks, and try to avoid too many hashed out comments inside the code chunks). Add subheaders as needed. 
Code folding is activated, meaning the code will be hidden by default in the html (one can click to expand it).
Caching is also activated (from the top YAML), meaning that rendering to html will be quicker the second time you do it. This will create a folder inside you project folder (called INDICATORID_cache). Sometimes caching created problems because some operations are not rerun when they should be rerun. Try deleting the cash folder and try again. -->

### Paths to data sources
Before starting any of the analyses, we store the path in which the data will be found. If readers wish to download the data and run this code, they can just change the paths below to their local paths for the rest of the code to function.
```{r}
#| eval: true
#| code-summary: "Paths to the data"

# DEGURBA from Eurostat
path_degurba <- "/data/P-Prosjekter2/412413_2023_no_egd/git_data/Adminstrative_boundaries_NO/LAU_DEGURBA_Eurostat/EU-27-LAU-2024-NUTS-2024.xlsx"

# LAUs shapefile from Eurostat
path_lau <- "/data/P-Prosjekter2/412413_2023_no_egd/git_data/Adminstrative_boundaries_NO/LAU_Eurostat/LAU_RG_01M_2023_3035.shp"
path_lau_folder <- "/data/P-Prosjekter2/412413_2023_no_egd/git_data/Adminstrative_boundaries_NO/LAU_Eurostat/"

# Municipalities from Kartverkert
path_kom <- "/data/R/GeoSpatialData/AdministrativeUnits/Norway_AdministrativeUnits/Original/Norway_Municipalities/Administrative enheter kommuner FGDB-format/Basisdata_0000_Norge_25833_Kommuner_FGDB/Basisdata_0000_Norge_25833_Kommuner_FGDB.gdb"

# Municipalities number 2023 and 2024
path_kom_nb <- "/data/P-Prosjekter2/412413_2023_no_egd/git_data/Adminstrative_boundaries_NO/NO_Fylke/kommune_fylke_region_NO_2024.xlsx"

# Grunnkart
path_grunnkart <- "/data/R/GeoSpatialData/LandUse/Norway_Arealregnskap/Original/GrunnkartArealregnskap FGDB-format/"

# Path to write results
res_path <- "/data/P-Prosjekter2/412413_2023_no_egd/Results/URAQ/"

```

### Define urban areas
To be able to delineate the *target area* for the different versions of the indicator we need to create polygons delineating (i) the urban ecosystems (i.e. ET01) from all other ecosystem types, and (ii) the municipalities from each other. In addition we will need to distinguish different types of municipalities according to their "degree of urbanisation" (DEGURBA).

#### Local Administrative Units (LAUs)
The Local Administrative Units in Norway are the municipalities. A shapefile (D-3) with the administrative boundaries of the municipalities is available from Eurostat. As we are not interested in the marine ecosystems, we chose to use Eurotat boundaries instead of those available nationally from Kartverkeret (D-5) as the boundaries excluded the sea. Unfortunately, Eurostat shapefile is from 2023, before the modification of municipalities that happened in 2024, we thus have to manipulate the shapefile from Eurostat to update it in for the municipalities Haram and Ålesund.
```{r}
#| eval: false
#| code-summary: "Update Eurostat LAUs to 2024"

# Read shapefile and select Norway
lau_no <- st_read(path_lau) %>%
           filter(CNTR_CODE == "NO")

# Read the shapefile from Kartverkert
kom_2024 <- st_read(path_kom, layer = "kommune")

# Select Haram and Ålesund municipalities
har_al_lau <- lau_no %>% 
                filter(LAU_ID == 1507)

har_al_kom <- kom_2024 %>%
                filter(kommunenummer == 1508 | kommunenummer == 1580) %>%
                st_transform(., st_crs(har_al_lau))

# Intersection between Eurostat LAU shapefile and Kartverkert 
# municipality shapefile for Haram and Ålesund municipalities 
kom_nb <- read_excel(path_kom_nb) %>%
            as.data.frame()
kom_nb$kommune_nr_2023[which(kom_nb$kommune_nr_2023 == "301")] <- "0301"

haram_2024 <- st_intersection(har_al_lau, har_al_kom[2,]) %>%
                select(c(colnames(lau_no), kommunenavn)) %>%
                select(!c(LAU_NAME)) %>%
                rename(LAU_NAME = kommunenavn) %>%
                left_join(., kom_nb, by = join_by("LAU_ID" == "kommune_nr_2023")) %>%
                select(LAU_NAME, fylke_nr, kommune_nr_2024, region_name, geometry)
haram_2024$kommune_nr_2024 <- 1580

alesund_2024 <- st_intersection(har_al_lau, har_al_kom[1,]) %>%
                select(colnames(lau_no)) %>%
                left_join(., kom_nb, by = join_by("LAU_ID" == "kommune_nr_2023")) %>%
                select(LAU_NAME, fylke_nr, kommune_nr_2024, region_name, geometry)

# Final LAUs shapefile
lau_no_2024 <- lau_no %>%
                filter(!LAU_ID == 1507) %>%
                left_join(., kom_nb, by = join_by("LAU_ID" == "kommune_nr_2023")) %>%
                select(LAU_NAME, fylke_nr, kommune_nr_2024, region_name, geometry) %>%
                rbind(., haram_2024, alesund_2024) %>%
                st_as_sf()
                
                
```

To compile the different versions of the URAQ indicators, we need to append the DEGURBA categoreis of each municipality to this shapefile. This classification is produced by Eurostat for each European municipality (D-4). In the code below we join the `DEGURBA` variable to the municipality shapefile. We finish by exporting the shapefile for further analyses with duckdb in the next section.

```{r}
#| eval: false
#| code-summary: "Add the DEGURBA variable to the LAU dataset"

# Read excel file with Degurba variable and select Norway
degurba_lau_no <- read_excel(path_degurba, sheet = "NO")

degurba_lau_no$`LAU CODE` <- as.numeric(degurba_lau_no$`LAU CODE`)
#degurba_lau_no$`LAU CODE`[which(degurba_lau_no$`LAU CODE` == 0301)] <- 301 #BC: is this needed?

# Join lau_no_2024 with DEGURBA
lau_dgurb <- inner_join(lau_no_2024,
                        degurba_lau_no,
                        by = join_by("kommune_nr_2024" == "LAU CODE")) %>%
              select(LAU_NAME, DEGURBA, fylke_nr, kommune_nr_2024, region_name, geometry) %>%
              st_as_sf()

# Export the LAUs updated shapefiles for 2024
# this is necessary for working with duckdb in the next section
st_write(lau_dgurb, paste0(path_lau_folder, "LAU_EUROSTAT_2024.shp"), append = FALSE)

# Clean the R environment
rm(list = setdiff(ls(), 
                  c("path_degurba",
                    "path_kom",
                    "path_kom_nb",
                    "path_lau",
                    "path_lau_folder",
                    "path_grunnkart",
                    "res_path",
                    "lau_dgurb")))

```

#### Settlements and Other Artificial Areas (ET01) within LAUs

Defining ET01 within LAUs requires the LAUs and the extent of the ET01 ecosystem type. LAUs have been created at the step before. ET01 can be retrieved from the Grunnkart produced by NIBIO (D-2). To identify these areas, we need to run a spatial intersections between the LAUs and the ET01 class from the Grunnkart. Such intersections are however time consuming so we will do it with the `duckdb` package which allows to decrease significantly the time of computation. Note that sadly, the geometry of the Grunnkart tile of Fylke 34 had to be cleaned outside of `duckdb` and using `sf` as some topology exceptions could not be corrected.

```{r}
#| eval: false
#| code-summary: "Settlements per LAUs"
# Code by Jennifer Hansen & Sylvie Clappe

## Path to data
# Grunnkart
gdb_files <- list.files(path_grunnkart, pattern = "_gdb\\.gdb$", 
                        full.names = TRUE)

# LAUs 2024
path_lau_2024 <- paste0(path_lau_folder, "LAU_EUROSTAT_2024.shp")

## Clean Grunnkart tile 34
# Clean
grunnkart_34 <- st_read(gdb_files[8], query = "SELECT * FROM arealregnskap WHERE okosystemtype_1 = 'Settlements and other artificial areas'") %>%
                  st_transform(., crs = "EPSG:3035") %>%
                  st_buffer(., 0)

# Check
which(st_is_valid(grunnkart_34) == FALSE) %>% length()


## Database setup
conn <- dbConnect(duckdb())
ddbs_install(conn)
ddbs_load(conn)


## Limit the number of threads (cores) duckdb uses
dbExecute(conn, "PRAGMA threads = 30")


## Register grunnkart_34 in the duckdb database
ddbs_write_vector(conn, grunnkart_34, "grunnkart_valid_34")



# Check that the table was registered
ddbs_list_tables(conn)

## Write SQL queries to re-project the grunnkart and make its geometry valid
query_valid <-glue("
CREATE TABLE grunnkart_valid AS
SELECT
  okosystemtype_1,
  ST_Transform(ST_MakeValid(geo), 'EPSG:25832', 'EPSG:3035', true) AS geom
  FROM grunnkart
  WHERE okosystemtype_1 = 'Settlements and other artificial areas'
")

query_valid_18_55 <- glue("
CREATE TABLE grunnkart_valid AS
SELECT
  okosystemtype_1,
  ST_Transform(ST_MakeValid(geo), 'EPSG:25833', 'EPSG:3035', true) AS geom
  FROM grunnkart
  WHERE okosystemtype_1 = 'Settlements and other artificial areas'
")

query_valid_34 <- glue("
CREATE TABLE grunnkart_valid AS
SELECT
  okosystemtype_1,
  geo AS geom
  FROM grunnkart_valid_34
  WHERE okosystemtype_1 = 'Settlements and other artificial areas'
")

query_valid_56 <- glue("
CREATE TABLE grunnkart_valid AS
SELECT
  okosystemtype_1,
  ST_Transform(ST_MakeValid(geo), 'EPSG: 25835', 'EPSG:3035', true) AS geom
  FROM grunnkart
  WHERE okosystemtype_1 = 'Settlements and other artificial areas'
")

query_intersect <- glue("
CREATE TABLE grunnkart_intersection AS
SELECT g.*, l.*
FROM grunnkart_valid g
JOIN lau_fylke l
ON ST_Intersects(g.geom, l.geom)")

query_drop <- glue("
ALTER TABLE grunnkart_intersection
DROP COLUMN geom_1")


## Intersection

# Create function to do the spatial intersection
# includes registration of grunnkart and its cleaning
do_intersection <- function(db_connexion, fylke, path_list, fylke_index_path_list, bd_path){
  
  if(fylke %in% c(3, 11, 15, 40, 42, 46, 31, 33, 32, 39, 50)){
    
    # Register Grunnkart for the specific fylke
    idx <- which(fylke_index_path_list == fylke)
    ar_path <- normalizePath(path_list[idx])
    ar_layer <- "arealregnskap"
    dbExecute(db_connexion, glue("
  CREATE VIEW grunnkart AS 
  SELECT *,
  FROM ST_Read('{ar_path}', layer='{ar_layer}')"))
    
    # Register LAU for specific Fylke
    lau_path <- bd_path
    dbExecute(db_connexion, glue("
  CREATE VIEW lau_fylke AS 
  SELECT *,
  FROM ST_Read('{bd_path}')"))
    
    # Spatial intersect to join the variables of both datasets before intersection
    dbExecute(db_connexion, query_valid)
    dbExecute(db_connexion, query_intersect)
    dbExecute(db_connexion, query_drop)
    
    # Perform spatial intersection
    soaa_lau <- ddbs_intersection(db_connexion, x = "grunnkart_intersection", y = "lau_fylke", crs = "EPSG:3035")
    
    # Drop the grunnkart register tables
    dbExecute(db_connexion, "DROP VIEW grunnkart")
    dbExecute(db_connexion, "DROP VIEW lau_fylke")
    dbExecute(db_connexion, "DROP TABLE grunnkart_valid")
    dbExecute(db_connexion, "DROP TABLE grunnkart_intersection")
    
    # Return the spatial intersection
    return(soaa_lau)
    
  } else if(fylke %in% c(18, 55)){
    
    # Register grunnkart for the specific fylke
    idx <- which(fylke_index_path_list == fylke)
    ar_path <- path_list[idx]
    ar_layer <- "arealregnskap"
    dbExecute(db_connexion, glue("
  CREATE VIEW grunnkart AS 
  SELECT *,
  FROM ST_Read('{ar_path}', layer='{ar_layer}')"))
    
    # Register LAU for specific Fylke
    lau_path <- bd_path
    dbExecute(db_connexion, glue("
  CREATE VIEW lau_fylke AS 
  SELECT *,
  FROM ST_Read('{bd_path}')"))
    
    # Spatial intersect to join the variables of both datasets before intersection
    dbExecute(db_connexion, query_valid_18_55)
    dbExecute(db_connexion, query_intersect)
    dbExecute(db_connexion, query_drop)
    
    # Perform spatial intersection
    soaa_lau <- ddbs_intersection(db_connexion, x = "grunnkart_intersection", y = "lau_fylke", crs = "EPSG:3035")
    
    # Drop the grunnkart register tables
    dbExecute(db_connexion, "DROP VIEW grunnkart")
    dbExecute(db_connexion, "DROP VIEW lau_fylke")
    dbExecute(db_connexion, "DROP TABLE grunnkart_valid")
    dbExecute(db_connexion, "DROP TABLE grunnkart_intersection")
    
    # Return the spatial intersection
    return(soaa_lau)
    
  } else if(fylke == 56){
    
    # Register Grunnkart for the specific fylke
    idx <- which(fylke_index_path_list == fylke)
    ar_path <- path_list[idx]
    ar_layer <- "arealregnskap"
    dbExecute(db_connexion, glue("
  CREATE VIEW grunnkart AS 
  SELECT *,
  FROM ST_Read('{ar_path}', layer='{ar_layer}')"))
    
    # Register LAU for specific Fylke
    lau_path <- bd_path
    dbExecute(db_connexion, glue("
  CREATE VIEW lau_fylke AS 
  SELECT *,
  FROM ST_Read('{bd_path}')"))
    
    # Spatial intersect to join the variables of both datasets before intersection
    dbExecute(db_connexion, query_valid_56)
    dbExecute(db_connexion, query_intersect)
    dbExecute(db_connexion, query_drop)
    
    # Perform spatial intersection
    soaa_lau <- ddbs_intersection(db_connexion, x = "grunnkart_intersection", y = "lau_fylke", crs = "EPSG:3035")
    
    # Drop the grunnkart register tables
    dbExecute(db_connexion, "DROP VIEW grunnkart")
    dbExecute(db_connexion, "DROP VIEW lau_fylke")
    dbExecute(db_connexion, "DROP TABLE grunnkart_valid")
    dbExecute(db_connexion, "DROP TABLE grunnkart_intersection")
    
    return(soaa_lau)
    
  } else if(fylke == 34){
    
    # Register LAU for specific Fylke
    lau_path <- bd_path
    dbExecute(db_connexion, glue("
  CREATE VIEW lau_fylke AS 
  SELECT *,
  FROM ST_Read('{bd_path}')"))
    
    # Spatial intersect to join the variables of both datasets before intersection
    dbExecute(db_connexion, query_valid_34)
    dbExecute(db_connexion, query_intersect)
    dbExecute(db_connexion, query_drop)
    
    # Perform spatial intersection
    soaa_lau <- ddbs_intersection(db_connexion, x = "grunnkart_intersection", y = "lau_fylke", crs = "EPSG:3035")
    
    # Drop the grunnkart register tables
    dbExecute(db_connexion, "DROP VIEW lau_fylke")
    dbExecute(db_connexion, "DROP TABLE grunnkart_valid")
    dbExecute(db_connexion, "DROP TABLE grunnkart_intersection")
    
    return(soaa_lau)
    
  } else (retrun("an error has occured"))
  
}

# Create the input to the intersection function
numextract <- function(string){str_extract(string, "[-+]?[0-9]*\\.?[0-9]+")
}  
fylke_nb_gdb_vec <- map(gdb_files, ~ numextract(.x)) %>%
                      unlist() %>%
                      as.numeric()

# Perform the intersection
soaa_lau_inter <- map(fylke_nb_gdb_vec, 
                      ~ do_intersection(conn, .x, gdb_files, fylke_nb_gdb_vec, path_lau_2024))


# Close the connection to duckdb database (remove in-memory dB)
dbDisconnect(conn)

# Clean the R environment
rm(list = setdiff(ls(), 
                  c("path_degurba",
                    "path_kom",
                    "path_kom_nb",
                    "path_lau",
                    "path_lau_folder",
                    "path_grunnkart",
                    "res_path",
                    "soaa_lau_inter",
                    "lau_dgurb")))
```


### PM2.5 concentration
#### Load the data
We can now read in the PM2.5 concentration maps (D-1) for each of the municipalities. As the PM2.5 maps are available from met.no using an API, we first create a list of the maps that should be accessed before retrieving the data through the API. The PM2.5 maps are retrieved in .tif format. Note that the data have to be called through the API and written on the disk. Due to their format, they couldn't be loaded in the R environment. The code below shows how to retrieve the data and write them on a chosen folder in your computer. If you do not need to run this code, go to the next step.
```{r}
#| eval: false
#| code-summary: "Load PM2.5 concentration maps and store them on disk"

## Create list of urls

# Base url
begin_url <- "https://airquality-expert.met.no/airqualityexpert/0.2/map/"
end_url <- "/pm25_concentration_annualmean.tif"

# List of municipalities numbers
path_lau_2024 <- paste0(path_lau_folder, "LAU_EUROSTAT_2024.shp")
lau_2024 <- st_read(path_lau_2024)

lau_nb <- unique(lau_2024$k__2024) %>%
            sprintf("%04i",.) # 4-digits w padding zeros (e.g. "0301")


# List the years of interest
yrs <- seq(2016, 2023, 1)

# Create the urls
url_list <- map(seq_along(yrs), 
                ~ map_chr(seq_along(lau_nb), 
                          function(y) {paste0(begin_url,
                                       lau_nb[y],
                                       "/",
                                       yrs[.x],
                                       end_url)}
                          )
                )


## Write API query function: retrieve the data and write them on the disk
api_fetch_data <- function(year_vec, municipality_vec, year, municipality, out_path, url_list){

  idx_year <- which(year_vec == year)
  idx_municip <- which(municipality_vec == municipality)
  
  # Create a request
  req <- request(url_list[[idx_year]][idx_municip])
  
  # Perform the request
  fetch_data <- req %>% 
                 req_perform()
  
  # Write data in GIS folder       
  resp_body_raw(fetch_data) %>% 
    writeBin(., paste0(out_path, year, "/PM25_", year, "_", municipality, ".tif"))
  }


## Retrive and write the PM2.5 data on the disk
map(seq_along(yrs), 
    ~ map(seq_along(lau_nb), function(y) {
      api_fetch_data(yrs, 
                     lau_nb, 
                     yrs[.x], 
                     lau_nb[y], 
                     out_path = "/data/P-Prosjekter2/412413_2023_no_egd/git_data/PM2.5/",
                     url_list = url_list)}
      )
    )

api_fetch_data(yrs, lau_nb, 2016, "1508", 
               out_path= "/data/P-Prosjekter2/412413_2023_no_egd/git_data/PM2.5/",
               url_list = url_list)

## Clean the R environment
rm(list = setdiff(ls(), 
                  c("path_degurba",
                    "path_kom",
                    "path_kom_nb",
                    "path_lau",
                    "path_lau_folder",
                    "path_grunnkart",
                    "res_path",
                    "soaa_lau_inter",
                    "lau_dgurb",
                    "yrs",
                    "lau_nb")))
```

#### Extract PM2.5 concentration in urban areas
Urban areas are defined in two ways in this project: (1) the total area of the LAU; or (2) the total area of the class "Settlements and other artificial areas" (ET01), from the EU Ecosystem Typology, within the LAUs. The mean concentration of PM2.5for case (1) is easy to get as it can be calculated based on the entire PM2.5 concentration maps that we downloaded above. For case (2) however, further manipulations are needed as we need to only extract the raster cells of the PM2.5 concentration maps that overlap with the ET01 polygons. This is what we do in the code below. Note that the function used for this (`exact_extract()`) only works if the geometry type is polygon or multipolygon. Hence, we first need to clean the ET01 maps that we created before to only extract the polygons. 

During the extraction of the raster cell values, there will be the creation of "NA" values. This means that some polygon will have a PM2.5 concentration of "NA". This is an artifact due to the raster format of the PM2.5 concentration maps. While comparing them with the polygon of the municipalities, we noticed that some municipal raster maps were smaller than their associated municipal polygon.Hence, some polygons of settlements sadly fall outside of the PM2.5 concentration map while being in the municipal polygon. This leads to the creation of "NA" values. We added a step of cleaning in the code below to remove these "NA" values.

One last note on the code below: to speed up the computation time, parallel computing has been used through the new `in_parallel()` function from the `purrr` package. This requires to make some adjustments in the code to make sure that the `workers`, or jobs running in parallel, have the objects present in  the R environment and the packages. Indeed, when using `in_parallel()`, all packages and R objects of the environment are invisible to the `workers` if not explicitly stated in the `in_parallel()` function.

```{r}
#| eval: false
#| code-summary: "Compile PM2.5 concentration in urban areas"

## Iteration variables (if the code above hasn't been run)
# List of municipalities numbers 
path_lau_2024 <- paste0(path_lau_folder, "LAU_EUROSTAT_2024.shp")
lau_2024 <- st_read(path_lau_2024)

lau_nb <- unique(lau_2024$k__2024) %>%
            sprintf("%04i",.) # 4-digits w padding zeros (e.g. "0301")

# List the years of interest
yrs <- seq(2016, 2023, 1)

## Clean ET01: keep only polygons
daemons(15)
soaa_lau <-  soaa_lau_inter %>%
              map(., in_parallel(~ sf:::st_collection_extract(.x,
                    type = "POLYGON", 
                    warn = FALSE))) %>%
              compact() %>%  
              bind_rows()

daemons(0)
  

## Create function to read the raster and extract the raster cells corresponding to SOOA
extract_rast <- function(path_rast_folder, soaa_shp, municipality, year){

  # Load packages so they are available in environment fo the worker for parallel computing
  library(dplyr)
  library(sf)
  library(terra)
  library(exactextractr)

  # Read in data
  municip_rast <- rast(paste0(path_rast_folder, year, "/PM25_", year, "_", municipality, ".tif"))
  soaa_bd <- soaa_shp %>%
              st_transform(., crs(municip_rast)) %>%
              mutate(soaa_area_m2 = unclass(st_area(.)))

  # Extract raster cells
  soaa_lau_pm25 <- soaa_bd %>%
                    exact_extract(municip_rast,
                                  .,
                                  fun = c("mean"),
                                  append_cols = TRUE) %>%
                    filter(!is.na(mean) == TRUE) %>%  # Cleaning step
                    mutate(., year = year)
  return(soaa_lau_pm25)
}

## Extract PM2.5 mean concentration per ET01 polygon
daemons(8)

soaa_pm25 <- map(seq_along(lau_nb), function(municipality_idx){
  
  # Filter municipality
  municipality_code <- lau_nb[municipality_idx]
  soaa_filtered <- soaa_lau %>%
                    filter(k__2024 == as.numeric(municipality_code))
  
  # Parallelise the extraction of PM2.5 cells for each year
  
  pm25_cells <- map(seq_along(yrs), in_parallel(function(j){
      extract_rast(
      path_rast_folder = "/data/P-Prosjekter2/412413_2023_no_egd/git_data/PM2.5/",
      soaa_shp = soaa_filtered,
      municipality = municipality_code,
      year = yrs[j]
    )
    }, extract_rast = extract_rast,
    soaa_filtered = soaa_filtered,
    municipality_code = municipality_code,
    yrs = yrs))
  
  return(pm25_cells)
  
  })

daemons(0)


## Clean the R environment
rm(list = setdiff(ls(), 
                  c("path_degurba",
                    "path_kom",
                    "path_kom_nb",
                    "path_lau",
                    "path_lau_folder",
                    "path_grunnkart",
                    "res_path",
                    "soaa_lau",
                    "lau_dgurb",
                    "yrs",
                    "lau_nb",
                    "soaa_pm25")))
```

#### Compile mean PM2.5 concentration in urban areas
Now that we have the PM2.5 concentration for the whole municipalities (PM2.5 raster maps), and within the ET01 of municipalities (see section above), we can calculate the mean concentration over both these areas.

```{r}
#| eval: false
#| code-summary: "Mean PM2.5 concentration in urban areas"

## Average PM2.5 in the municipality
# Create an averaging function
read_and_compile_pm25 <- function(path_rast_folder, year, municipality){
  
  # Load libraries for workers
  library(terra)
  library(dplyr)
  
  # Read in data
  municip_rast <- rast(paste0(path_rast_folder, year, "/PM25_", year, "_", municipality, ".tif"))
  
  # Average
  av_pm25_municip <- values(municip_rast) %>% 
                      .[!is.na(.)] %>%
                      mean()
  sd_pm25_municip <- values(municip_rast) %>% 
                      .[!is.na(.)] %>%
                      sd()
  
  # Return a vector of results
  res <- data.frame(mean_pm25_municip_ug_m3 = av_pm25_municip, 
                    sd_pm25_municip_ug_m3 = sd_pm25_municip,
                    year = year, 
                    kommune_nummer = as.numeric(municipality))
  
  return(res)
                      
}

# Run the averaging function
daemons(10)

all_combinations <- expand.grid(seq_yrs = seq_along(yrs), seq_lau_nb = seq_along(lau_nb))

municip_pm25_av <- map2(all_combinations$seq_yrs, all_combinations$seq_lau_nb,
                   in_parallel(function(x, y){
                     read_and_compile_pm25(path_rast_folder = "/data/P-Prosjekter2/412413_2023_no_egd/git_data/PM2.5/",
                                           year = yrs[x], 
                                           municipality = lau_nb[y]
                                           )
                                          },
                     read_and_compile_pm25 = read_and_compile_pm25,
                     lau_nb = lau_nb, 
                     yrs = yrs
                          )
                   )
daemons(0)




##Create the raw data
# Calculate municipality total area
lau_total_area <- lau_2024 %>%
                    mutate(area_m2 = unclass(st_area(.))) %>%
                    st_drop_geometry() %>%
                    select(LAU_NAM, k__2024, DEGURBA, area_m2)

# Create raw datasets
municip_pm25_df <- municip_pm25_av %>%
                    compact() %>%
                    bind_rows() %>%
                    left_join(., lau_total_area, join_by(kommune_nummer == k__2024))


soaa_pm25_df <- soaa_pm25 %>%
                  compact() %>%
                  bind_rows() 

## Average PM2.5 in the ET01 of the municipality
soaa_pm25_av <- soaa_pm25_df %>%
                  rename(kommune_nummer = k__2024) %>%
                  select(year, LAU_NAM, kommune_nummer, DEGURBA, soaa_area_m2, mean) %>%
                  group_by(year, LAU_NAM, kommune_nummer, DEGURBA) %>%
                  summarise(mean_soaa_pm25_ug_m3 = mean(mean),
                            w_mean_soaa_pm25_ug_m3 = round2(weighted.mean(mean, soaa_area_m2), 2),
                            sd_soaa_pm25_ug_m3 = round2(sd(mean), 2),
                            count_n = n(),
                            se_soaa_pm25_ug_m3 = round2(sd(mean)/sqrt(count_n), 2),
                            total_soaa_m2 = sum(soaa_area_m2))


```

### Export result tables to derive URAQ
```{r}
#| eval: false
#| code-summary: "Export result tables"

## Export raw data
write.table(soaa_pm25_df, paste0(res_path, "URAQ_SOAA_raw_data_table_10OCT2025.csv"), sep = ";", row.names = FALSE)
write.table(soaa_pm25_av, paste0(res_path, "URAQ_SOAA_summary_table_10OCT2025.csv"), sep = ";", row.names = FALSE)
write.table(municip_pm25_df, paste0(res_path, "URAQ_municipality_summary_table_10OCT2025.csv"), sep = ";", row.names = FALSE)

```


## 10. Results
<!--# Repeat the final results here. Typically this is a map or table of indicator values.
This is typically where people will harvest data from, so make sure to include all relevant output here, but don't clutter this section with too much output either. -->

From the summary table that we exported previously, we create a summary table with the following indicators:

* **URAQ_000**: Average PM2.5 concentration in the *whole area of* the municipalities considered as "cities" according to Eurostat classification: degree of urbanisation equal to 1 (`DEGURBA = 1`)

* **URAQ_001**: Average PM2.5 concentration in the urban areas (class ET01: Settlements and other artificial areas of the EU Ecosystem Typology) within the municipalities considered as "cities" according to Eurostat classification: degree of urbanisation equal to 1 (`DEGURBA = 1`)

* **URAQ_002**: Average PM2.5 concentration  in the urban areas (class ET01: Settlements and other artificial areas of the EU Ecosystem Typology) within the municipalities considered as "towns and suburbs" according to Eurostat classification: degree of urbanisation equal to 1 (`DEGURBA = 2`)

* **URAQ_003**: Average PM2.5 concentration  in the urban areas (class ET01: Settlements and other artificial areas of the EU Ecosystem Typology) within the municipalities considered as "rural areas" according to Eurostat classification: degree of urbanisation equal to 1 (`DEGURBA = 3`)

* **URAQ_004**: Average PM2.5 concentration in the urban areas of Norway (class ET01: Settlements and other artificial areas of the EU Ecosystem Typology) 

Below, we present two kinds of summary table: one national, and one presenting a breakdown by municipalities. Note that at municipality level, URAQ_000 does not present any standard error due to methodological limitations of the data.

### National Results
```{r}
#| eval: true
#| code-summary: "National summary table"

# Read exported table
soaa_res_processed <- read.table(paste0(res_path, "URAQ_SOAA_summary_table_10OCT2025.csv"), sep = ";", head = TRUE)
municip_res_processed <- read.table(paste0(res_path, "URAQ_municipality_summary_table_10OCT2025.csv"), sep = ";", head = TRUE)

# Compile the different URAQ indicators at national level
uraq_000_nat <- municip_res_processed %>%
                select(year, kommune_nummer, DEGURBA, mean_pm25_municip_ug_m3, area_m2) %>%
                filter(DEGURBA == 1) %>%
                group_by(year) %>%
                summarise(w_mean_pm25_nat = round2(weighted.mean(mean_pm25_municip_ug_m3, area_m2), 2),
                          count_n = n(), 
                          se_pm25_nat = round2(sd(mean_pm25_municip_ug_m3)/sqrt(count_n), 2)) %>%
                mutate(ID = "URAQ 000") 

uraq_001_nat <- soaa_res_processed %>%
                select(year, DEGURBA, mean_soaa_pm25_ug_m3, total_soaa_m2) %>%
                filter(DEGURBA == 1) %>%
                group_by(year) %>%
                summarise(w_mean_pm25_nat = round2(weighted.mean(mean_soaa_pm25_ug_m3, total_soaa_m2), 2),
                          count_n = n(),
                          se_pm25_nat = round2(sd(mean_soaa_pm25_ug_m3)/sqrt(count_n), 2)) %>%
                mutate(ID = "URAQ 001")

uraq_002_nat <- soaa_res_processed %>%
                select(year, DEGURBA, mean_soaa_pm25_ug_m3, total_soaa_m2) %>%
                filter(DEGURBA == 2) %>%
                group_by(year) %>%
                summarise(w_mean_pm25_nat = round2(weighted.mean(mean_soaa_pm25_ug_m3, total_soaa_m2), 2),
                          count_n = n(),
                          se_pm25_nat = round2(sd(mean_soaa_pm25_ug_m3)/sqrt(count_n), 2)) %>%
                mutate(ID = "URAQ 002")

uraq_003_nat <- soaa_res_processed %>%
                select(year, DEGURBA, mean_soaa_pm25_ug_m3, total_soaa_m2) %>%
                filter(DEGURBA == 3) %>%
                group_by(year) %>%
                summarise(w_mean_pm25_nat = round2(weighted.mean(mean_soaa_pm25_ug_m3, total_soaa_m2), 2),
                          count_n = n(),
                          se_pm25_nat = round2(sd(mean_soaa_pm25_ug_m3)/sqrt(count_n), 2)) %>%
                mutate(ID = "URAQ 003")

uraq_004_nat <- soaa_res_processed %>%
                select(year, mean_soaa_pm25_ug_m3, total_soaa_m2) %>%
                group_by(year) %>%
                summarise(w_mean_pm25_nat = round2(weighted.mean(mean_soaa_pm25_ug_m3, total_soaa_m2), 2),
                          count_n = n(),
                          se_pm25_nat = round2(sd(mean_soaa_pm25_ug_m3)/sqrt(count_n), 2)) %>%
                mutate(ID = "URAQ 004")

res_national <- bind_rows(uraq_000_nat,
                          uraq_001_nat,
                          uraq_002_nat,
                          uraq_003_nat,
                          uraq_004_nat) %>%
                mutate(Indicator = "Urban Air Quality",
                       Accounting_area = "Norway") %>%
                select(Indicator, ID, Accounting_area, year, w_mean_pm25_nat, se_pm25_nat)

colnames(res_national) <- c("Indicator",
                            "ID",
                            "Accounting area",
                            "Accounting period",
                            "Average PM2.5 concentration µg/m3",
                            "Standard error (µg/m3)")

datatable(res_national)
```

### Municipality level
Note that URAQ_004 is not reported here as  this indicator is only for national level. An area-weigthed mean of URAQ_001 to URAQ_003 would sum to URAQ_004.
```{r}
#| eval: true
#| message : false
#| code-summary: "Municipal summary table"

# Read exported table
soaa_res_processed <- read.table(paste0(res_path, "URAQ_SOAA_summary_table_10OCT2025.csv"), sep = ";", head = TRUE)
municip_res_processed <- read.table(paste0(res_path, "URAQ_municipality_summary_table_10OCT2025.csv"), sep = ";", head = TRUE)

# Compile the different URAQ indicators at national level
uraq_000_mun <- municip_res_processed %>%
                select(year, kommune_nummer, LAU_NAM, DEGURBA, mean_pm25_municip_ug_m3) %>%
                rename(w_mean_pm25_ug_m3 = mean_pm25_municip_ug_m3) %>%
                mutate(se_pm25_ug_m3 = NA,
                       ID = "URAQ 000")

uraq_001_mun <- soaa_res_processed %>%
                select(year, kommune_nummer, LAU_NAM, DEGURBA, w_mean_soaa_pm25_ug_m3, se_soaa_pm25_ug_m3) %>%
                rename(w_mean_pm25_ug_m3 = w_mean_soaa_pm25_ug_m3,
                        se_pm25_ug_m3 = se_soaa_pm25_ug_m3) %>%
                filter(DEGURBA == 1) %>%
                mutate(ID = "URAQ 001")

uraq_002_mun <- soaa_res_processed %>%
                select(year, kommune_nummer, LAU_NAM, DEGURBA, w_mean_soaa_pm25_ug_m3, se_soaa_pm25_ug_m3) %>%
                rename(w_mean_pm25_ug_m3 = w_mean_soaa_pm25_ug_m3,
                        se_pm25_ug_m3 = se_soaa_pm25_ug_m3) %>%
                filter(DEGURBA == 2) %>%
                mutate(ID = "URAQ 002")

uraq_003_mun <- soaa_res_processed %>%
                select(year, kommune_nummer, LAU_NAM, DEGURBA, w_mean_soaa_pm25_ug_m3, se_soaa_pm25_ug_m3) %>%
                rename(w_mean_pm25_ug_m3 = w_mean_soaa_pm25_ug_m3,
                        se_pm25_ug_m3 = se_soaa_pm25_ug_m3) %>%
                filter(DEGURBA == 3) %>%
                mutate(ID = "URAQ 003")

res_municip <- bind_rows(uraq_000_mun,
                         uraq_001_mun,
                         uraq_002_mun,
                         uraq_003_mun) %>%
              mutate(Indicator = "Urban Air Quality") %>%
              select(Indicator, ID, kommune_nummer, LAU_NAM, year, w_mean_pm25_ug_m3, se_pm25_ug_m3)

res_municip$se_pm25_ug_m3 <- as.character(res_municip$se_pm25_ug_m3) %>%
                                replace_na("Not available")

colnames(res_municip) <- c("Indicator",
                           "ID",
                           "Accounting area (municipality number)",
                           "Accounting area (municipality name)",
                           "Accounting period",
                           "Average PM2.5 concentration (µg/m3)",
                           "Standard error (µg/m3)")


datatable(res_municip)
```



## 11. Export file
<!--# Optional: Display the code (don't execute it) or the workflow for exporting the indicator values to file. Ideally the indicator values are exported as a georeferenced shape or raster file with indicators values, reference values and errors. You can also chose to export the raw (un-normalised or unscaled variable) as a seperate product. You should not save large sptaial output data on GitHub. You can use eval=FALSE to avoid code from being executed (example below - delete if not relevant) -->

Finally we present a sample code which can export the results into csv or xlsx files: 

```{r export}
#| eval: false
#| code-summary: "Code to export the result tables above"

#CSV
write.table(res_national, "URAQ_NO_national_2016_2023.csv")
write.table(res_municip, "URAQ_NO_regional_2016_2023.csv")

# #Excel
# write_xlsx(res_national, "URAQ_NO_national_2016_2023.xlsx")
# write_xlsx(res_municip, "URAQ_NO_regional_2016_2023.xlsx")

```

