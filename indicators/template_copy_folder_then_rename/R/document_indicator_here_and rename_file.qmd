---
title: "Enter indicator name here"
subtitle: "[INDICATORID]"
indicatorID: 
  - INDICATORID
  - INDICATORID2 # delete whole line if not needed
indicatorName: 
  - INDICATOR_NAME # add more by adding another line starting '-'
country: country
continent: continent
ECT: ECT # e.g. A2 - Chemical State characteristics
Realm: 
  - Realm # e.g. Freshwater (F)
Biome: 
  - Biome # e.g. F1 Rivers and streams biome
Ecosystem: 
  - Ecosystem # e.g. F1.3 Freeze-thaw streams
yearAdded: 2025
yearLastUpdate: 2025
status: incomplete
Version: "000.001"
VersionComment: First complete version
url: 
Normalised: 
SpatialAggregationPathway: # e.g. Scale - Transform - Aggregate (length-weighted arithmetic mean) - Truncate
format: 
  html:
    embed-resources: true
    code-fold: true
    toc: true
    toc-title: Contents
    toc-depth: 3
    smooth-scroll: true
execute: 
  cache: true
author:
  - name: John Doe              # Enter name
    email: john.doe@example.no  # Enter email
    affiliations:
      - id: myID
        name: A Fictive Institute for Nature Research # Enter affiliations
  - name: Jane Doe              #  Enter subsequent authors like this, or remove if not relevant
    affiliations:
      - ref: myID               # To reuse affiliations reference the id like this
date: January 1, 1901 # Enter date
data_availability: gold
code_reproducibility: bronze
open_science_badge: silver
callout-icon: false
lightbox: true
css: ../../../style.css
code-links:
      - text: Add a review
        icon: github
        href: https://github.com/NINAnor/ecRxiv
---

<!--# This is a template for how to document the indicator analyses. Make sure also to not change the order, or modify, the headers, unless you really need to. This is because it easier to read if all the indicators are presented using the same layout. If there is one header where you don't have anything to write, just leave the header as is, and don't write anything below it. If you are providing code, be careful to annotate and comment on every step in the analysis. Before starting it is recommended to fill in as much as you can in the metadata file. This file will populate the initial table in your output.-->

<!--# Load all you dependencies here -->

```{r setup}
#| include: false
library(knitr)
library(tidyverse)
library(kableExtra)
library(here)
library(anybadger)
library(yaml)
library(tibble)
library(conflicted)
# weird workarounds for cache issues
conflicts_prefer(dplyr::filter)
conflicts_prefer(dplyr::lag)
conflicts_prefer(dplyr::select)
pull<-dplyr::pull

knitr::opts_chunk$set(echo = TRUE)
```

```{r source}
#| echo: false
#| cache: false
source(here::here("_common.R"))
```

```{r extractFromYML}
#| echo: false
#| cache: false

# Get the current .qmd file being rendered
this_file <- knitr::current_input()
# this_file <- here::here("indicators","template_copy_folder_then_rename", "R","document_indicator_here_and rename_file.qmd")
# Read the YAML front matter
lines <- readLines(this_file, warn = FALSE)
dash_lines <- which(trimws(lines) == "---")
yaml_block <- lines[(dash_lines[1] + 1):(dash_lines[2] - 1)]
yaml_data <- yaml::yaml.load(paste(yaml_block, collapse = "\n"))

# Robust flatten function
flatten_to_string <- function(x) {
  if (is.list(x)) {
    # recursively flatten any nested lists
    x <- unlist(x, recursive = TRUE)
  }
  # convert to single string
  paste(x, collapse = "; ")
}

# Apply to all YAML entries
yaml_data_flat <- lapply(yaml_data, flatten_to_string)

# Create tibble
meta <- tibble::enframe(yaml_data_flat, name = "Variable", value = "Value")

# Check structure
#str(meta)

st <- meta |>
  dplyr::filter(Variable == "status") |>
  pull(Value)
version <- meta |>
  dplyr::filter(Variable == "Version") |>
  pull(Value)
auth <- meta |>
  dplyr::filter(Variable == "authors") |>
  pull(Value)
year <- meta |>
  dplyr::filter(Variable == "yearAdded") |>
  pull(Value)
id <- meta |>
  dplyr::filter(Variable == "indicatorID") |>
  pull(Value)
name <- meta |>
  dplyr::filter(Variable == "indicatorName") |>
  pull(Value)
url <- meta |>
  dplyr::filter(Variable == "url") |>
  pull(Value)
badges<-meta |> 
  dplyr::filter(Variable %in% c("data_availability",
         "code_reproducibility", "open_science_badge")) |> 
  pull(Value)

meta <- meta |>
  dplyr::mutate(Variable = dplyr::case_match(Variable,
    "indicatorID" ~ "Indicator ID" ,
    "indicatorName" ~ "Indicator Name",
    "country" ~ "Country",
    "continent" ~ "Continent",
    "ECT" ~ "Ecosystem Condition Typology Class",
    "yearAdded" ~ "Year added",
    "yearLastUpdate" ~ "Last update",
    .default = Variable
  )) |>
  dplyr::filter(Variable != "authors")

```



<!--# The following parts are autogenerated. Do not edit. -->

::: {layout-ncol="5"}

```{r statusBadge}
#| echo: false
status_badge(as.character(st))
```

```{r versionBadge}
#| echo: false
version_badge(version_number = as.character(version[[1]]))
```

```{r dataBadge}
#| echo: false
data_badge(as.character(badges[[1]]))
```

```{r codeBadge}
#| echo: false
code_badge(as.character(badges[[2]]))
```

```{r openScienceBadge}
#| echo: false
open_science_badge(as.character(badges[[3]]))
```
::: 
 

> **Recommended citation**: `r paste(auth, " ", year, ". ", name, " (ID: ", id, ") ", "v. ", version, ". ecRxiv: ", url, sep="")`



::: {.callout-tip collapse="true"}
## Metadata
```{r tbl-meta2}
#| tbl-cap: 'Indicator metadata'
#| echo: false
#| warning: false
meta |>
  dplyr::filter(Variable %in% c("Indicator ID","Indicator Name","Country","Continent","Ecosystem Condition Typology Class", "Year added", "Last update")) |>   kable()

meta |>
  dplyr::select(Variable, Value) |>
  kbl(col.names = NULL) 

```
:::

::: {.callout-tip collapse="true"}

## Log

<!--# Update this logg with short messages for each update -->
- 01 Jan. 1901 - Original PR
:::


<hr />

<!--# Document you work below.  -->

## 1. Summary

<!--# 

With a maximum of 300 words, describe the indicator in general terms as you would to a non-expert. Think of this as a kind of common language summary. It is a good idea to include a bullet point list of the specific steps in the workflow. Include a mention of the following aspects:

What does the metric represent?
Why is this relevant for describing ecosystem condition in this ecosystem?
What are the main anthropogenic impact factors?
What kind of data is used? 
Shortly, how is the data customized (modified, estimated, integrated) to fit its purpose as an indicator?
What is the current status of  the metric (can it be used or is it still in development)?
How should the metric be used and interpreted, and how should it not be used/interpretted?

 -->

> ### Interpretation
<!-- Add a very short description of how the indicator values should be interpreted. Here's an example for a bumblebee indicator: An indicator value of 1 signifies an intact bumblebee community. Values decreasing toward zero reflect negative ecological change, specifically the decline of species expected to be present. This metric does not account for potentially positive changes, such as increases in species' abundance or the arrival of new species. Tip: Add text on the line directly following the subheader, and don't introduce blank lines. This way the whole paragraph renders as a block quote.    
  -->
An indicator value of 1 signifies ...
Values decreasing toward zero reflect...

## 2. About the underlying data

<!--# Give a general introduction the datasets you have used, and provide more specific details in the sub-chapters.  -->

### 2.1 Spatial and temporal resolution and extent

<!--# Describe the temporal and spatial resolution and extent of the data used -->

### 2.2 Sampling design

<!-- How was the data sampled? Describe potential sampling biases -->

### 2.3 Original units

<!--# What are the original units for the most relevant  variables in the data-->


### 2.3 Instructions for citing, using and accessing data

<!--# Is the data openly available? If not, how can one access it? What are the key references to the datasets?   -->

### 2.4 Additional comments about the dataset

<!--# Optional. Text here -->

## 3. Indicator properties

### 3.1 Ecosystem Condition Typology Class (ECT)

<!--# Describe the rationale for assigning the indicator to the ECT class. See https://oneecosystem.pensoft.net/article/58218/
This doesnt need to be very long. Maybe just a single sentence. -->

### 3.1.1 Other condition typologies

<!--# Optional: Add text about other standards or typologies, such as alternative national condition typologies, and how the indicator relates to these -->


### 3.2 Ecosystem condition characteristic

<!--# 

Describe the ecosystem condition characteristic represented in the indicator. See 10.3897/oneeco.6.e58218 for information on what these characteristics might be.
For example, and indicator called 'Trenching in mires' could be made to represent an ecosystem characteristic 'Intact hydrology'. The term 'characteristic' is used similar to the term 'criteria' in Multiple Criteria Decision Making.  

-->

### 3.3 Collinearities with other indicators

<!--# Describe known collinearities with other metrics (indicators or variables) that could become problematic if they were also included in the same Ecosystem Condition Assessment as the indicator described here. -->


### 3.4 Impact factors

<!--# Describe the main natural and anthropogenic factors that affecst the metric -->

### 3.6 Spatial aggregation

<!-- Describe in word the same aggregation pathway presented in the metadata.xlsx. If you have scaled against the reference value, it is especially important to know if you did any avergaing or summations etc. beforehand. An example text for a rather simple case could be: "The variable is scaled at the initial polygon level and the point estimate is a area-weighted arithmetic mean of all polygins. There is no transformation, and truncation is not needed as the indicator becomes naturally bound between 0 and 1".  -->

## 4. Reference condition and levels

### 4.1 Reference condition

<!--# Define the reference condition (or refer to where it is defined). Note the distinction between reference condition and reference levels 10.3897/oneeco.5.e58216  -->

### 4.2 Reference levels

<!--# 

If relevant (i.e. if you have normalised a variable), describe the reference levels used to normalise the variable. 

Use the terminology where X~0~ refers to the reference level (the variable value) denoting the worst possible condition; X~100~denotes the optimum or best possible condition; and X~*n*~, where in is between 0 and 100, denotes any other anchoring points linking the variable scale to the indicator scale (e.g. the threshold value between good and bad condition X~60^). 

Why was the current option chosen and how were the reference levels quantified? If the reference values are calculated as part of the analyses further down, please repeat the main information here.

 -->


#### 4.2.1 Spatial resolution and validity

<!--# 

Describe the spatial resolution of the reference levels. E.g. is it defined as a fixed value for all areas, or does it vary. Also, at what spatial scale are the reference levels valid? For example, if the reference levels have a regional resolution (varies between regions), it might mean that it is only valid and correct to use for normalising local variable values that are first aggregated to regional scale. However, sometimes the reference levels are insensitive to this and can be used to scale variables at the local (e.g. plot) scale. 

 -->

## 5. Uncertainties
### 5.1 General uncertainties
<!--# Describe the main reasons why you might not trust 100% the final value to represent the given ecosystem characteristic for the give ecosystem type. What aspects of this condition metric are most sensitive to subjective decitions? Is the spatial sampling sufficient? Does the choice of modeling framework affect the values? Is the metric relevant do describe ecosystem condition for the give ecosystem type?  -->

### 5.2 Reported uncertainties
<!-- Describe the nature of the errors you (hopefully) provide alongside the point estimate for the condition metric. It is especially important to clarify if the errors are inferential (referring to the uncertainty of the point estimate) or descriptive (referreing to the data itself). Here' an example text: "What we report as uncertainties in @tbl-finalTable are inferential and refer to the uncertainty around the point estimates. It does not directly describe variation in the data itself. 
However, the variation in the mean is defined by the spatial variation only, and quartiles are obtained by bootstrapping the set of localities within a region, and calculating the indicator for each of 9999 such samples".   -->



## 6. References

<!--# You can add references manually or use a citation manager and add intext citations as with crossreferencing and hyperlinks. See https://quarto.org/docs/authoring/footnotes-and-citations.html -->

## 7. Import and prepare datasets

<!--# All the data import and preparation should be done in this chapter, before the analysis chapter. As a minimum, add code for importing data, and describe or show the data structure. You may also explain certain variables, what they represent, and their distributions -->

### 7.1 Dataset A

<!--# Import and prepare the first dataset for analysis. Change the header from Dataset A to the name of the actual dataset. -->

### 7.2. Dataset B

<!--# Repeat the process for each dataset -->

## 8. Spatial units

<!--# Describe the spatial units that you rely on in your analyses. Highlight the spatial units (the resolution) that the indicator values should be interpreted at. Potential spatial delineation data (maksing layers etc.) should be introduced under chapert 7. We recommend using the SEEA EA terminology of Basic Spatial Units (BSU), Ecosystem Asses (EA) and Ecosystem Accounting Area (EAA). -->

## 9. Analyses

<!--# 

Use this header for documenting the analyses. Put code in separate code chunks, and annotate the code in between using normal text (i.e. between the chunks, and try to avoid too many hashed out comments inside the code chunks). Add subheaders as needed. 

Code folding is activated, meaning the code will be hidden by default in the html (one can click to expand it).

Caching is also activated (from the top YAML), meaning that rendering to html will be quicker the second time you do it. This will create a folder inside you project folder (called INDICATORID_cache). Sometimes caching created problems because some operations are not rerun when they should be rerun. Try deleting the cash folder and try again.

-->

## 10. Results

<!--# 

Repeat the final results here. Typically this is a map or table of indicator values.

This is typically where people will harvest data from, so make sure to include all relevant output here, but don't clutter this section with too much output either.

-->

## 11. Export file

<!--# 

Optional: Display the code (don't execute it) or the workflow for exporting the indicator values to file. Ideally the indicator values are exported as a georeferenced shape or raster file with indicators values, reference values and errors. You can also chose to export the raw (un-normalised or unscaled variable) as a separate product. You should not save large sptaial output data on GitHub. You can use eval=FALSE to avoid code from being executed (example below - delete if not relevant) 

-->

```{r export}
#| eval: false
```


::: {.callout-tip collapse="true"}
## Session Info

```{r sessionInfo}
#| echo: false
sessionInfo()
```

:::