---
title: "Bumblebees"
subtitle: |
  [NO_BUMB_001] (grasslands) \
  [NO_BUMB_002] (forests)
format: 
  html:
    embed-resources: true
    code-fold: true
    toc: true
    toc-title: Contents
    toc-depth: 3
    smooth-scroll: true
execute: 
  cache: true
author:
  - name: Jens Åström
    email: jens.astrom@nina.no  # Enter email
    affiliations:
      - id: myID
        name: Norwegian Institute for Nature Research
  - name: Anders L. Kolstad
    affiliations:
      - ref: myID     
date: Aughust 21, 2025
callout-icon: false
lightbox: true
css: ../../../style.css
code-links:
      - text: Add a review
        icon: github
        href: https://github.com/NINAnor/ecRxiv
bibliography: references.bib
---

```{r setup}
#| include: false
library(knitr)
library(tidyverse)
library(kableExtra)
library(here)
knitr::opts_chunk$set(echo = TRUE)
```

```{r source}
#| echo: false
source(here::here("_common.R"))
```

```{r}
#| echo: false
meta <- readxl::read_xlsx("../metadata.xlsx")
st <- meta |>
  filter(Variable == "status") |>
  pull(Value)
version <- meta |>
  filter(Variable == "Version") |>
  pull(Value)
auth <- meta |>
  filter(Variable == "authors") |>
  pull(Value)
year <- meta |>
  filter(Variable == "yearAdded") |>
  pull(Value)
id <- meta |>
  filter(Variable == "indicatorID") |>
  pull(Value)
name <- meta |>
  filter(Variable == "indicatorName") |>
  pull(Value)
url <- meta |>
  filter(Variable == "url") |>
  pull(Value)

meta <- meta |>
  mutate(Variable = case_match(Variable,
    "indicatorID" ~ "Indicator ID" ,
    "indicatorName" ~ "Indicator Name",
    "country" ~ "Country",
    "continent" ~ "Continent",
    "ECT" ~ "Ecosystem Condition Typology Class",
    "yearAdded" ~ "Year added",
    "yearLastUpdate" ~ "Last update",
    .default = Variable
   )
  ) |>
  filter(Variable != "authors")

```

```{r}
#| echo: false
#| results: asis
status(st)
```

::: {layout-ncol="2"}
> **Recommended citation**: `r paste(auth, " ", year, ". ", name, " (ID: ", id, ") ", "v. ", version, ". ecRxiv: https://view.nina.no/ecRxiv/", sep="")`

> **Version**: `r version`
:::

```{=html}
<details>
<summary>Show metadata</summary>
```

```{r tbl-meta}
#| tbl-cap: 'Indicator metadata'
#| echo: false
#| warning: false

meta |>
  select(Variable, Value) |>
  kbl(col.names = NULL) 

```

</details>

::: {.callout-tip collapse="true"}
## Logg

<!--# Update this logg with short messages for each update -->

-   21 Aug. 2025 - Started work
:::

<hr />

## 1. Summary

```{=html}
<!--# 

With a maximum of 300 words, describe the indicator in general terms as you would to a non-expert. Think of this as a kind of common language summary. It is a good idea to include a bullet point list of the specific steps in the workflow. Include a mention of the following aspects:

What does the metric represent?
Why is this relevant for describing ecosystem condition in this ecosystem?
What are the main anthropogenig impact factors?
What kind of data is used? 
Shortly, how is the data customized (modified, estimated, integrated) to fit its purpose as an indicator?
What is the current status of  the metric (can it be used or is it still in development)?
How should the metric be used and interpreted, and how should it not be used/interpretted?

 -->
```

Bumblebees represent a conspicuous aspect of biodiversity, as well as indicators of habitat quality and important ecosystem functions, such as pollination. As a community they are dependent on a varied herbaceous flora. Bumblebee community structure can become disturbed by human activities, such as intensive agriculture and land-use change, and is therefore a key indicator of ecosystem condition.

Here we calculate nationally aggregated indicator estimates for all of Norway, for both the forest and the semi-natural meadow ecosystems. The indicator is based on data from the Norwegian monitoring of bumblebees and butterflies (NMBB) [@åström2024]. This is a transect based survey using a representative sample of grassland localities in four regions of Norway (northern Norway is not included, but is expected to become included in the near future). The indicator is based on the number of bumblebees in each locality, which is then compared to expert elicited reference communities that show the expected number of each bumblebee species.

The workflow for calculating indicator values, and for storing data, is integrated into an R-package called [bombLepiSurv](https://github.com/NINAnor/bombLepiSurv). The indicator is fully operational and used in several national reporting settings. The indicator is very similar to the indicator *Butterflies* \[NO_BFLY_001 and 002\] [@åström].

## 2. About the underlying data

The Norwegian monitoring of bumblebees and butterflies (NMBB) is initiated and financed by the Environmental agency, with the aim to produce continuous area representative time-series of insect community data. The NMBB program use sweep netting along transect walks where the species are identified manually in the field.

NMBB is designed to be area representative, within the respective habitat types (forest and grasslands) and regions. It uses stratified randomized selection of localities. Localities are selected from a predefined continuous network of survey squares, within which individual transects are then manually placed. Some subjective decisions are made in the definition of habitat criteria and in discarding unpractical survey locations.

### 2.1 Spatial and temporal resolution and extent

The NMBB program started in 2009 in a subset of south-eastern Norway (counties of Vestfold and Østfold), and was expanded to central Norway (Trøndelag and Møre og Romsdal) in 2010, south-western Norway in 2013 (Rogaland and Vest Agder), to western Norway (Vestland) in 2022, and Northern Norway in 2025. The spatial resolution aligns with these 4 regions (data from Northern Norway not yet available), and it is not recommended to downscale the predictions due to the limited number of sampling locations in each region.

There are in total 71 sampling locations as of 2024, divided between the forests and the grassland ecosystem. The four regions have approx. the same sample size, yet they cover quite different extents (\@fig-regions). Therefore, the values from the central regions contributes a lot more in the area weighted national estimate (about 10 times as much weight as the values from the east region; \@tbl-wgt). In this sense, the dataset is perhaps more suited, or at least more better designed, to analysing regional difference, rather than to look at national means.

Since the same locations are visited each year, yearly estimates of the condition could be calculated, but should be interpreted by caution due to natural yearly variability.

<!--# Data covers 2009 (for part of Norway) up to the present, but the database currently only has data up until 2024. The 2024 is available on GitHub, but is not accessible via the same workflow using the bombLepiSurv-package. -->

### 2.2 Original units

Original units are number of individuals of each species within a transect, although only presences in transects (as presence frequencies) are used for the indicator calculations.

### 2.3 Additional comments about the dataset

This indicator was developed for the Nature Index of Norway back in 2010 [@öberg2011] , and is calculated routinely on a yearly basis (see @åström2024 for the latest report). The indicator is also described in detail \[here\](https://ninanor.github.io/ecosystemCondition/insect-indicators.html), from where most of the text and code in the current document is taken (often directly).

#### 2.3.1 Instructions for citing, using and accessing data

<!--# Is the data openly available? If not, how can one access it? What are the key references to the datasets?   -->

## 3. Indicator properties

### 3.1 Ecosystem Condition Typology Class (ECT)

B1 - Compositional state characteristics. This indicator fits here as it describes biotic communities.

### 3.2 Ecosystem condition characteristic

Intakt biotic communities.

### 3.3 Other standards

In the Norwegian \*fagsystem [@nybø2017]\*, the indicator fits with the \*Biologisk mangfold\* characteristic.

### 3.4 Collinearities with other indicators

Possibly co-varied with NO_BFLY [@åström] as they both represent insect communities.

### 3.5 Impact factors

Bumblebees in Norway are negatively affected by the loss and fragmentation of flower rich habitats in the agricultural landscape, including good nest sites [@adb]. The reduction is good habitat is attributed to both land abandonment and increased land use intensity (pesticides, fertilize use with reduced flower diversity).

## 4. Reference condition and levels

### 4.1 Reference condition

The reference condition for forests is one with minimal negative human impact (pre modern forestry and accelerated climate change for example), but there is a special interpretation for semi-natural land. These habitats are formed and maintained through human activities. Thus, “minimal negative human impact” is replaced by a state of “good maintenance”, here understood as resembling the traditional agricultural maintenance regime, existing for several hundred years up until the late 1800s. This is characterized by extensive grazing, meadows and lays, crop rotation with legumes to bind nitrogen in addition to fertilization from manure, relatively small field sizes and abundant field margins, and a lack of artificial fertilization and mechanized tilling.

### 4.2 Reference levels

Reference levels are calculated the same way as for [@åström] but repeated here for coherency.

Assessing the current state of insect communities is a complicated task, due to their taxonomic and functional breadth and high temporal and spatial variability. Still, even more challenging is establishing reference levels, when the reference states are extinct or prohibitively difficult to measure empirically.

For the bumblebee indicator, the communities are small enough and well-known enough to identify reference communities by expert opinion. These reference communities specify the expected rate of observing each species. The current rates of observation are then compared to the expected rates. The calculations are further explained below.

We have not specified a value for good ecological condition (X~60~) as of yet, since we lack a straightforward empirical basis to do so. By default then, the values is set to 0.6 , following the general framework.

The indicator summarize the state of a bumbelbee community by estimating the difference from a reference community. Formally, the community indicator (CI) is expressed as the relative change of the community from a state of reference (SR), were the change is calculated by a state of change (SC).

$$CI = \frac{SR-SC}{SR}$$

The state of reference (SR) represents a community of species which can be expected to be observed in a given habitat type and region. It is calculated by assigning each species to class of expected commonality: common (C), sporadic (S) and rare (R) species. This classification is done by expert opinion, informed by known present and past species distributions. Note that this state of reference only contains a subset of highlighted species, making up a historical reference community. Potential observations of "new" species therefore don't inform the indicator value at all. Common species are expected to be observed in at least 5 % of the surveyed transects in a habitat type and region. Sporadic species similarly are defined as having a presence below 5 % but above 1 %. Rare species are seen in no more than 1 % of the transects, and lastly, species not seen in any transect are assumed as lost (L) for the purpose of this calculation.

Each commonality class gets its own weight, so that common species inform the reference state more than sporadic species, followed by rare species. The state of reference (SR) is thus a value where each species adds to the state according to its commonality. Formally, it is defined as:

$$SR = n_C * w_{C, SR} + n_S * w_{S, SR} + n_R * w_{R, SR} = \sum_{i = (C, S, R)} n_i * w_{i, SR}, $$

where $n_i$ is the number of species in a commonality class (C, S, R), and the weights $[w_{C, SR}, w_{S, SR}, w_{R, SR}]$ specify their respective contribution to the reference state (SR). The weights used are $[w_{C, SR}, w_{S, SR}, w_{R, SR}] = [1.0, 0.75, 0.50]$, i.e. a sporadic species has 75 % the weight of a common species, and a rare species has 50 % the weight of a common species.

The state of change (SC) is calculated as

$$SC = n_{CS} * w_{CS} + n_{CR} * w_{CR} + n_{CL} * w_{CL} + n_{SR} * w_{SR} + n_{SL} * w_{SL} + n_{RL} * w_{RL} $$

where $n_{CS}$ is the number of expected common species (C) that is observed sporadically (S), and $w_{CS}$ is the weight of this change. Similarly, $n_{CR}$ is the number of expected common species that is observed rarely, $n_{RL}$ is the number of rare species that is lost, and so on. Potential increases in observation rates do not inform the indicator. Changes for common species are weighted more heavily than changes for less common species, and larger decreases are weighted more heavily than smaller decreases, such that $[w_{CS}, w_{CR}, w_{CL}, w_{SR}, w_{SL}, w_{RL}]= [0.50, 0.75, 1.00, 0.50, 0.75, 0.50]$.

#### 4.2.1 Spatial resolution and validity

The reference levels are the unique to each region. They reflect the assumed *mean* community assemblage of bumblebees in that region, and therefore indicator values should not be presented at a spatial scale that is smaller than region. Note that there is no *variable* (in SEEA EA terms) associated with this indicator, and the indicator is normalised from the beginning, and before any spatial aggregation.

## 5. Uncertainties

The indicator values are estimated with uncertainty in the sense of spatial variation, by bootstrapping the set of localities within a region, and calculating the indicator for each of 9999 such samples. The uncertainties for indicator values are constituted by a distribution of discrete values, and therefore we only provide confidence intervals and not a standard deviation.

## 6. References

::: {#refs}
:::

### 7.1 Dataset A - NMBB

The `bombLepiSurv` package has convenience functions to fetch data from the internal NINA database. This database is currently not available outside NINA, but we will implement a solution for this in the future. Either we will make the database externally available, or we will provide an alternative route to the data from the GBIF export. For now, we will fetch the data through the `bombLepiSurv` functions.

### 7.2. Dataset B - Regions

We here import the   delineations used in this monitoring program. Note that this delineation different from the more standard definitions used in ecosystem accounting Norway.

```{r}
#| eval: false

# Path to counties pre 2020 merge
path <- here("indicators/NO_BFLY_001/data/Basisdata_0000_Norge_25833_Fylker2019_FGDB.gdb")

# print layer names
#st_layers(path)

# Get the names to the codes
# temp <- read_sf(path, layer = "administrativenhetnavn")

# read data and group counties
counties <- sf::read_sf(path,
    layer = "fylke") 

# The file is a combination of multipolygons and multisurfaces.
# I used this post to fix the problem: https://gis.stackexchange.com/questions/389814/r-st-centroid-geos-error-unknown-wkb-type-12

library(gdalUtilities)

ensure_multipolygons <- function(X) {
    tmp1 <- tempfile(fileext = ".gpkg")
    tmp2 <- tempfile(fileext = ".gpkg")
    st_write(X, tmp1)
    ogr2ogr(tmp1, tmp2, f = "GPKG", nlt = "MULTIPOLYGON")
    Y <- st_read(tmp2)
    st_sf(st_drop_geometry(X), geom = st_geometry(Y))
}

counties2 <- ensure_multipolygons(counties)
sf::st_geometry_type(counties2) #OK

# Plot in interactive mode to get correct county numbers
tmap::tmap_mode("view")
tm_shape(counties2) + 
  tm_polygons()

# Classify

counties3 <- counties2 |>
  mutate(Region = case_when(
    fylkesnummer %in% c("50", "15") ~ "Midt",
        fylkesnummer %in% c("12", "14") ~ "Vest",
        fylkesnummer %in% c("10", "11") ~ "Sør",
        fylkesnummer %in% c("01","07") ~ "Øst",
        .default = NA_character_
      ))
tmap::tmap_mode("plot")
tm_shape(counties3) + 
  tm_polygons(col = "Region") 

# Merge counties from same region

counties4 <- counties3 |>
  group_by(Region) |>
  summarize(geom = st_union(geom))

# Take out the marine areas
# import outline of Norway
nor <- sf::st_read(here::here("indicators/NO_BFLY_001/data/outlineOfNorway_EPSG25833.shp"),
  quiet = TRUE)
# remove marine areas
counties <- sf::st_intersection(counties4, nor)

tm_shape(counties) + 
  tm_polygons(col = "Region") 

# Save
saveRDS(counties, here::here("indicators/NO_BFLY_001/data/regions.rds"))
```

```{r fig-regions}
#| fig-cap: 'Regions in Norway'

readRDS(here::here("indicators/NO_BFLY_001_002/data/regions.rds")) -> counties
tm_shape(counties) + 
  tm_polygons(col = "Region") +
  tm_layout(legend.position = c("right", "bottom"))
```

## 8. Spatial units

```{=html}
<!--# 

Describe the spatial units that you rely on in your analyses. Highlight the spatial units (the resolution) that the indicator values should be interpretted at. Potential spatial delineation data should eb introduced under 7.1. Datasets. We recomend using the SEEA EA terminology opf Basic Spatial Units (BSU), Ecosystem Asses (EA) and Ecosystem Accounting Area (EAA). 

-->
```

Ecosystem assets: Mid-, central-, east-, and southern Norway. Note that southern Norway only includes the old counties of Vestfold and Østfold, and the south region contain Rogaland and Vest Agder, but not Øst Agder. The mid or central region includes Trøndelag and Møre og Romsdal.

Ecosystem accounting area: Norway (although N-Norway and several sub-regions are missing).

Data needs to be aggregated to EA level before interpretation. In addition, only locations with complete sampling (three replicated per season) should be included to avoids seasonal biases.

## 9. Analyses

```{=html}
<!--# 

Use this header for documenting the analyses. Put code in seperate code chunks, and annotate the code in between using normal text (i.e. between the chunks, and try to avoid too many hashed out comments inside the code chunks). Add subheaders as needed. 

Code folding is activated, meaning the code will be hidden by default in the html (one can click to expand it).

Caching is also activated (from the top YAML), meaning that rendering to html will be quicker the second time you do it. This will create a folder inside you project folder (called INDICATORID_cache). Sometimes caching created problems because some operations are not rerun when they should be rerun. Try deleting the cash folder and try again.

-->
```

These calculations with bootstrap sampling are implemented in the R-package [bombLepiSurv](https://github.com/NINAnor/bombLepiSurv).

Install package like this.

```{r}
#| eval: false
#| code-fold: show
remotes::install_github("NINAnor/bombLepiSurv")
library(bombLepiSurv)
```

Here I illustrate how to connect to the database. Since the database is only accessible from NINA, I will not run this part of the analyses, but instead cache the output files so that others can reproduce the general workflow, even if they cannot access the database.

```{r connect}
#| eval: false
# get secret username and password. I just keep mine in a local .R file that I also put in the gitignore file.
source(here::here("_pw.R"))
# connect
bombLepiSurv::humlesommerfConnect(
  username = BOMB_USER,
  password = BOMB_PASSWORD,
  host = "ninradardata01.nina.no"
)
```

Download data from 2023 as an example. 2024 data is not yet published (although it is made availble in a developement branch on GitHub).

```{r}
#| eval: false
allLepiGressmark2023 <- 
  getAllData(type = "butterflies", 
habitat = "gressmark",
    year = 2023,
    language = "norsk") |>
      mutate_if(bit64::is.integer64, as.numeric)

ggsave(
  here::here("indicators/NO_BFLY_001_002/img/fig_allLepiGressmark2023.png"),
  surveyBarplot(allLepiGressmark2023),
  width = 10,
  height = 5)
```

```{r fig-allLepiGressmark2023}
#| fig-cap: 'Butterflies in grasslands 2023.'
knitr::include_graphics(here::here("indicators/NO_BFLY_001_002/img/fig_allLepiGressmark2023.png"))
```

Indicator data is already processed for the years 2009 to 2022 and we can get them from the R package like this:

```{r}
# List datasets
dat <- CursoRopen::list_github_files(
  "bombLepiSurv", 
  path = "data/", 
  owner = "NINAnor", 
  regexp = "sInd") # add regexp = "Gress" to filter for just grasslands

# remove the first part of the path
dat <- str_remove(dat, "data/")
# and the second part
dat <- str_remove(dat, ".rda")

# read in all the data (as promise)
data(package = "bombLepiSurv", list = dat)
```

The indicator data is stored in the environment as one dataframe per year/region/habitat.

We need to calculate the indicator values for the years 2023 (and later also 2024) and store them in the same way.

```{r calculateIndicatorValues}
#| eval: false
nIter = 999

sInd2023TrondGress <- calcInd(
  type = "Sommerfugl",    # butterflies
  region_short = "Trond", # Trøndelag region
  habitat = "Gressmark",  # Grasslands
  year = 2023,
  nIter = nIter,
  save.draws = T)

sInd2023SorGress <- calcInd(
  type = "Sommerfugl",    # butterflies
  region_short = "Sor", # South region
  habitat = "Gressmark",  # Grasslands
  year = 2023,
  nIter = nIter,
  save.draws = T)

sInd2023OstGress <- calcInd(
  type = "Sommerfugl",    # butterflies
  region_short = "Ost", # East region
  habitat = "Gressmark",  # Grasslands
  year = 2023,
  nIter = nIter,
  save.draws = T)

sInd2023VestGress <- calcInd(
  type = "Sommerfugl",    # butterflies
  region_short = "Vest", # West region
  habitat = "Gressmark",  # Grasslands
  year = 2023,
  nIter = nIter,
  save.draws = T)

save(sInd2023TrondGress, 
     sInd2023SorGress, 
     sInd2023OstGress, 
     sInd2023VestGress, 
     file = here::here("indicators", "NO_BFLY_001", "data", "sInd2023.RData"))

# Same for forest
sInd2023TrondSkog <- calcInd(
  type = "Sommerfugl",    # 
  region_short = "Trond", # Trøndelag region
  habitat = "Skogsmark",  # 
  year = 2023,
  nIter = nIter,
  save.draws = T)

  sInd2023SorSkog <- calcInd(
    type = "Sommerfugl",    # 
    region_short = "Sor", # South region
    habitat = "Skogsmark",  # 
    year = 2023,
    nIter = nIter,
    save.draws = T)

  sInd2023OstSkog <- calcInd(
    type = "Sommerfugl",    # 
    region_short = "Ost", # East region
    habitat = "Skogsmark",  # 
    year = 2023,
    nIter = nIter,
    save.draws = T)

  sInd2023VestSkog <- calcInd(
    type = "Sommerfugl",    # 
    region_short = "Vest", # West region
    habitat = "Skogsmark",  # 
    year = 2023,
    nIter = nIter,
    save.draws = T)

  save(sInd2023TrondSkog, 
      sInd2023SorSkog, 
      sInd2023OstSkog, 
      sInd2023VestSkog, 
      file = here::here("indicators", "NO_BFLY_001", "data", "sInd2023Skog.RData"))
```

```{r}
#| echo: false
load(here::here("indicators", "NO_BFLY_001_002", "data", "sInd2023.RData"))
load(here::here("indicators", "NO_BFLY_001_002", "data", "sInd2023Skog.RData"))
```

Then we compile the indicator values for the years 2009 to 2023.

```{r fig-linegraph}
#| fig-cap: 'Indicator values for butterflies in grasslands from 2009 to 2022'
bGressIndVals <- collectIndData(taxa = "butterflies", 
                                habitat = "gressmark",
                                years = 2009:2023)

indPlot(input = bGressIndVals,
        confLevel = "95%",
        lineWidth = 1,
        dodge = 0.5,
        pointSize = 4) +
  scale_x_continuous(breaks = 2009:2023)
```

```{r fig-linegraph2}
#| fig-cap: 'Indicator values for butterflies in forests from 2009 to 2022'
bSkogIndVals <- collectIndData(taxa = "butterflies", 
                                habitat = "skogsmark",
                                years = 2009:2023)

indPlot(input = bSkogIndVals,
        confLevel = "95%",
        lineWidth = 1,
        dodge = 0.5,
        pointSize = 4) +
  scale_x_continuous(breaks = 2009:2023)
```

The data objects contain point estimates and some percentiles. However, in certain ecosystem accounting contexts, we may want the SD. We can get the symmetrical SD from the vector of randomized draws of community indices, like this:

```{r}
sInd2023OstGress$`Randomization draws, community` |>
  sd()
```

However, the errors or extremely skewed. We shall therefore use the 50% confidence interval (IQR).

Here is the summary data for one region and one year, for illustration:

```{r}
sInd2023OstGress
```

I can get the correct 2.5 and 97.5 percentiles by using the `quantile` function.

```{r}
sInd2023OstGress$`Randomization draws, community` |>
  quantile(probs = c(0.025, 0.5, 0.975))
```

But notice that the point estimate is not the median of the distribution. Nor is it the mean. The point estimate is rather taken from the actual sample (not a random draw) of sampling locations.

This particular version of the indicator is developed for the Norwegian pilot for national ecosystem condition accounting. In this context we need to adhere to some guidelines. The accounting year (closing year) is 2024, and the accounting period is 3 years. We don't have data from 2024, but I will aggregate the data from year 2022 and 2023 to produce the value for the year 2024. We are only concerned with the national estimate for now. We also need to carry the errors through every calculation step and to use an area weighted mean when aggregation spatially over regions.

First we get the area weights. The localities are stratified to four regions of very different sizes.

```{r tbl-wgt}
#| fig-cap: 'Area weights'
regTable <- counties |>
  filter(!is.na(Region)) |>
  mutate(area_km2 = round(units::drop_units(st_area(geom))/1e6),
  area_weight = round(area_km2/max(area_km2), 3)) |>
  st_drop_geometry() |>
  select(Region, area_km2, area_weight)

regTable |>
  kbl() |>
  kable_paper() 
```

We use bootstrapping for getting the errors, but we use area-weighted arithmetic mean to get the point estimate.

First the point estimate for grasslands.

```{r}
ost22 <- sInd2022OstGress$`Community indicator estimates, with percentiles` |>
  enframe() |>
  filter(name == "Point estimate") |>
  pull("value")

ost23 <- sInd2023OstGress$`Community indicator estimates, with percentiles` |>
  enframe() |>
  filter(name == "Point estimate") |>
  pull("value")

west22 <- sInd2022VestGress$`Community indicator estimates, with percentiles` |>
  enframe() |>
  filter(name == "Point estimate") |>
  pull("value")


west23 <- sInd2023VestGress$`Community indicator estimates, with percentiles` |>
  enframe() |>  
  filter(name == "Point estimate") |>
  pull("value")

south22 <- sInd2022SorGress$`Community indicator estimates, with percentiles` |>
  enframe() |>
  filter(name == "Point estimate") |>
  pull("value")


south23 <- sInd2023SorGress$`Community indicator estimates, with percentiles` |>
  enframe() |>
  filter(name == "Point estimate") |>
  pull("value")

mid22 <- sInd2022TrondGress$`Community indicator estimates, with percentiles` |>
  enframe() |>
  filter(name == "Point estimate") |>
  pull("value")


mid23 <- sInd2023TrondGress$`Community indicator estimates, with percentiles` |>
  enframe() |>  
  filter(name == "Point estimate") |>
  pull("value")

# aggregate by first taking the mean of the two years, then the area weighted mean of the four regions

ost <- (ost22 + ost23)/2
west <- (west22 + west23)/2
south <- (south22 + south23)/2
mid <- (mid22 + mid23)/2

# area weighted mean
pointEstimateNorway <- mean(
  c(
    mid,
    south,
    west, 
    ost
  ), 
  weights = regTable$area_weight)

pointEstimateNorway
```

And then for forests:

```{r}
ost22s <- sInd2022OstSkog$`Community indicator estimates, with percentiles` |>
  enframe() |>
  filter(name == "Point estimate") |>
  pull("value")

ost23s <- sInd2023OstSkog$`Community indicator estimates, with percentiles` |>
  enframe() |>
  filter(name == "Point estimate") |>
  pull("value")

west22s <- sInd2022VestSkog$`Community indicator estimates, with percentiles` |>
  enframe() |>
  filter(name == "Point estimate") |>
  pull("value")

west23s <- sInd2023VestSkog$`Community indicator estimates, with percentiles` |>
  enframe() |>  
  filter(name == "Point estimate") |>
  pull("value")

south22s <- sInd2022SorSkog$`Community indicator estimates, with percentiles` |>
  enframe() |>
  filter(name == "Point estimate") |>
  pull("value")

south23s <- sInd2023SorSkog$`Community indicator estimates, with percentiles` |>
  enframe() |>
  filter(name == "Point estimate") |>
  pull("value")

mid22s <- sInd2022TrondSkog$`Community indicator estimates, with percentiles` |>
  enframe() |>
  filter(name == "Point estimate") |>
  pull("value")

mid23s <- sInd2023TrondSkog$`Community indicator estimates, with percentiles` |>
  enframe() |>  
  filter(name == "Point estimate") |>
  pull("value")

# aggregate by first taking the mean of the two years, then the area weighted mean of the four regions

ost_s <- (ost22s + ost23s)/2
west_s <- (west22s + west23s)/2
south_s <- (south22s + south23s)/2
mid_s <- (mid22s + mid23s)/2

# area weighted mean
pointEstimateNorway_s <- mean(
  c(
    mid_s,
    south_s,
    west_s, 
    ost_s
  ), 
  weights = regTable$area_weight)

pointEstimateNorway_s
```

Then the errors. We first combine the data from 2022 and 2023 and sample from these with *n* corresponding to the area weights

```{r}
east <- c(sInd2022OstGress$`Randomization draws, community`,
  sInd2023OstGress$`Randomization draws, community`)
vest <- c(sInd2022VestGress$`Randomization draws, community`,
  sInd2023VestGress$`Randomization draws, community`)
south <- c(sInd2022SorGress$`Randomization draws, community`,
  sInd2023SorGress$`Randomization draws, community`)
mid <- c(sInd2022TrondGress$`Randomization draws, community`,
  sInd2023TrondGress$`Randomization draws, community`)

# sample
east2 <- sample(east, size = regTable |> filter(Region == "Øst") |> pull(area_weight)*10000, replace = T)
west2 <- sample(vest, size = regTable |> filter(Region == "Vest") |> pull(area_weight)*10000, replace = T)
south2 <- sample(south, size = regTable |> filter(Region == "Sør") |> pull(area_weight)*10000, replace = T)
mid2 <- sample(mid, size = regTable |> filter(Region == "Midt") |> pull(area_weight)*10000, replace = T)

# repeat for forests (skog)
s_east <- c(sInd2022OstSkog$`Randomization draws, community`,
  sInd2023OstSkog$`Randomization draws, community`)
s_vest <- c(sInd2022VestSkog$`Randomization draws, community`,
  sInd2023VestSkog$`Randomization draws, community`)
s_south <- c(sInd2022SorSkog$`Randomization draws, community`,
  sInd2023SorSkog$`Randomization draws, community`)
s_mid <- c(sInd2022TrondSkog$`Randomization draws, community`,
  sInd2023TrondSkog$`Randomization draws, community`)

# sample
s_east2 <- sample(s_east, size = regTable |> filter(Region == "Øst") |> pull(area_weight)*10000, replace = T)
s_west2 <- sample(s_vest, size = regTable |> filter(Region == "Vest") |> pull(area_weight)*10000, replace = T)
s_south2 <- sample(s_south, size = regTable |> filter(Region == "Sør") |> pull(area_weight)*10000, replace = T)
s_mid2 <- sample(s_mid, size = regTable |> filter(Region == "Midt") |> pull(area_weight)*10000, replace = T)


```

Then we combine these into one big string and draw from it

```{r}
all <- c(east2, west2, south2, mid2)
all_s <- c(s_east2, s_west2, s_south2, s_mid2)

(nationalDist <- sample(all, size = 10000, replace = T) |>
  quantile(probs = c(0.25, 0.75)))

(nationalDist_s <- sample(all_s, size = 10000, replace = T) |>
  quantile(probs = c(0.25, 0.75)))
```

## 10. Results

```{=html}
<!--# 

Repeat the final results here. Typically this is a map or table of indicator values.

This is typically where people will harvest data from, so make sure to include all relevant output here, but don't clutter this section with too much output either.

-->
```

| ECT | Indicator | ID | Accounting area | Ecosystem | Closing year | Value | Error (IQR) |
|---------|---------|---------|---------|---------|---------|---------|---------|
| B1 | Butterflies | NO_BFLY_001 | Norway | Grasslands | 2024 | 0.358 | (0.253 - 0.345) |
| B1 | Butterflies | NO_BFLY_002 | Norway | Forest | 2024 | 0.506 | (0.400 - 0.494) |