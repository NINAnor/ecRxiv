---
title: "Bumblebees"
subtitle: |
  [NO_BUMB_001] (grasslands) \
  [NO_BUMB_002] (forests)
format: 
  html:
    embed-resources: true
    code-fold: true
    toc: true
    toc-title: Contents
    toc-depth: 3
    smooth-scroll: true
execute: 
  cache: true
author:
  - name: Jens Åström
    email: jens.astrom@nina.no  # Enter email
    affiliations:
      - id: myID
        name: Norwegian Institute for Nature Research
  - name: Anders L. Kolstad
    affiliations:
      - ref: myID     
date: Aughust 21, 2025
callout-icon: false
lightbox: true
css: ../../../style.css
code-links:
      - text: Add a review
        icon: github
        href: https://github.com/NINAnor/ecRxiv
bibliography: references.bib
---

```{r setup}
#| include: false
library(knitr)
library(tidyverse)
library(kableExtra)
library(here)
library(tmap)
library(sf)
library(NinaR)
library(CursoRopen)
library(bombLepiSurv)
knitr::opts_chunk$set(echo = TRUE)
```

```{r source}
#| echo: false
source(here::here("_common.R"))
```

```{r}
#| echo: false
meta <- readxl::read_xlsx(here::here("indicators/NO_BUMB_001_002/metadata.xlsx"))
st <- meta |>
  filter(Variable == "status") |>
  pull(Value)
version <- meta |>
  filter(Variable == "Version") |>
  pull(Value)
auth <- meta |>
  filter(Variable == "authors") |>
  pull(Value)
year <- meta |>
  filter(Variable == "yearAdded") |>
  pull(Value)
id <- meta |>
  filter(Variable == "indicatorID") |>
  pull(Value)
name <- meta |>
  filter(Variable == "indicatorName") |>
  pull(Value)
url <- meta |>
  filter(Variable == "url") |>
  pull(Value)

meta <- meta |>
  mutate(Variable = case_match(Variable,
    "indicatorID" ~ "Indicator ID" ,
    "indicatorName" ~ "Indicator Name",
    "country" ~ "Country",
    "continent" ~ "Continent",
    "ECT" ~ "Ecosystem Condition Typology Class",
    "yearAdded" ~ "Year added",
    "yearLastUpdate" ~ "Last update",
    .default = Variable
   )
  ) |>
  filter(Variable != "authors")

```

```{r}
#| echo: false
#| results: asis
status(st)
```



::: {layout-ncol="2"}
> **Recommended citation**: `r paste(auth, " ", year, ". ", name, " (ID: ", id, ") ", "v. ", version, ". ecRxiv: ", url, sep="")`

> **Version**: `r version`
:::

```{=html}
<details>
<summary>Show metadata</summary>
```

```{r tbl-meta}
#| tbl-cap: 'Indicator metadata'
#| echo: false
#| warning: false

meta |>
  select(Variable, Value) |>
  kable()

```

</details>

::: {.callout-tip collapse="true"}
## Logg

<!--# Update this logg with short messages for each update -->

-   21 Aug. 2025 - Started work
:::

<hr />

## 1. Summary


Bumblebees represent a conspicuous aspect of biodiversity, as well as indicators of habitat quality and important ecosystem functions, such as pollination. As a community they are dependent on a varied herbaceous flora. Bumblebee community structure can become disturbed by human activities, such as intensive agriculture and land-use change, and is therefore a key indicator of ecosystem condition.

Here we calculate nationally aggregated indicator estimates for all of Norway, for both the forest and the semi-natural meadow ecosystems. The indicator is based on data from the Norwegian monitoring of bumblebees and butterflies (NMBB) [@åström2024]. This is a transect based survey using a representative sample of grassland localities in four regions of Norway (northern Norway is not included, but is expected to become included in the near future). The indicator is based on the number of bumblebees in each locality, which is then compared to expert elicited reference communities that show the expected number of each bumblebee species.

The workflow for calculating indicator values, and for storing data, is integrated into an R-package called [bombLepiSurv](https://github.com/NINAnor/bombLepiSurv). The indicator is fully operational and used in several national reporting settings. The indicator is very similar to the indicator *Butterflies* \[NO_BFLY_001 and 002\] [@åström].

> ### Interpretation
An indicator value of 1 signifies an intact bumblebee community. Values decreasing toward zero reflect negative ecological change, specifically the decline of species expected to be present. This metric does not account for potentially positive changes, such as increases in species' abundance or the arrival of new species.


## 2. About the underlying data

The Norwegian monitoring of bumblebees and butterflies (NMBB) is initiated and financed by the Environmental agency, with the aim to produce continuous area representative time-series of insect community data. The NMBB program use sweep netting along transect walks where the species are identified manually in the field.

NMBB is designed to be area representative, within the respective habitat types (forest and grasslands) and regions. It uses stratified randomized selection of localities. Localities are selected from a predefined continuous network of survey squares, within which individual transects are then manually placed. Some subjective decisions are made in the definition of habitat criteria and in discarding unpractical survey locations.

### 2.1 Spatial and temporal resolution and extent

The NMBB program started in 2009 in a subset of south-eastern Norway (counties of Vestfold and Østfold), and was expanded to central Norway (Trøndelag and Møre og Romsdal) in 2010, south-western Norway in 2013 (Rogaland and Vest Agder), to western Norway (Vestland) in 2022, and Northern Norway in 2025. The spatial resolution aligns with these 4 regions (data from Northern Norway not yet available), and it is not recommended to downscale the predictions due to the limited number of sampling locations in each region.

There are in total 71 sampling locations as of 2024, divided between the forests and the grassland ecosystem. The four regions have approx. the same sample size, yet they cover quite different extents (@fig-regions). Therefore, the values from the central regions contributes a lot more in the area weighted national estimate (about 10 times as much weight as the values from the east region; @tbl-wgt). In this sense, the dataset is perhaps more suited, or at least more better designed, to analysing regional difference, rather than to look at national means.

Since the same locations are visited each year, yearly estimates of the condition could be calculated, but should be interpreted by caution due to natural yearly variability.

<!--# Data covers 2009 (for part of Norway) up to the present, but the database currently only has data up until 2024. The 2024 is available on GitHub, but is not accessible via the same workflow using the bombLepiSurv-package. -->

### 2.2 Original units

Original units are number of individuals of each species within a transect, although only presences in transects (as presence frequencies) are used for the indicator calculations.

### 2.3 Additional comments about the dataset

This indicator was developed for the Nature Index of Norway back in 2010 [@öberg2011] , and is calculated routinely on a yearly basis (see @åström2024 for the latest report). The indicator is also described in detail \[here\](https://ninanor.github.io/ecosystemCondition/insect-indicators.html), from where most of the text and code in the current document is taken (often directly).

#### 2.3.1 Instructions for citing, using and accessing data


The version of the data used here is only only stored at NINA, but will be made available upon request. 
Most of the data is, however, available on GBIF [@dataset].

## 3. Indicator properties

### 3.1 Ecosystem Condition Typology Class (ECT)

B1 - Compositional state characteristics. This indicator fits here as it describes biotic communities.

### 3.2 Ecosystem condition characteristic

Intakt biotic communities.

### 3.3 Other standards

In the Norwegian _fagsystem_ [@nybø2017], the indicator fits with the _Biologisk mangfold_ characteristic.

### 3.4 Collinearities with other indicators

Possibly co-varied with NO_BFLY [@åström] as they both represent insect communities.

### 3.5 Impact factors

Bumblebees in Norway are negatively affected by the loss and fragmentation of flower rich habitats in the agricultural landscape, including good nest sites [@adb]. The reduction is good habitat is attributed to both land abandonment and increased land use intensity (pesticides, fertilize use with reduced flower diversity).

## 4. Reference condition and levels

### 4.1 Reference condition

The reference condition for forests is one with minimal negative human impact (pre modern forestry and accelerated climate change for example), but there is a special interpretation for semi-natural land. These habitats are formed and maintained through human activities. Thus, “minimal negative human impact” is replaced by a state of “good maintenance”, here understood as resembling the traditional agricultural maintenance regime, existing for several hundred years up until the late 1800s. This is characterized by extensive grazing, meadows and lays, crop rotation with legumes to bind nitrogen in addition to fertilization from manure, relatively small field sizes and abundant field margins, and a lack of artificial fertilization and mechanized tilling.

### 4.2 Reference levels

Reference levels are calculated the same way as for [@åström] but repeated here for coherency.

Assessing the current state of insect communities is a complicated task, due to their taxonomic and functional breadth and high temporal and spatial variability. Still, even more challenging is establishing reference levels, when the reference states are extinct or prohibitively difficult to measure empirically.

For the bumblebee indicator, the communities are small enough and well-known enough to identify reference communities by expert opinion. These reference communities specify the expected rate of observing each species. The current rates of observation are then compared to the expected rates. The calculations are further explained below.

We have not specified a value for good ecological condition (X~60~) as of yet, since we lack a straightforward empirical basis to do so. By default then, the values is set to 0.6 , following the general framework.

The indicator summarize the state of a bumblebee community by estimating the difference from a reference community. Formally, the community indicator (CI) is expressed as the relative change of the community from a state of reference (SR), were the change is calculated by a state of change (SC).

$$CI = \frac{SR-SC}{SR}$$

The state of reference (SR) represents a community of species which can be expected to be observed in a given habitat type and region. It is calculated by assigning each species to class of expected commonality: common (C), sporadic (S) and rare (R) species. This classification is done by expert opinion, informed by known present and past species distributions. Note that this state of reference only contains a subset of highlighted species, making up a historical reference community. Potential observations of "new" species therefore don't inform the indicator value at all. Common species are expected to be observed in at least 5 % of the surveyed transects in a habitat type and region. Sporadic species similarly are defined as having a presence below 5 % but above 1 %. Rare species are seen in no more than 1 % of the transects, and lastly, species not seen in any transect are assumed as lost (L) for the purpose of this calculation.

Each commonality class gets its own weight, so that common species inform the reference state more than sporadic species, followed by rare species. The state of reference (SR) is thus a value where each species adds to the state according to its commonality. Formally, it is defined as:

$$SR = n_C * w_{C, SR} + n_S * w_{S, SR} + n_R * w_{R, SR} = \sum_{i = (C, S, R)} n_i * w_{i, SR}, $$

where $n_i$ is the number of species in a commonality class (C, S, R), and the weights $[w_{C, SR}, w_{S, SR}, w_{R, SR}]$ specify their respective contribution to the reference state (SR). The weights used are $[w_{C, SR}, w_{S, SR}, w_{R, SR}] = [1.0, 0.75, 0.50]$, i.e. a sporadic species has 75 % the weight of a common species, and a rare species has 50 % the weight of a common species.

The state of change (SC) is calculated as

$$SC = n_{CS} * w_{CS} + n_{CR} * w_{CR} + n_{CL} * w_{CL} + n_{SR} * w_{SR} + n_{SL} * w_{SL} + n_{RL} * w_{RL} $$

where $n_{CS}$ is the number of expected common species (C) that is observed sporadically (S), and $w_{CS}$ is the weight of this change. Similarly, $n_{CR}$ is the number of expected common species that is observed rarely, $n_{RL}$ is the number of rare species that is lost, and so on. Potential increases in observation rates do not inform the indicator. Changes for common species are weighted more heavily than changes for less common species, and larger decreases are weighted more heavily than smaller decreases, such that $[w_{CS}, w_{CR}, w_{CL}, w_{SR}, w_{SL}, w_{RL}]= [0.50, 0.75, 1.00, 0.50, 0.75, 0.50]$.

#### 4.2.1 Spatial resolution and validity

The reference levels are the unique to each region. They reflect the assumed *mean* community assemblage of bumblebees in that region, and therefore indicator values should not be presented at a spatial scale that is smaller than region. Note that there is no *variable* (in SEEA EA terms) associated with this indicator, and the indicator is normalised from the beginning, and before any spatial aggregation.

## 5. Uncertainties

The indicator values are estimated with uncertainty in the sense of spatial variation, by bootstrapping the set of localities within a region, and calculating the indicator for each of 9999 such samples. The uncertainties for indicator values are constituted by a distribution of discrete values, and therefore we only provide confidence intervals and not a standard deviation.

## 6. References

::: {#refs}
:::

### 7.1 Dataset A - NMBB

The `bombLepiSurv` package has convenience functions to fetch data from the internal NINA database. This database is currently not available outside NINA, but we will implement a solution for this in the future. Either we will make the database externally available, or we will provide an alternative route to the data from the GBIF export. For now, we will fetch the data through the `bombLepiSurv` functions.

### 7.2. Dataset B - Regions

We here import the delineations used in this monitoring program. Note that this delineation different from the more standard definitions used in ecosystem accounting Norway.

```{r readReg}
readRDS(here::here("indicators/NO_BUMB_001_002/data/regions.rds")) -> counties
```

```{r fig-regions}
#| fig-cap: 'Regions in Norway'
tm_shape(counties) + 
  tm_polygons(col = "Region") +
  tm_layout(legend.position = c("right", "bottom"))

```

## 8. Spatial units


Ecosystem assets: Mid-, central-, east-, and southern Norway. Note that southern Norway only includes the old counties of Vestfold and Østfold, and the south region contain Rogaland and Vest Agder, but not Øst Agder. The mid or central region includes Trøndelag and Møre og Romsdal.

Ecosystem accounting area: Norway (although N-Norway and several sub-regions are missing).

Data needs to be aggregated to EA level before interpretation. In addition, only locations with complete sampling (three replicated per season) should be included to avoid seasonal biases.

## 9. Analyses

These calculations with bootstrap sampling are implemented in the R-package [bombLepiSurv](https://github.com/NINAnor/bombLepiSurv).

Install package like this.

```{r}
#| eval: false
#| code-fold: show
remotes::install_github("NINAnor/bombLepiSurv")
library(bombLepiSurv)
```

Here I illustrate how to connect to the database. Since the database is only accessible from NINA, I will not run this part of the analyses, but instead cache the output files so that others can reproduce the general workflow, even if they cannot access the database.

```{r connect}
#| eval: false
# get secret username and password. I just keep mine in a local .R file that I also put in the gitignore file.
source(here::here("_pw.R"))
# connect
bombLepiSurv::humlesommerfConnect(
  username = BOMB_USER,
  password = BOMB_PASSWORD
)
```

Download data from 2024 as an example. 

```{r}
#| eval: false
allBumbGressmark2024 <- 
  getAllData(type = "Bumblebees", 
    habitat = "Gressmark",
    year = 2024) |>
  mutate_if(bit64::is.integer64, as.numeric)

ggsave(
  here::here("indicators/NO_BUMB_001_002/img/fig_allBumbGressmark2024.png"),
  surveyBarplot(allBumbGressmark2024),
  width = 10,
  height = 5)
```

```{r fig-allBumbGressmark2024}
#| fig-cap: 'Bumblebees in grasslands 2024.'
knitr::include_graphics(here::here("indicators/NO_BUMB_001_002/img/fig_allBumbGressmark2024.png"))
```

Indicator data is already processed and we can get them from the R package like this:

```{r}
# List datasets
dat <- CursoRopen::list_github_files(
  "bombLepiSurv", 
  path = "data/", 
  owner = "NINAnor", 
  regexp = "hInd") # the 'h' is for humler/bumblebees. add regexp = "Gress" to filter for just grasslands

# remove the first part of the path
dat <- str_remove(dat, "data/")
# and the second part
dat <- str_remove(dat, ".rda")

# read in all the data (as promise)
data(package = "bombLepiSurv", list = dat)
```

The indicator data gets stored in the environment as one dataframe per year/region/habitat.

Then we compile the indicator values for the years 2009 to 2024.

```{r fig-linegraph}
#| fig-cap: 'Indicator values for bumblebees in grasslands from 2009 to 2022'
hGressIndVals <- collectIndData(type = "Bumblebees", 
                                habitat = "Gressmark",
                                years = 2009:2024)

indPlot(input = hGressIndVals,
        confLevel = "95%",
        lineWidth = 1,
        dodge = 0.5,
        pointSize = 4) +
  scale_x_continuous(breaks = 2009:2024)+
  ylim(c(0,1))
```

```{r fig-linegraph2}
#| fig-cap: 'Indicator values for bumblebees in forests from 2009 to 2022'
hSkogIndVals <- collectIndData(type = "Bumblebees", 
                                habitat = "Skogsmark",
                                years = 2009:2024)

indPlot(input = hSkogIndVals,
        confLevel = "95%",
        lineWidth = 1,
        dodge = 0.5,
        pointSize = 4) +
  scale_x_continuous(breaks = 2009:2024)+
    ylim(c(0,1))
```

The data objects contain point estimates and some percentiles. However, in certain ecosystem accounting contexts, we may want the SD. We can get the symmetrical SD from the vector of randomized draws of community indices, like this:

```{r}
hInd2024OstGress$`Randomization draws, community` |>
  sd()
```

However, the errors or extremely skewed. We shall therefore use the 50% confidence interval (IQR).

Here is the summary data for one region and one year, for illustration:

```{r}
hInd2024OstGress$`Community indicator estimates, with percentiles` |>
  kable()
```

I can get the correct 2.5 and 97.5 percentiles by using the `quantile` function.

```{r}
hInd2024OstGress$`Randomization draws, community` |>
  quantile(probs = c(0.025, 0.5, 0.975))
```

But notice that the point estimate is not the median of the distribution. Nor is it the mean. The point estimate is rather taken from the actual sample (not a random draw) of sampling locations.

This particular version of the indicator is developed for the Norwegian pilot for national ecosystem condition accounting. In this context we need to adhere to some guidelines. The accounting year (closing year) is 2024, and the accounting period is 3 years. I will aggregate the data from year 2022 to 2024 and produce the value for the closing year 2024. We are only concerned with the national estimate for now. We also need to carry the errors through every calculation step and to use an area weighted mean when aggregating spatially over regions.

First we get the area weights. The localities are stratified to four regions of very different sizes.

```{r tbl-wgt}
#| tbl-cap: 'Area weights'

regTable <- counties |>
    filter(!is.na(Region)) |>
    mutate(area_km2 = round(units::drop_units(st_area(geom))/1e6),
    area_weight = round(area_km2/max(area_km2), 3)) |>
    st_drop_geometry() |>
    select(Region, area_km2, area_weight) 

regTable |> kable()
```

We use bootstrapping for getting the errors, but we use area-weighted arithmetic mean to get the point estimate.

First the point estimate for grasslands.

```{r}
# define grouping variables
years <- 2022:2024
habitat <- c("Gress", "Skog")
region <- c(
  "Ost",
  "Vest",
  "Sor",
  "Trond")

# Create tibble with all combinations
pointEstimates <- expand_grid(
  year = years,
  habitat = habitat,
  region = region
)

# define a function that retrieves the value for one combination
get_point_estimate <- function(year, region, habitat) {
  # Construct the object name, e.g. hInd2022OstGress
  obj_name <- paste0("hInd", year, region, habitat)
  
  # Get the object by name
  obj <- get(obj_name)
  
  # Extract the value
  val <- obj$`Community indicator estimates, with percentiles` |>
    enframe() |>
    filter(name == "Point estimate") |>
    pull("value")
  
  return(val)
}

# Run function for each row
pointEstimates <- pointEstimates |>
  rowwise() |>
  mutate(point = get_point_estimate(year, region, habitat)) |>
  ungroup()

# Make 'region' variable consistent with regTable variable names Region
pointEstimates <- pointEstimates |>
  mutate(region2 = case_when(
    region == "Ost" ~ "Øst",
    region == "Sor" ~ "Sør",
    region == "Trond" ~ "Midt",
    .default = region
  )) 

# aggregate by first taking the mean of the years, then the area weighted mean of the four regions
pointEstimates_overYears <- pointEstimates |>
  summarise(mean = mean(point), .by = c(habitat, region2)) |>
  left_join(regTable, by = join_by(region2 == Region)) |>
  summarise(wmean = mean(mean, weights = area_weight), .by = habitat)

pointEstimates_overYears |> kable()
```


Then the errors. We first combine the data from all years and sample from these with *n* corresponding to the area weights

```{r}
east <- c(
  hInd2022OstGress$`Randomization draws, community`,
  hInd2023OstGress$`Randomization draws, community`, 
  hInd2024OstGress$`Randomization draws, community`
  )
vest <- c(
  hInd2022VestGress$`Randomization draws, community`,
  hInd2023VestGress$`Randomization draws, community`,
  hInd2024VestGress$`Randomization draws, community`)
south <- c(
  hInd2022SorGress$`Randomization draws, community`,
  hInd2023SorGress$`Randomization draws, community`,
  hInd2024SorGress$`Randomization draws, community`)
mid <- c(
  hInd2022TrondGress$`Randomization draws, community`,
  hInd2023TrondGress$`Randomization draws, community`,
  hInd2024TrondGress$`Randomization draws, community`)

# sample
east2 <- sample(east, size = regTable |> filter(Region == "Øst") |> pull(area_weight)*10000, replace = T)
west2 <- sample(vest, size = regTable |> filter(Region == "Vest") |> pull(area_weight)*10000, replace = T)
south2 <- sample(south, size = regTable |> filter(Region == "Sør") |> pull(area_weight)*10000, replace = T)
mid2 <- sample(mid, size = regTable |> filter(Region == "Midt") |> pull(area_weight)*10000, replace = T)

# repeat for forests (skog)
s_east <- c(
  hInd2022OstSkog$`Randomization draws, community`,
  hInd2023OstSkog$`Randomization draws, community`,
  hInd2024OstSkog$`Randomization draws, community`)
s_vest <- c(
  hInd2022VestSkog$`Randomization draws, community`,
  hInd2023VestSkog$`Randomization draws, community`,
  hInd2024VestSkog$`Randomization draws, community`)
s_south <- c(
  hInd2022SorSkog$`Randomization draws, community`,
  hInd2023SorSkog$`Randomization draws, community`,
  hInd2024SorSkog$`Randomization draws, community`)
s_mid <- c(
  hInd2022TrondSkog$`Randomization draws, community`,
  hInd2023TrondSkog$`Randomization draws, community`,
  hInd2024TrondSkog$`Randomization draws, community`)

# sample
s_east2 <- sample(s_east, size = regTable |> filter(Region == "Øst") |> pull(area_weight)*10000, replace = T)
s_west2 <- sample(s_vest, size = regTable |> filter(Region == "Vest") |> pull(area_weight)*10000, replace = T)
s_south2 <- sample(s_south, size = regTable |> filter(Region == "Sør") |> pull(area_weight)*10000, replace = T)
s_mid2 <- sample(s_mid, size = regTable |> filter(Region == "Midt") |> pull(area_weight)*10000, replace = T)


```

Then we combine these into one big string and draw from it

```{r}
all <- c(east2, west2, south2, mid2)
all_s <- c(s_east2, s_west2, s_south2, s_mid2)

(nationalDist <- sample(all, size = 10000, replace = T) |>
  quantile(probs = c(0.25, 0.75)))

(nationalDist_s <- sample(all_s, size = 10000, replace = T) |>
  quantile(probs = c(0.25, 0.75)))
```

## 10. Results

```{r}
tibble(
  ECT = rep("B1", 2),
  Indicator = rep("Bumblebees", 2),
  ID = c("NO_BUMB_001", "NO_BUMB_002"),
  "Accounting area" = "Norway",
  Ecosystem = c("Grasslands", "Forest"),
  "Closing year" = rep(2024, 2),
  "Indicator value" = c(
    round(pointEstimates_overYears |>
      filter(habitat == "Gress") |>
      pull(wmean), 3), 
    round(pointEstimates_overYears |>
      filter(habitat == "Skog") |>
      pull(wmean), 3)),
  "Error (IQR)" = c(
    paste(round(nationalDist[1], 2), "-", round(nationalDist[2], 2)),
    paste(round(nationalDist_s[1], 2), "-", round(nationalDist_s[2], 2))
  )
) |>
  kable()


```
