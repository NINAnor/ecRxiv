---
title: "Functional plant community indicators"
subtitle: |
  [NO_FUNC_001] (farmland and open lowland) \
  [NO_FUNC_002] (mountains) \
  [NO_FUNC_003] (wetlands) \
  [NO_FUNC_004] (forests)
format: 
  html:
    embed-resources: true
    code-fold: true
    toc: true
    toc-title: Contents
    toc-depth: 3
    smooth-scroll: true
execute: 
  cache: true
author:
  - name: Joachim Töpper
    email: joachim.topper@nina.no
    affiliations:
      - id: myID
        name: Norwegian Institute for Nature Research
  - name: Erik Framstad
    affiliations:
      - ref: myID               # To reuse affiliations referecen the id like this
date: March 4, 2025 # Enter date 
callout-icon: false
lightbox: true
css: ../../../style.css
code-links:
      - text: Add a review
        icon: github
        href: https://github.com/NINAnor/ecRxiv
---

<!--# This is a template for how to document the indicator analyses. Make sure also to not change the order, or modify, the headers, unless you really need to. This is because it easier to read if all the indicators are presented using the same layout. If there is one header where you don't have anything to write, just leave the header as is, and don't write anything below it. If you are providing code, be careful to annotate and comment on every step in the analysis. Before starting it is recommended to fill in as much as you can in the metadata file. This file will populate the initial table in your output.-->

<!--# Load all you dependencies here -->

```{r setup}
#| include: false
library(knitr)
library(tidyverse)
library(kableExtra)
library(here)
library(sf)
library(readxl)
library(plyr)
library(RColorBrewer)
library("gridExtra") 
library(ggridges)
library(tmap)
library(tmaptools)
library(raster)
library(stars)
library(betareg)
library(glmmTMB)
library(flextable)
knitr::opts_chunk$set(echo = TRUE)
```

```{r source}
#| echo: false
source(here::here("_common.R"))
```

```{r}
#| echo: false
meta <- readxl::read_xlsx("../metadata.xlsx")
st <- meta |>
  filter(Variable == "status") |>
  pull(Value)
version <- meta |>
  filter(Variable == "Version") |>
  pull(Value)
auth <- meta |>
  filter(Variable == "authors") |>
  pull(Value)
year <- meta |>
  filter(Variable == "yearAdded") |>
  pull(Value)
id <- meta |>
  filter(Variable == "indicatorID") |>
  pull(Value)
name <- meta |>
  filter(Variable == "indicatorName") |>
  pull(Value)
url <- meta |>
  filter(Variable == "url") |>
  pull(Value)

meta <- meta |>
  mutate(Variable = case_match(Variable,
    "indicatorID" ~ "Indicator ID" ,
    "indicatorName" ~ "Indicator Name",
    "country" ~ "Country",
    "continent" ~ "Continent",
    "ECT" ~ "Ecosystem Condition Typology Class",
    "yearAdded" ~ "Year added",
    "yearLastUpdate" ~ "Last update",
    .default = Variable
   )
  ) |>
  filter(Variable != "authors")

```

<!--# The following parts are autogenerated. Do not edit. -->

```{r}
#| echo: false
#| results: asis
status(st)
```

::: {layout-ncol="2"}



> **Recomended citation**: `r paste(auth, " ", year, ". ", name, " (ID: ", id, ") ", "v. ", version, ". ecRxiv: ", url, sep="")`

> **Version**: `r version`

:::

```{=html}
<details>
<summary>Show metadata</summary>
```

```{r tbl-meta}
#| tbl-cap: 'Indicator metadata'
#| echo: false
#| warning: false

meta |>
  select(Variable, Value) |>
  kbl(col.names = NULL) 

```

```{=html}
</details>
```

::: {.callout-tip collapse="true"}

## Logg

<!--# Update this logg with short messages for each update -->
- 01 Jan. 1901 - Original PR
:::


<hr />

<!--# Document you work below.  -->

## 1. Summary
Functional plant community indicators represent the response of the vascular plant species composition to environmental variables (such as available temperature, moisture, nitrogen, light, pH, soil disturbance, and others) and to environmental stressors (such as competition, abiotic stress, and disturbance) and can thus be used to describe the functional signature of plant communities by calculating community-weighted means of functional indicator values related to these environmental variables or stressors for plant communities (Diekmann 2003). The functional signature of plant communities may be indicative of ecosystem condition, depending on which functional plant indicator we look at (cf. Töpper et al. 2018). For instance, using an indicator for moisture one would find a functional signature with higher moisture values for plant communities in mires compared to e.g. grasslands or forests. Deviations in the functional signature of such an indicator beyond a certain range of indicator values (as there of course is natural variation of functional signatures within an ecosystem type) may be related to a reduction in ecological condition. For different ecosystems different environmental variables are subject to change and thus relevant for condition accounting. In principle, both too much or too little of any environmental resource can represent a challenge leading to shifts in plant species composition. Thus, functional plant community indicators usually are two-sided indicators that can show deviations of a plant community towards both excess or limiting amounts of a resource. One exception here is the indicator for heat-requirement in alpine systems, which is designed as a one-sided indicator for a one-directional environmental pressure phenomenon: climate warming. This indicator does not rely on calculating community weighted means but rather on calculating cumulative abundance (see Framstad et al. 2022).

Here, we build functional plant community indicators by combining field sampled plant community data from the Norwegian nature monitoring program ANO (Tingstad et al. 2019) with functional plant indicator values from Tyler et al. (2021) and indicator values for plant strategies towards stressors from Grime (1974). We calculate the functional signatures of plant communities in the monitored sites with respect to various environmental variables depending on ecosystem type (not all variables are relevant for all ecosystem types). These functional signatures are then compared to reference distributions of functional signature, separately for each ecosystem type, calculated from ‘generalized species lists’ underlying the Norwegian categorization system for eco-diversity (Halvorsen et al. 2020). These functional plant community indicators are developed following the principles and technical protocol of the IBECA framework (Jakobsson et al. 2021, Töpper & Jakobsson 2021).

For grazing land and hay meadows as well as naturally open lowland ecosystems, the main challenges today are abandonment/land use change, climatic changes, pollution, and recreational overuse. Therefore, we use functional plant indicator values for light, moisture, pH, nitrogen, phosphorus, grazing/mowing, and soil disturbance as well as Grime's strategy indicator values for competition, abiotic stress, and disturbance. 
For mountain ecosystems, the main challenges today are disturbance from human infrastructure, climatic changes, species range shifts  , and pollution. For the first, functional plant indicators are not suitable; for the others, we use functional plant indicator values for heat requirement, light, and nitrogen, respectively.
For wetland ecosystems, the main challenges today are drainage, shrub/tree encroachment, pollution and climate change related changes in water table and moisture content.  Therefore, we use functional plant indicator values for moisture, light, pH, and nitrogen.
For forest ecosystems, the main challenges today are disturbance from human infrastructure, climatic changes, and pollution  . For the first, functional plant indicators are not suitable; for the others, we use functional plant indicator values for moisture and nitrogen.
Note, that these indicators do not address the issue of loss of area, which is the overarching and dominating reason for biodiversity loss both globally and in Norway. This pressure is covered in the extent account and not the condition account.

## 2. About the underlying data
We use three types of data for building functional plant community indicators for ecological condition:

- as observation data  we use plant community data from the ANO monitoring scheme (cf. Tingstad et al. 2019)
- as reference data we use generalized species lists from the Norwegian categorization system for eco-diversity (NiN) (Halvorsen et al. 2020) for basic ecosystem types in wetland, mountain, forest, and semi-natural ecosystems   - and a separate set of generalized species lists following the NiN-system for basic ecosystem types in naturally open ecosystems below the tree line from Evju et. al (2023)
- Swedish functional plant indicator data from Tyler et al. (2021) and indicator values for plant strategies from Grime (1974)

For details see point 7 below.


### 2.1 Spatial and temporal resolution and extent

The ANO monitoring data available now represent one cycle of sampling from 2019-2024 comprising ca. 1000 sites across Norway.
ANO has no defined end date. 2025 is the first year of repeated sampling for about 20% of the approximately 1000 ANO sites for all of mainland Norway (i.e. the Ecosystem Accounting Area). Annual sampling is spatially representative, in principle allowing to compute area-representative estimates   for single years but also 3-yr-reporting periods.

### 2.2 Original units

Abundance data for vascular plants in ANO is given as % cover within a 1 m2 sample quadrat. This is transformed to relative abundance data per quadrat. Each ANO quadrat is classified to its respective ecosystem type according to ‘Nature in Norway’ (NiN; https://artsdatabanken.no/NiN). Environmental indicator values from Tyler et al. (2021) are given on an ordinal scale from 1 (lowest affinity to the respective variable) to n (highest affinity to the respective variable), the number of levels (n) varying between environmental indicators. Strategy indicator values from Grime (1974) range from 0 to 1, and for each species the three strategies sum to 1.

### 2.3 Additional comments about the dataset

none

## 3. Indicator properties

### 3.1 Ecosystem Condition Typology Class (ECT)

All functional plant community indicators reflect the plant species composition and thus represent ECT class 'B1 Biotic compositional characteristics'.
Through the coupling of compositional data to environmental indicator values, the functional plant community indicators in addition represent the following ECT classes:
Functional plant community indicators for nitrogen, phosphorus and pH reflect the availability of nutrients and soil chemical properties and thus represent the ECT class 'A2 Chemical characteristics'.
Functional plant community indicators for heat requirement, moisture, light and abiotic stress (Grime's S) reflect the availability of abiotic, physical environmental resources and thus represent the ECT class 'A1 Physical characteristics'.
Functional plant community indicators for grazing/mowing, soil disturbance, competition (Grime's C) and vegetation disturbance (Grime's R) reflect the availability of physical structuring conditions and thus represent the ECT class 'A1 Physical characteristics'.
 
### 3.2 Ecosystem condition characteristic

Functional plant community indicators in general are aimed at describing to which degree ecosystems fulfill the criterion 'Intact plant community', i.e. to that degree they are in good condition with respect to a plant community composition reflecting the functional properties of the respective ecosystem in the reference condition.

The individual, specific functional plant community indicators represent concrete functional properties of an ecosystem and deviations from the reference thus shed light on which drivers affect the plant community.

For instance, the functional plant community indicator on nitrogen represents the influence of nitrogen on the plant community composition in the given ecosystem. Thus, deviations from the reference community towards e.g. higher nitrogen values reflect an environment characterized by higher availability of nitrogen which has led to shifts in plant species composition towards higher abundances of species with higher affinity to nitrogen. This functional plant community indicator for nitrogen reflects both the chemical properties of the ecosystem but also the ecosystem’s productivity.

### 3.3 Other standards

None

### 3.4 Collinearities with other indicators

Different functional plant community indicators for different environmental variables (light, moisture, ...) might show a certain degree of co-linearity with one another. Therefore, any aggregation of scaled functional plant community indicators to one single functional plant community indicator index should rely on using the indicator with worst scaled value and not on an average of all indicators.

Functional plant community indicators can potentially exhibit co-linearities with other vegetation-oriented indicators, such as NDVI, though this depends greatly on which functional plant community indicator ends up as the leading one (i.e. the one with the lowest scaled score).

### 3.5 Impact factors

<!--# Describe the main natural and anthropogenic factors that affecst the metric -->
CHAPTER CURRENTLY PROBABLY TOO GENERAL -> REVISE TO MAKE MORE INDICATOR CONCISE

Plant community composition is sensitive to consistent directional changes in environmental drivers, but the main pressures may vary between ecosystems.

Farmlands and open lowland ecosystems have been kept open by historic human activities and land use. With land-use change, intensivation of certain agricultural areas and abandonment of many other, encroachment of shrubs and trees is one of the main challenges today for anthropogenically open systems which change the plant community composition in a directional way. In addition, climatic changes, pollution and wear and tear (for instance from recreational overuse) alter the environmental conditions for both human influenced and naturally open ecosystems directionally, for instance through increased precipitation, drought spells and high critical loads of nitrogen deposition. 

Mountain ecosystems are characterized as limited by cold temperatures and usually low availability of nutrients. The main challenge today are thus climate warming and climate-warming related species range shifts (which introduce strong changes in biotic interactions between species) and pollution (e.g. nitrogen deposition) which affect the plant community composition in a directional way.

Wetland ecosystems are primarily characterized by high moisture and are thus threatened by drainage and shrub/tree encroachment, which both change the plant community composition dramatically. In addition, pollution can cause directional shifts in plant communities (e.g. nitrogen deposition).

The plant community composition in forest ecosystems is subject to changes with climate warming and precipitation changes as well as pollution.

Also alien species represent a major threat to all ecosystems, and this pressure may cause shifts in functional plant community signatures as found for naturally open systems around the Oslofjord (Evju et al. 2023).
## 4. Reference condition and levels

### 4.1 Reference condition

The reference condition is considered to be a plant community composition (see Jakobsson et al 2020) representing natural and undisturbed conditions (for natural ecosystems) or moderately disturbed, human influenced conditions in e.g. semi-natural grasslands under moderate long-term traditional grazing or mowing land management (but note that the plant species composition will vary between grazed and mowed grasslands). The reference condition for functional plant community indicators is represented by the generalized species lists for ecosystems as described in the Norwegian ecosystem categorization system NiN (Halvorsen et al. 2020) for forest, mountain, wetland and semi-natural ecosystem, and in Evju et al. (2023) for naturally open systems below the tree line.

### 4.2 Reference levels

For two-sided indicators, reference and limit values (scaling values) for functional plant community indicators are derived as the 0.025, 0.5, and 0.975 quantiles (lower limit values, reference value, upper limit value, respectively) from distributions of community weighted means of the respective plant indicators originating from bootstrapped generalized species lists.
For the one-sided indicator ‘Heat requirement’, the reference and limit values are derived as the 0.5 and 0.95 quantiles, respectively, of the bootstrapped distribution of summed relative abundance of heat requirement levels of 3 (‘reaching the low-alpine zone’) and higher.
Bootstraps were set up with resampling of the original generalized species lists 1000 times. In every sample a random 1/3 of the original generalized species list was sampled (as ANO points on average contain roughly a third of the potential species richness in the generalized species lists -> local variation in species composition thus is large and needs to be reflected in the bootstraps), with the exception of dominant species (abundance value of 5 or higher in the original scale of the generalized species lists), which were retained in every sample.
All reference distributions, and thus all scaling values are unique to NiN mapping units at a scale of 1:5000.

#### 4.2.1 Spatial resolution and validity

The scaling values vary between basic ecosystem types in the NiN-system, thus there are several sets of scaling values per major ecosystem type. Spatially, all scaling values apply for all of Norway and are not regionalized.

## 5. Uncertainties

Uncertainties relate partly to sampling and observer variability (and possible observer bias) in the recording of the plant cover data. Presumably, there is also uncertainty related to the scoring of indicator values for species, and this will probably vary among species (cf. Tyler et al. 2021 and Grime 1974). These potential sources uncertainty can only be assumed and not quantified.
Spatial variability as a source of uncertainty can be quantified. For every mean or median indicator value (after scaling) for every region (or any other delimited area of interest) we can calculate its corresponding standard error or confidence interval quantiles as a measure of spatial uncertainty for a geographical area.
Other uncertainties connected to the indicator arise from community weighted means calculated from plant communities of different species richness in the observation data; since no uncertainty measure for these community-weighted means is calculated and propagated, the actual uncertainty of functional community signals for the single community observations is unknown.


## 6. References

Diekmann, M. 2003. Species indicator values as an important tool in applied plant ecology - a review. Basic and Applied Ecology 4: 493-506, doi:10.1078/1439-1791-00185

Evju, M., Olsen, S.L., Prestø, T., Vange, V., Bratli, H. & Töpper, J. 2023. Ecological condition of naturally open areas below the forest line. Background, proposed indicators, and knowledge needs. NINA Report 2341. Norwegian Institute for Nature Research.

Framstad, E., Kolstad, A. L., Nybø, S., Töpper, J. & Vandvik, V. 2022. The condition of forest and mountain ecosystems in Norway. Assessment by the IBECA method. NINA Report 2100. Norwegian Institute for Nature Research.

Halvorsen, R., Skarpaas, O., Bryn, A., Bratli, H., Erikstad, L., Simensen, T., & Lieungh, E. (2020). Towards a systematics of ecodiversity: The EcoSyst framework. Global Ecology and Biogeography, 29(11), 1887-1906. doi:10.1111/geb.13164

Jakobsson, S., Töpper, J.P., Evju, M., Framstad, E., Lyngstad, A., Pedersen, B., Sickel, H., Sverdrup-Thygeson, A., Vandvik. V., Velle, L.G., Aarrestad, P.A. & Nybø, S. 2020. Setting reference levels and limits for good ecological condition in terrestrial ecosystems. Insights from a case study based on the IBECA approach. Ecological Indicators 116: 106492.

Jakobsson, S., Evju, M., Framstad, E., Imbert, A., Lyngstad, A., Sickel, H., Sverdrup-Thygeson, A., Töpper, J., Vandvik, V., Velle, L.G., Aarrestad, P.A. & Nybø, S. 2021. An index-based assessment of ecological condition and its links to international frameworks. Ecological Indicators 124: 107252.

Tingstad, L., Evju, M., Sickel, H., & Töpper, J. 2019. Utvikling av nasjonal arealrepresentativ naturovervåking (ANO). Forslag til gjennomføring, protokoller og kostnadsvurderinger med utgangspunkt i erfaringer fra uttesting i Trøndelag. NINA Rapport 1642.

Töpper, J. & Jakobsson, S. 2021. The Index-Based Ecological Condition Assessment (IBECA) - Technical protocol, version 1.0. NINA Report 1967. Norwegian Institute for Nature Research.

Töpper, J., Velle, L.G. & Vandvik, V. 2018. Developing a method for assessment of ecological state based on indicator values after Ellenberg and Grime (revised edition). NINA Report 1529b. Norwegian Institute for Nature Research.

Tyler, T., Herbertsson, L., Olofsson, J., & Olsson, P. A. 2021. Ecological indicator and traits values for Swedish vascular plants. Ecological In-dicators, 120. doi:10.1016/j.ecolind.2020.106923

## 7. Datasets

### 7.1 ANO monitoring data

ANO stands for areal-representativ naturovervåking, i.e. area representative nature monitoring. 1000 sites are randomly distributed across mainland Norway and visitied within a 5-year cycle. Each ANO site spans a 500 x 500 m grid cell, and the data collection at each ANO site includes up to 12 evenly distributed vegetation analyses in 1 x 1 m plots (up to 12, because some of these evenly distributed points may be in water or otherwise inaccessible). For the vegetation analyses, the cover of each vascular plant species in the plot is recorded. Every vegetation analysis is accompanied by an assessment of the ecosystem the plot lies in, including ecosystem type and some additional variables related to ecosystem-specific drivers of state (following the NiN system, Halvorsen et al. 2020). In the analyses described in this document, we use the data available on Miljødirektoratets kartkatalog (https://kartkatalog.miljodirektoratet.no/Dataset/Details/2054), which comprises data from the first round of data collection in ANO, 2019-2024  , and a total of 20 028 plots in 1052 sites. For some major ecosystem types no reference species lists exist, and the final evaluation of the functional plant community indicators thus comprised 15 787 plots in 1029 sites.
The timeframe of six years from 2019-2024 allows to create indicator values for the two 3-year reporting periods 2019-2021 and 2022-2024.


### 7.2. Reference data from NiN and from Evju et al. 2023

The generalized species lists underlying the ecosystem categorization in NiN (Halvorsen et al. 2020) and those for naturally open ecosystems below the tree line from Evju et al. (2023) represent expert-compiled species lists based on empirical evidence from the literature and expert knowledge of the systems and their species. In these lists, every species is assigned an abundance value on a 6-step scale, with each step representing a range for the ‘expected combination of frequency and cover’ of occurrence

1 = < 1/32

2 = 1/32 - 1/8

3 = 1/8 - 3/8

4 = 3/8 - 4/5

5 = 3/8 - 4/5 + dominance

6 = > 4/5

For the purpose of this project, these steps are simplified to maximum expected combination of frequency and cover, whereby steps 4 & 5 are assigned 0.6 and 0.8, respectively, in order to distinguish between them.

### 7.3. The Swedish plant indicator values
The Swedish plant indicator values dataset published by Tyler et al. (2021) contains a large collection of plant indicators based on the Swedish flora, which is well representative of the Norwegian flora as well. From this set, we use indicator data for light, heat requirement, moisture, pH, nitrogen, phosphorus, grazing/mowing, and soil disturbance as these are thought to be subject to potential change due to ongoing pressures in the respective ecosystems (see details above under 'Summary').

### 7.4. Grime's plant strategy indicator values
Grime's plant strategy indicator values (Grime 1974) comprise three plant strategies evolved in plant species to meet competition (C), abiotic stress (S), and disturbance (R). Values range between 0 (strategy absent) and 1 (the only strategy present) and the three strategy indicators sum to 1 in every plant species.

## 8. Spatial units

The spatial units for functional plant community indicators are governed by the ANO data, which consist of 1000 randomly chosen sites in Norway. Each site is a 500 x 500 m grid cell with 18 monitoring points of 250sqm and a central 1 x 1 m vegetation plot. The basic unit for which observational community data exist, and for which every functional plant community indicator is computed, is this central 1 x 1 m vegetation plot. Aggregation of these basic spatial units to higher ones - like sites, municipalities, counties, regions, or the national level - should be done with appropriate consideration of the spatial structure of the data, i.e. imbalances and clustering (highly unequal number of points of an ecosystem type between sites).

## 9. Analyses

<!--# 

Use this header for documenting the analyses. Put code in seperate code chunks, and annotate the code in between using normal text (i.e. between the chunks, and try to avoid too many hashed out comments inside the code chunks). Add subheaders as needed. 

Code folding is activated, meaning the code will be hidden by default in the html (one can click to expand it).

Caching is also activated (from the top YAML), meaning that rendering to html will be quicker the second time you do it. This will create a folder inside you project folder (called INDICATORID_cache). Sometimes caching created problems because some operations are not rerun when they should be rerun. Try deleting the cash folder and try again.

-->
### Data sets
<!-- Please print the entire workflow with echo=T. Also, simply reading cached data creates loose ends - I cant find out where this data comes from. You may also chose to read tin this data (or a cached version of it) way at the top of the file, so that you can add some in-line R code for the summary stats in the introduction part (see previous comments)-->

Import testing data:
```{r}
#Sys.setlocale("LC_ALL", "no_NB.utf8") #works with æøå or use "Norwegian"
# ANO data
ANO.sp <- st_read("C:/Users/joachim.topper/OneDrive - NINA/work/projects/oekologisk tilstand/Naturovervaking_eksport.gdb",
                    layer="ANO_Art")
ANO.geo <- st_read("C:/Users/joachim.topper/OneDrive - NINA/work/projects/oekologisk tilstand/Naturovervaking_eksport.gdb",
                   layer="ANO_SurveyPoint")
head(ANO.sp)
head(ANO.geo)

# GRUK data
GRUK.variables<-readRDS(paste0(here::here(),"/indicators/NO_FUNC_001-004/data/cache/GRUK.variables.RDS"))
GRUK.species<-readRDS(paste0(here::here(),"/indicators/NO_FUNC_001-004/data/cache/GRUK.species.RDS"))
GRUK2021.condition<-readRDS(paste0(here::here(),"/indicators/NO_FUNC_001-004/data/cache/GRUK2021.condition.RDS"))

# ASO data
ASO.sp<-readRDS(paste0(here::here(),"/indicators/NO_FUNC_001-004/data/cache/ASO.sp.RDS"))
ASO.geo<-readRDS(paste0(here::here(),"/indicators/NO_FUNC_001-004/data/cache/ASO.geo.RDS"))

# 3Q data


```

Import Plant indicators from Tyler et al. (2021):
```{r}
## Tyler indicator data
#ind.Tyler <-readRDS(paste0(here::here(),"/indicators/NO_FUNC_001-004/data/cache/ind.dat.RDS"))
ind.Tyler <- read.table("P:/41201785_okologisk_tilstand_2022_2023/data/functional plant indicators/Tyler et al_Swedish plant indicators.txt", sep = '\t', header=T, quote = '')
# head(ind.Tyler)
 
ind.Grime<-readRDS(paste0(here::here(),"/indicators/NO_FUNC_001-004/data/cache/ind.Grime.RDS"))


```

Import reference species lists (Generalized species lists from NiN & from Evju et al. 2023)
```{r}
# data from cache
Eco_State<-readRDS(paste0(here::here(),"/indicators/NO_FUNC_001-004/data/cache/Eco_State.RDS"))
# load("/data/P-Prosjekter2/41201785_okologisk_tilstand_2022_2023/functional plant indicators/reference from NiN/Eco_State.RData")
# str(Eco_State)
natopen_NiN_ref<-readRDS(paste0(here::here(),"/indicators/NO_FUNC_001-004/data/cache/natopen_NiN_ref.RDS"))
natopen_NiN_ref_spInfo<-readRDS(paste0(here::here(),"/indicators/NO_FUNC_001-004/data/cache/natopen_NiN_ref_spInfo.RDS"))
```

#### Data handling
- Checking for errors
- Checking species nomenclature in the different species lists to make species and indicator data possible to merge
- Merging indicator data with monitoring data and indicator data with reference data
(not shown here, but documented in the code)
<!-- Please include everything like this, but you can chose to have it take up less space by adding the attr.output option, like this: -->


```{r, include = T, results='hide', warning=F, message=F}

#### Plant indicator data
names(ind.Tyler)
names(ind.Tyler)[1] <- 'species'
ind.Tyler$species <- as.factor(ind.Tyler$species)
summary(ind.Tyler$species)
ind.Tyler <- ind.Tyler[!is.na(ind.Tyler$species),] # removing species-NAs
ind.Tyler[,'species.orig'] <- ind.Tyler[,'species'] # make a backup of the original species variable
ind.Tyler[,'species'] <- word(ind.Tyler[,'species'], 1,2) # trimming away sub-species & co, and descriptor info

ind.Grime[,'species.orig'] <- ind.Grime[,'species'] # make a backup of the original species variable
ind.Grime[,'species'] <- word(ind.Grime[,'species'], 1,2) # trimming away sub-species & co, and descriptor info


# the trimming above leaves some duplicates that need to be taken care of
ind.Grime[duplicated(ind.Grime[,'species']),"species"]
ind.Grime.dup <- ind.Grime[duplicated(ind.Grime[,'species']),c("species")]
ind.Grime[ind.Grime$species %in% ind.Grime.dup,]
# getting rid of the duplicates in the Grime data
ind.Grime <- ind.Grime %>% filter( !(species.orig %in% list("Carex viridula brachyrrhyncha",
                                                            "Dactylorhiza fuchsii praetermissa",
                                                            "Medicago sativa varia",
                                                            "Montia fontana chondrosperma",
                                                            "Papaver dubium lecoqii",
                                                            "Sanguisorba minor muricata")
) )

ind.Tyler[duplicated(ind.Tyler[,'species']),"species"]
ind.Tyler.dup <- ind.Tyler[duplicated(ind.Tyler[,'species']),"species"]
ind.Tyler[ind.Tyler$species %in% ind.Tyler.dup,c("Light","Moisture","Soil_reaction_pH","Nitrogen","Heat_requirement","species.orig","species")]
ind.Tyler <- ind.Tyler %>% filter( !(species.orig %in% list("Ammophila arenaria x Calamagrostis epigejos",
                                                            "Anemone nemorosa x ranunculoides",
                                                            "Armeria maritima ssp. elongata",
                                                            "Asplenium trichomanes ssp. quadrivalens",
                                                            "Calystegia sepium ssp. spectabilis",
                                                            "Campanula glomerata 'Superba'",
                                                            "Dactylorhiza maculata ssp. fuchsii",
                                                            "Erigeron acris ssp. droebachensis",
                                                            "Erigeron acris ssp. politus",
                                                            "Erysimum cheiranthoides L. ssp. alatum",
                                                            "Euphrasia nemorosa x stricta var. brevipila",
                                                            "Galium mollugo x verum",
                                                            "Geum rivale x urbanum",
                                                            "Hylotelephium telephium (ssp. maximum)",
                                                            "Juncus alpinoarticulatus ssp. rariflorus",
                                                            "Lamiastrum galeobdolon ssp. argentatum",
                                                            "Lathyrus latifolius ssp. heterophyllus",
                                                            "Medicago sativa ssp. falcata",
                                                            "Medicago sativa ssp. x varia",
                                                            "Monotropa hypopitys ssp. hypophegea",
                                                            "Ononis spinosa ssp. hircina",
                                                            "Ononis spinosa ssp. procurrens",
                                                            "Pilosella aurantiaca ssp. decolorans",
                                                            "Pilosella aurantiaca ssp. dimorpha",
                                                            "Pilosella cymosa ssp. gotlandica",
                                                            "Pilosella cymosa ssp. praealta",
                                                            "Pilosella officinarum ssp. peleteranum",
                                                            "Poa x jemtlandica (Almq.) K. Richt.",
                                                            "Poa x herjedalica Harry Sm.",
                                                            "Ranunculus peltatus ssp. baudotii",
                                                            "Sagittaria natans x sagittifolia",
                                                            "Salix repens ssp. rosmarinifolia",
                                                            "Stellaria nemorum L. ssp. montana",
                                                            "Trichophorum cespitosum ssp. germanicum")
) )

# checking duplicates again
ind.Tyler[duplicated(ind.Tyler[,'species']),"species"]
ind.Tyler.dup <- ind.Tyler[duplicated(ind.Tyler[,'species']),"species"]
ind.Tyler[ind.Tyler$species %in% ind.Tyler.dup,c("Light","Moisture","Soil_reaction_pH","Nitrogen","Heat_requirement", "Soil_disturbance","Phosphorus","Grazing_mowing","species.orig","species")]
# getting rid of sect. for Hieracium
ind.Tyler <- ind.Tyler %>% mutate(species=gsub("sect. ","",species.orig))
ind.Tyler[,'species'] <- word(ind.Tyler[,'species'], 1,2)

ind.Tyler[duplicated(ind.Tyler[,'species']),"species"]
ind.Tyler.dup <- ind.Tyler[duplicated(ind.Tyler[,'species']),"species"]
ind.Tyler[ind.Tyler$species %in% ind.Tyler.dup,c("Light","Moisture","Soil_reaction_pH","Nitrogen","Heat_requirement", "Soil_disturbance","Phosphorus","Grazing_mowing","species.orig","species")]
# only hybrids left -> get rid of these
ind.Tyler <- ind.Tyler[!duplicated(ind.Tyler[,'species']),]
ind.Tyler[duplicated(ind.Tyler[,'species']),"species"]

ind.Tyler$species <- as.factor(ind.Tyler$species)
summary(ind.Tyler$species)
# no duplicates left

head(ind.Tyler)

# merge indicator data
ind.dat <- merge(ind.Grime,ind.Tyler, by="species", all=T)
#summary(ind.dat)
#ind.dat[duplicated(ind.dat[,'species']),"species"]
ind.dat$species <- as.factor(ind.dat$species)
#summary(ind.dat$species)
head(ind.dat)


#### ANO monitoring data

head(ANO.sp)
head(ANO.geo)

## fix NiN information
ANO.geo$hovedtype_rute <- substr(ANO.geo$kartleggingsenhet_1m2,1,3) # take the 3 first characters
ANO.geo$hovedtype_rute <- gsub("-", "", ANO.geo$hovedtype_rute) # remove hyphen
unique(as.factor(ANO.geo$hovedtype_rute))

## fix NiN-variables
colnames(ANO.geo)
colnames(ANO.geo)[42:47] <- c("groeftingsintensitet",
                              "bruksintensitet",
                              "beitetrykk",
                              "slatteintensitet",
                              "tungekjoretoy",
                              "slitasje")
head(ANO.geo)

# remove variable code in the data
ANO.geo$groeftingsintensitet <- gsub("7GR-GI_", "", ANO.geo$groeftingsintensitet) 
unique(ANO.geo$groeftingsintensitet)
ANO.geo$groeftingsintensitet <- gsub("X", "NA", ANO.geo$groeftingsintensitet)
unique(ANO.geo$groeftingsintensitet)
ANO.geo$groeftingsintensitet <- as.numeric(ANO.geo$groeftingsintensitet)
unique(ANO.geo$groeftingsintensitet)

ANO.geo$bruksintensitet <- gsub("7JB-BA_", "", ANO.geo$bruksintensitet) 
unique(ANO.geo$bruksintensitet)
ANO.geo$bruksintensitet <- gsub("X", "NA", ANO.geo$bruksintensitet)
unique(ANO.geo$bruksintensitet)
ANO.geo$bruksintensitet <- as.numeric(ANO.geo$bruksintensitet)
unique(ANO.geo$bruksintensitet)

ANO.geo$beitetrykk <- gsub("7JB-BT_", "", ANO.geo$beitetrykk) 
unique(ANO.geo$beitetrykk)
ANO.geo$beitetrykk <- gsub("X", "NA", ANO.geo$beitetrykk)
unique(ANO.geo$beitetrykk)
ANO.geo$beitetrykk <- as.numeric(ANO.geo$beitetrykk)
unique(ANO.geo$beitetrykk)

ANO.geo$slatteintensitet <- gsub("7JB-SI_", "", ANO.geo$slatteintensitet) 
unique(ANO.geo$slatteintensitet)
ANO.geo$slatteintensitet <- gsub("X", "NA", ANO.geo$slatteintensitet)
unique(ANO.geo$slatteintensitet)
ANO.geo$slatteintensitet <- as.numeric(ANO.geo$slatteintensitet)
unique(ANO.geo$slatteintensitet)

ANO.geo$tungekjoretoy <- gsub("7TK_", "", ANO.geo$tungekjoretoy) 
unique(ANO.geo$tungekjoretoy)
ANO.geo$tungekjoretoy <- gsub("X", "NA", ANO.geo$tungekjoretoy)
unique(ANO.geo$tungekjoretoy)
ANO.geo$tungekjoretoy <- as.numeric(ANO.geo$tungekjoretoy)
unique(ANO.geo$tungekjoretoy)

ANO.geo$slitasje <- gsub("7SE_", "", ANO.geo$slitasje) 
unique(ANO.geo$slitasje)
ANO.geo$slitasje <- gsub("X", "NA", ANO.geo$slitasje)
unique(ANO.geo$slitasje)
ANO.geo$slitasje <- as.numeric(ANO.geo$slitasje)
unique(ANO.geo$slitasje)

## check that every point is present only once
length(levels(as.factor(ANO.geo$ano_flate_id)))
length(levels(as.factor(ANO.geo$ano_punkt_id)))
summary(as.factor(ANO.geo$ano_punkt_id))
# there's many double presences, probably some wrong registrations of point numbers,
# but also double registrations (e.g. ANO0159_55)
# CHECK THIS when preparing ecosystem-datasets for scaling




# fix species names
ANO.sp$Species <- ANO.sp$art_navn
unique(as.factor(ANO.sp$Species))
ANO.sp[,'Species'] <- word(ANO.sp[,'Species'], 1,2) # lose subspecies
ANO.sp$Species <- str_to_title(ANO.sp$Species) # make first letter capital
ANO.sp$Species <- gsub("( .*)","\\L\\1",ANO.sp$Species,perl=TRUE) # make capital letters after hyphen to lowercase
ANO.sp$Species <- gsub("( .*)","\\L\\1",ANO.sp$Species,perl=TRUE) # make capital letters after space to lowercase

## merge species data with indicators
ANO.sp.ind <- merge(x=ANO.sp[,c("Species", "art_dekning", "parentglobalid")], 
                y= ind.dat[,c("species", "CC", "SS", "RR", "Light", "Moisture", "Soil_reaction_pH", "Nitrogen","Heat_requirement", "Soil_disturbance","Phosphorus","Grazing_mowing")],
                by.x="Species", by.y="species", all.x=T)
summary(ANO.sp.ind)


## checking which species didn't find a match
unique(ANO.sp.ind[is.na(ANO.sp.ind$Moisture),'Species'])

# fix species name issues
ind.dat <- ind.dat %>% 
  mutate(species=str_replace(species,"Aconitum lycoctonum", "Aconitum septentrionale")) %>% 
  mutate(species=str_replace(species,"Carex simpliciuscula", "Kobresia simpliciuscula")) %>%
  mutate(species=str_replace(species,"Carex myosuroides", "Kobresia myosuroides")) %>%
  mutate(species=str_replace(species,"Clinopodium acinos", "Acinos arvensis")) %>%
  mutate(species=str_replace(species,"Artemisia rupestris", "Artemisia norvegica")) %>%
  mutate(species=str_replace(species,"Cherleria biflora", "Minuartia biflora")) %>%
  mutate(species=str_replace(species,"Rosa vosagica", "Rosa vosagiaca"))

ANO.sp <- ANO.sp %>% 
  mutate(Species=str_replace(Species,"Agrostis hyemalis", "Agrostis scabra")) %>%
  mutate(Species=str_replace(Species,"Antennaria lapponica", "Antennaria alpina")) %>%
  mutate(Species=str_replace(Species,"Antennaria porsildii", "Antennaria alpina")) %>%
  mutate(Species=str_replace(Species,"Arctous alpinus", "Arctous alpina")) %>%
  mutate(Species=str_replace(Species,"Betula tortuosa", "Betula pubescens")) %>%
  mutate(Species=str_replace(Species,"Blysmopsis rufa", "Blysmus rufus")) %>%
  mutate(Species=str_replace(Species,"Cardamine nymanii", "Cardamine pratensis")) %>%
  mutate(Species=str_replace(Species,"Carex adelostoma", "Carex buxbaumii")) %>%
  mutate(Species=str_replace(Species,"Carex concolor", "Carex aquatilis")) %>%
  mutate(Species=str_replace(Species,"Carex leersii", "Carex echinata")) %>%
  mutate(Species=str_replace(Species,"Carex myosuroides", "Kobresia myosuroides")) %>%
  mutate(Species=str_replace(Species,"Carex paupercula", "Carex magellanica")) %>%
  mutate(Species=str_replace(Species,"Carex simpliciuscula", "Kobresia simpliciuscula")) %>%
  mutate(Species=str_replace(Species,"Carex viridula", "Carex flava")) %>%
  mutate(Species=str_replace(Species,"Chamaepericlymenum suecicum", "Cornus suecia")) %>%
  mutate(Species=str_replace(Species,"Cicerbita alpina", "Lactuca alpina")) %>%
  mutate(Species=str_replace(Species,"Cornus suecia", "Cornus suecica")) %>%
  mutate(Species=str_replace(Species,"Cotoneaster scandinavicus", "Cotoneaster integerrimus")) %>%
  mutate(Species=str_replace(Species,"Dactylorhiza viridis", "Coeloglossum viride")) %>%
  mutate(Species=str_replace(Species,"Diphasiastrum alpinum", "Lycopodium alpinum")) %>%
  mutate(Species=str_replace(Species,"Diphasiastrum complanatum", "Lycopodium complanatum")) %>%
  mutate(Species=str_replace(Species,"Dryopteris affinis", "Dryopteris filix-mas")) %>%
  mutate(Species=str_replace(Species,"Empetrum hermaphroditum", "Empetrum nigrum")) %>%
  mutate(Species=str_replace(Species,"Elymus alaskanus", "Elymus kronokensis")) %>%
  mutate(Species=str_replace(Species,"Festuca prolifera", "Festuca rubra")) %>%
  mutate(Species=str_replace(Species,"Galium album", "Galium mollugo")) %>%
  mutate(Species=str_replace(Species,"Galium elongatum", "Galium palustre")) %>%
  mutate(Species=str_replace(Species,"Helictotrichon pratense", "Avenula pratensis")) %>%
  mutate(Species=str_replace(Species,"Helictotrichon pubescens", "Avenula pubescens")) %>%
  mutate(Species=str_replace(Species,"Hieracium alpina", "Hieracium Alpina")) %>%
  mutate(Species=str_replace(Species,"Hieracium alpinum", "Hieracium Alpina")) %>%
  mutate(Species=str_replace(Species,"Hieracium hieracium", "Hieracium Hieracium")) %>%
  mutate(Species=str_replace(Species,"Hieracium hieracioides", "Hieracium umbellatum")) %>%
  mutate(Species=str_replace(Species,"Hieracium murorum", "Hieracium Vulgata")) %>%
  mutate(Species=str_replace(Species,"Hieracium oreadea", "Hieracium Oreadea")) %>%
  mutate(Species=str_replace(Species,"Hieracium prenanthoidea", "Hieracium Prenanthoidea")) %>%
  mutate(Species=str_replace(Species,"Hieracium vulgata", "Hieracium Vulgata")) %>%
  mutate(Species=str_replace(Species,"Hieracium pilosella", "Pilosella officinarum")) %>%
  mutate(Species=str_replace(Species,"Hieracium vulgatum", "Hieracium umbellatum")) %>%
  mutate(Species=str_replace(Species,"Hierochloã« alpina", "Hierochloë alpina")) %>%
  mutate(Species=str_replace(Species,"Hierochloã« hirta", "Hierochloë hirta")) %>%
  mutate(Species=str_replace(Species,"Hierochloã« odorata", "Hierochloë odorata")) %>%
  mutate(Species=str_replace(Species,"Huperzia appressa", "Huperzia selago")) %>%
  mutate(Species=str_replace(Species,"Huperzia arctica", "Huperzia selago")) %>%
  mutate(Species=str_replace(Species,"Hylotelephium maximum", "Sedum telephium")) %>%
  mutate(Species=str_replace(Species,"Listera cordata", "Neottia cordata")) %>%
  mutate(Species=str_replace(Species,"Leontodon autumnalis", "Scorzoneroides autumnalis")) %>%
  mutate(Species=str_replace(Species,"Loiseleuria procumbens", "Kalmia procumbens")) %>%
  mutate(Species=str_replace(Species,"Minuartia rubella", "Sabulina rubella")) %>%
  mutate(Species=str_replace(Species,"Minuartia stricta", "Sabulina stricta")) %>%
  mutate(Species=str_replace(Species,"Mycelis muralis", "Lactuca muralis")) %>%
  mutate(Species=str_replace(Species,"Omalotheca supina", "Gnaphalium supinum")) %>%
  mutate(Species=str_replace(Species,"Omalotheca norvegica", "Gnaphalium norvegicum")) %>%
  mutate(Species=str_replace(Species,"Omalotheca sylvatica", "Gnaphalium sylvaticum")) %>%
  mutate(Species=str_replace(Species,"Oreopteris limbosperma", "Thelypteris limbosperma")) %>%
  mutate(Species=str_replace(Species,"Oxycoccus microcarpus", "Vaccinium microcarpum")) %>%
  mutate(Species=str_replace(Species,"Oxycoccus palustris", "Vaccinium oxycoccos")) %>%
  mutate(Species=str_replace(Species,"Phalaris minor", "Phalaris arundinacea")) %>%
  mutate(Species=str_replace(Species,"Pinus unicinata", "Pinus mugo")) %>%
  mutate(Species=str_replace(Species,"Poa alpigena", "Poa pratensis")) %>%
  mutate(Species=str_replace(Species,"Poa angustifolia", "Poa pratensis")) %>%
  mutate(Species=str_replace(Species,"Poa ×jemtlandica", "Poa alpina")) %>%
  mutate(Species=str_replace(Species,"Potentilla anserina", "Argentina anserina")) %>%
  mutate(Species=str_replace(Species,"Potentilla arenosa", "Potentilla nivea")) %>%
  mutate(Species=str_replace(Species,"Pyrola grandiflora", "Pyrola rotundifolia")) %>%
  mutate(Species=str_replace(Species,"Rubus fruticosus", "Rubus plicatus")) %>%
  mutate(Species=str_replace(Species,"Rumex alpestris", "Rumex acetosa")) %>%
  mutate(Species=str_replace(Species,"Stellaria uliginosa", "Stellaria alsine")) %>%
  mutate(Species=str_replace(Species,"Syringa emodi", "Syringa vulgaris")) %>%
  mutate(Species=str_replace(Species,"Taraxacum crocea", "Taraxacum officinale")) %>%
  mutate(Species=str_replace(Species,"Taraxacum croceum", "Taraxacum officinale")) %>%
  mutate(Species=str_replace(Species,"Trientalis europaea", "Lysimachia europaea")) %>%
  mutate(Species=str_replace(Species,"Trifolium pallidum", "Trifolium pratense")) %>%
  mutate(Species=str_replace(Species,"Veratrum lobelianum", "Veratrum album"))

## merge species data with indicators
ANO.sp.ind <- merge(x=ANO.sp[,c("Species", "art_dekning", "parentglobalid")], 
                    y= ind.dat[,c("species", "CC", "SS", "RR", "Light", "Moisture", "Soil_reaction_pH", "Nitrogen","Heat_requirement", "Soil_disturbance","Phosphorus","Grazing_mowing")],
                    by.x="Species", by.y="species", all.x=T)
summary(ANO.sp.ind)
# checking which species didn't find a match
unique(ANO.sp.ind[is.na(ANO.sp.ind$Moisture),'Species'])
# don't find synonyms for these in the ind lists

## trimming away the points without information on NiN, species or cover
ANO.sp.ind <- ANO.sp.ind[!is.na(ANO.sp.ind$Species),]
ANO.sp.ind <- ANO.sp.ind[!is.na(ANO.sp.ind$art_dekning),]


summary(ANO.sp.ind)
head(ANO.sp.ind)
rm(ANO.sp)


#### GRUK data handling
names(GRUK.variables)
names(GRUK.species)
names(GRUK2021.condition)

colnames(GRUK.species)[5] <- "art_dekning"

# fix species names
GRUK.species <- as.data.frame(GRUK.species)

GRUK.species$Species <- GRUK.species$Navn
unique(as.factor(GRUK.species$Species))
GRUK.species$Species <- sub(".*?_", "", GRUK.species$Species) # lose the Norwegian name in the front
GRUK.species$Species <- gsub("_", " ", GRUK.species$Species) # replace underscore with space
GRUK.species$Species <- str_to_title(GRUK.species$Species) # make first letter capital
GRUK.species$Species <- gsub("( .*)","\\L\\1",GRUK.species$Species,perl=TRUE) # make capital letters after hyphon to lowercase
GRUK.species$Species <- gsub("( .*)","\\L\\1",GRUK.species$Species,perl=TRUE) # make capital letters after space to lowercase
GRUK.species[,'Species'] <- word(GRUK.species[,'Species'], 1,2) # lose subspecies




## merge species data with indicators
GRUK.species.ind <- merge(x=GRUK.species[,c("Species", "art_dekning", "ParentGlobalID")], 
                          y= ind.dat[,c("species","CC", "SS", "RR","Light", "Nitrogen", "Soil_disturbance")],
                          by.x="Species", by.y="species", all.x=T)
summary(GRUK.species.ind)


# checking which species didn't find a match
unique(GRUK.species.ind[is.na(GRUK.species.ind$Light & 
                                is.na(GRUK.species.ind$RR)),'Species'])



# fix species name issues
GRUK.species <- GRUK.species %>% 
  mutate(Species=str_replace(Species,"Arabis wahlenbergii", "Arabis hirsuta")) %>%
  #  mutate(Species=str_replace(Species,"Arctous alpinus", "Arctous alpina")) %>%
  #  mutate(Species=str_replace(Species,"Betula tortuosa", "Betula pubescens")) %>%
  #  mutate(Species=str_replace(Species,"Blysmopsis rufa", "Blysmus rufus")) %>%
  #  mutate(Species=str_replace(Species,"Cardamine nymanii", "Cardamine pratensis")) %>%
  #  mutate(Species=str_replace(Species,"Carex adelostoma", "Carex buxbaumii")) %>%
  #  mutate(Species=str_replace(Species,"Carex leersii", "Carex echinata")) %>%
  mutate(Species=str_replace(Species,"Carex paupercula", "Carex magellanica")) %>%
  #  mutate(Species=str_replace(Species,"Carex simpliciuscula", "Kobresia simpliciuscula")) %>%
  mutate(Species=str_replace(Species,"Carex viridula", "Carex flava")) %>%
  #  mutate(Species=str_replace(Species,"Chamaepericlymenum suecicum", "Cornus suecia")) %>%
  #  mutate(Species=str_replace(Species,"Cicerbita alpina", "Lactuca alpina")) %>%
  mutate(Species=str_replace(Species,"Cotoneaster scandinavicus", "Cotoneaster integerrimus")) %>%
  mutate(Species=str_replace(Species,"Cotoneaster symondsii", "Cotoneaster integrifolius")) %>%
  mutate(Species=str_replace(Species,"Cyanus montanus", "Centaurea montana")) %>%
  #  mutate(Species=str_replace(Species,"Empetrum hermaphroditum", "Empetrum nigrum")) %>%
  mutate(Species=str_replace(Species,"Erysimum virgatum", "Erysimum strictum")) %>%
  #  mutate(Species=str_replace(Species,"Festuca prolifera", "Festuca rubra")) %>%
  mutate(Species=str_replace(Species,"Festuca trachyphylla", "Festuca brevipila")) %>%
  mutate(Species=str_replace(Species,"Galium album", "Galium mollugo")) %>%
  #  mutate(Species=str_replace(Species,"Galium elongatum", "Galium palustre")) %>%
  mutate(Species=str_replace(Species,"Helictotrichon pratense", "Avenula pratensis")) %>%
  mutate(Species=str_replace(Species,"Helictotrichon pubescens", "Avenula pubescens")) %>%
  #  mutate(Species=str_replace(Species,"Hieracium alpina", "Hieracium Alpina")) %>%
  #  mutate(Species=str_replace(Species,"Hieracium alpinum", "Hieracium Alpina")) %>%
  #  mutate(Species=str_replace(Species,"Hieracium hieracium", "Hieracium Hieracium")) %>%
  #  mutate(Species=str_replace(Species,"Hieracium hieracioides", "Hieracium umbellatum")) %>%
  mutate(Species=str_replace(Species,"Hieracium murorum", "Hieracium Vulgata")) %>%
  #  mutate(Species=str_replace(Species,"Hieracium oreadea", "Hieracium Oreadea")) %>%
  #  mutate(Species=str_replace(Species,"Hieracium prenanthoidea", "Hieracium Prenanthoidea")) %>%
  #  mutate(Species=str_replace(Species,"Hieracium vulgata", "Hieracium Vulgata")) %>%
  #  mutate(Species=str_replace(Species,"Hieracium pilosella", "Pilosella officinarum")) %>%
  #  mutate(Species=str_replace(Species,"Hieracium vulgatum", "Hieracium umbellatum")) %>%
  #  mutate(Species=str_replace(Species,"Hierochloã« alpina", "Hierochloë alpina")) %>%
  #  mutate(Species=str_replace(Species,"Hierochloã« hirta", "Hierochloë hirta")) %>%
  #  mutate(Species=str_replace(Species,"Hierochloã« odorata", "Hierochloë odorata")) %>%
  mutate(Species=str_replace(Species,"Hylotelephium maximum", "Sedum telephium")) %>%
  #  mutate(Species=str_replace(Species,"Listera cordata", "Neottia cordata")) %>%
  #  mutate(Species=str_replace(Species,"Leontodon autumnalis", "Scorzoneroides autumnalis")) %>%
  mutate(Species=str_replace(Species,"Lepidotheca suaveolens", "Matricaria discoidea")) %>%
  #  mutate(Species=str_replace(Species,"Loiseleuria procumbens", "Kalmia procumbens")) %>%
  mutate(Species=str_replace(Species,"Malus ×domestica", "Malus domestica")) %>%
  #  mutate(Species=str_replace(Species,"Mycelis muralis", "Lactuca muralis")) %>%
  #  mutate(Species=str_replace(Species,"Omalotheca supina", "Gnaphalium supinum")) %>%
  #  mutate(Species=str_replace(Species,"Omalotheca norvegica", "Gnaphalium norvegicum")) %>%
  #  mutate(Species=str_replace(Species,"Omalotheca sylvatica", "Gnaphalium sylvaticum")) %>%
  #  mutate(Species=str_replace(Species,"Oreopteris limbosperma", "Thelypteris limbosperma")) %>%
  #  mutate(Species=str_replace(Species,"Oxycoccus microcarpus", "Vaccinium microcarpum")) %>%
  #  mutate(Species=str_replace(Species,"Oxycoccus palustris", "Vaccinium oxycoccos")) %>%
  #  mutate(Species=str_replace(Species,"Phalaris minor", "Phalaris arundinacea")) %>%
  #  mutate(Species=str_replace(Species,"Pinus unicinata", "Pinus mugo")) %>%
  #  mutate(Species=str_replace(Species,"Poa alpigena", "Poa pratensis")) %>%
  mutate(Species=str_replace(Species,"Poa angustifolia", "Poa pratensis")) %>%
  mutate(Species=str_replace(Species,"Poa humilis", "Poa pratensis")) %>%
  #  mutate(Species=str_replace(Species,"Pyrola grandiflora", "Pyrola rotundifolia")) %>%
  mutate(Species=str_replace(Species,"Rosa dumalis", "Rosa vosagiaca")) %>%
  #  mutate(Species=str_replace(Species,"Rumex alpestris", "Rumex acetosa")) %>%
  #  mutate(Species=str_replace(Species,"Syringa emodi", "Syringa vulgaris")) %>%
  #  mutate(Species=str_replace(Species,"Taraxacum crocea", "Taraxacum officinale")) %>%
  #  mutate(Species=str_replace(Species,"Taraxacum croceum", "Taraxacum officinale")) %>%
  #  mutate(Species=str_replace(Species,"Trientalis europaea", "Lysimachia europaea")) %>%
  mutate(Species=str_replace(Species,"Trifolium pallidum", "Trifolium pratense"))

## merge species data with indicators
GRUK.species.ind <- merge(x=GRUK.species[,c("Species", "art_dekning", "ParentGlobalID")], 
                          y= ind.dat[,c("species","CC", "SS", "RR","Light", "Nitrogen", "Soil_disturbance")],
                          by.x="Species", by.y="species", all.x=T)
summary(GRUK.species.ind)
# checking which species didn't find a match
unique(GRUK.species.ind[is.na(GRUK.species.ind$Light & 
                                is.na(GRUK.species.ind$RR)),'Species'])

### make GRUK.variables into spatial object
names(GRUK.variables)
GRUK.variables <- st_as_sf(GRUK.variables, coords = c("x","y"),remove=F)
# add CRS
GRUK.variables <- st_set_crs(GRUK.variables,4326)
# transform CRS to match ANO
GRUK.variables <- GRUK.variables %>%
  st_as_sf() %>%
  st_transform(crs = st_crs(ANO.geo))

### merge GRUK.variables and GRUK2021.condition
#GRUK.variables <- as.data.frame(GRUK.variables)
GRUK2021.condition <- as.data.frame(GRUK2021.condition)

head(GRUK.variables)
head(GRUK2021.condition)

## fixing site-ID in the condition-data
GRUK2021.condition$Flate_ID <- GRUK2021.condition$områdenavn
unique(as.factor(GRUK2021.condition$Flate_ID))
GRUK2021.condition$Flate_ID <- gsub("_", " ", GRUK2021.condition$Flate_ID) # replace underscore with space
unique(as.factor(GRUK2021.condition$Flate_ID))
GRUK2021.condition$Flate_ID <- sub(" .*", "", GRUK2021.condition$Flate_ID) # remove everything after space
unique(as.factor(GRUK2021.condition$Flate_ID))

#GRUK2021.condition$Flate_ID <- gsub(" ", "-", GRUK2021.condition$Flate_ID) # replace space with hyphon
#GRUK2021.condition$Flate_ID <- gsub("[^0-9\\-]", "", GRUK2021.condition$Flate_ID) # remove all non-numerics except '-'
#GRUK2021.condition$Flate_ID <- gsub("--", "-", GRUK2021.condition$Flate_ID) # remove double hyphons
#GRUK2021.condition$Flate_ID <- substr(GRUK2021.condition$Flate_ID, 1, nchar(GRUK2021.condition$Flate_ID)-1) # remove the last character ('-' for all)


colnames(GRUK.variables)
colnames(GRUK2021.condition)

GRUK.variables <- merge(x=GRUK.variables, 
                        y=GRUK2021.condition[,c("tilstandsvurdering","tilstandsgrunn","artsmangfoldvurdering","lokalitetskvalitet","Flate_ID")], 
                        by.x="Flate_ID", by.y="Flate_ID", all.x=T)



## adding information on ecosystem and condition variables to species data
GRUK.species.ind <- merge(x=GRUK.species.ind, 
                          y=GRUK.variables[,c("GlobalID","year","Flate_ID","Punkt_ID",
                                              "Total dekning % av karplanter registert","Dekning % av karplanter i feltsjikt","Dekning % av moser",
                                              "Dekning % av lav","Dekning % av strø","Dekning % av bar jord/grus/stein/berg",
                                              "Kartleggingsenhet",
                                              "Spor etter ferdsel med tunge kjøretøy (%)","Spor etter slitasje og slitasjebetinget erosjon (%)","Dekning % av nakent berg","Menneskeskapte objekter i sirkelen?",
                                              "Total dekning % av vedplanter i feltsjikt","Dekning % av busker i busksjikt","Dekning % av tresjikt","Dekning % av problemarter","Total dekning % av fremmede arter",
                                              "x","y")], 
                          by.x="ParentGlobalID", by.y="GlobalID", all.x=T)
# trimming away the points without information on NiN, species or cover
GRUK.species.ind <- GRUK.species.ind[!is.na(GRUK.species.ind$Species),]
GRUK.species.ind <- GRUK.species.ind[!is.na(GRUK.species.ind$art_dekning),]

#rm(GRUK.species)
#rm(GRUK.variables)


summary(GRUK.species.ind)
head(GRUK.species.ind)


### ASO data handling
## make ASO.geo into a spatial object
names(ASO.geo)
ASO.geo <- st_as_sf(x = ASO.geo, 
                        coords = c("x", "y"),
                        crs = "+proj=longlat +datum=WGS84 +ellps=WGS84")

colnames(ASO.geo)
colnames(ASO.geo)[c(6,7,8,10,14,16,18,23,24)] <- c("Omradenummer_flatenummer","Eng_ID","ASO_ID","NiN_grunntype",
                                                   "bruksintensitet",
                                                   "beitetrykk",
                                                   "slatteintensitet",
                                                   "tungekjoretoy",
                                                   "slitasje")


## fix NiN-variables
# remove variable code in the data
ASO.geo$bruksintensitet
ASO.geo$bruksintensitet <- gsub("7JB-BA_", "", ASO.geo$bruksintensitet) 
unique(ASO.geo$bruksintensitet)
ASO.geo$bruksintensitet <- gsub("X", "NA", ASO.geo$bruksintensitet)
unique(ASO.geo$bruksintensitet)
ASO.geo$bruksintensitet <- as.numeric(ASO.geo$bruksintensitet)
unique(ASO.geo$bruksintensitet)

ASO.geo$beitetrykk
ASO.geo$beitetrykk <- gsub("7JB-BT_", "", ASO.geo$beitetrykk) 
unique(ASO.geo$beitetrykk)
ASO.geo$beitetrykk <- gsub("X", "NA", ASO.geo$beitetrykk)
unique(ASO.geo$beitetrykk)
ASO.geo$beitetrykk <- as.numeric(ASO.geo$beitetrykk)
unique(ASO.geo$beitetrykk)

ASO.geo$slatteintensitet
ASO.geo$slatteintensitet <- gsub("7JB-SI_", "", ASO.geo$slatteintensitet) 
unique(ASO.geo$slatteintensitet)
ASO.geo$slatteintensitet <- gsub("X", "NA", ASO.geo$slatteintensitet)
unique(ASO.geo$slatteintensitet)
ASO.geo$slatteintensitet <- as.numeric(ASO.geo$slatteintensitet)
unique(ASO.geo$slatteintensitet)

ASO.geo$tungekjoretoy
ASO.geo$tungekjoretoy <- gsub("MDirPRTK_", "", ASO.geo$tungekjoretoy) 
unique(ASO.geo$tungekjoretoy)
ASO.geo$tungekjoretoy <- gsub("X", "NA", ASO.geo$tungekjoretoy)
unique(ASO.geo$tungekjoretoy)
ASO.geo$tungekjoretoy <- as.numeric(ASO.geo$tungekjoretoy)
unique(ASO.geo$tungekjoretoy)

ASO.geo$slitasje
ASO.geo$slitasje <- gsub("MDirPRSE_", "", ASO.geo$slitasje) 
unique(ASO.geo$slitasje)
ASO.geo$slitasje <- gsub("X", "NA", ASO.geo$slitasje)
unique(ASO.geo$slitasje)
ASO.geo$slitasje <- as.numeric(ASO.geo$slitasje)
unique(ASO.geo$slitasje)



## fixing variable names and issues in ASO.sp
head(as.data.frame(ASO.sp))

colnames(ASO.sp)
colnames(ASO.sp)[8] <- "art_dekning"

# fix species names
ASO.sp <- as.data.frame(ASO.sp)

ASO.sp$Species <- ASO.sp$Navn
unique(as.factor(ASO.sp$Species))
ASO.sp$Species <- sub(".*?_", "", ASO.sp$Species) # lose the Norwegian name in the front
ASO.sp$Species <- gsub("_", " ", ASO.sp$Species) # replace underscore with space
ASO.sp$Species <- str_to_title(ASO.sp$Species) # make first letter capital
ASO.sp$Species <- gsub("( .*)","\\L\\1",ASO.sp$Species,perl=TRUE) # make capital letters after hyphon to lowercase
ASO.sp$Species <- gsub("( .*)","\\L\\1",ASO.sp$Species,perl=TRUE) # make capital letters after space to lowercase
ASO.sp[,'Species'] <- word(ASO.sp[,'Species'], 1,2) # lose subspecies

unique(as.factor(ASO.sp$Species))


## merge species data with indicators
ASO.sp.ind <- merge(x=ASO.sp[,c("Species", "art_dekning", "ParentGlobalID")], 
                          y= ind.dat[,c("species","Light","Moisture","Soil_reaction_pH","Nitrogen","Phosphorus","Grazing_mowing","Soil_disturbance")],
                          by.x="Species", by.y="species", all.x=T)
summary(ASO.sp.ind)


# checking which species didn't find a match
unique(ASO.sp.ind[is.na(ASO.sp.ind$Light & 
                          is.na(ASO.sp.ind$Nitrogen)),'Species'])


# fix species name issues

ASO.sp <- ASO.sp %>% 
  mutate(Species=str_replace(Species,"Cardamine dentata", "Cardamine pratensis")) %>%
  mutate(Species=str_replace(Species,"Chamaepericlymenum suecicum", "Cornus suecica")) %>%
  mutate(Species=str_replace(Species,"Chamerion angustifolium", "Chamaenerion angustifolium")) %>%
  mutate(Species=str_replace(Species,"Cicerbita alpina", "Lactuca alpina")) %>%
  mutate(Species=str_replace(Species,"Galium album", "Galium mollugo")) %>%
  mutate(Species=str_replace(Species,"Helictotrichon pratense", "Avenula pratensis")) %>%
  mutate(Species=str_replace(Species,"Helictotrichon pubescens", "Avenula pubescens")) %>%
  mutate(Species=str_replace(Species,"Hieracium murorum", "Hieracium Vulgata")) %>%
  mutate(Species=str_replace(Species,"Hieracium vulgatum", "Hieracium umbellatum")) %>%
  mutate(Species=str_replace(Species,"Hylotelephium maximum", "Hylotelephium telephium")) %>%
  mutate(Species=str_replace(Species,"Listera cordata", "Neottia cordata")) %>%
  mutate(Species=str_replace(Species,"Listera ovata", "Neottia ovata")) %>%
  mutate(Species=str_replace(Species,"Omalotheca norvegica", "Gnaphalium norvegicum")) %>%
  mutate(Species=str_replace(Species,"Omalotheca sylvatica", "Gnaphalium sylvaticum")) %>%
  mutate(Species=str_replace(Species,"Oreopteris limbosperma", "Thelypteris limbosperma")) %>%
  mutate(Species=str_replace(Species,"Potentilla anserina", "Argentina anserina")) %>%
  mutate(Species=str_replace(Species,"Rosa dumalis", "Rosa vosagiaca")) %>%
  mutate(Species=str_replace(Species,"Rubus fruticosus", "Rubus plicatus")) %>%
  mutate(Species=str_replace(Species,"Rumex alpestris", "Rumex acetosa"))

## merge species data with indicators
ASO.sp.ind <- merge(x=ASO.sp[,c("Species", "art_dekning", "ParentGlobalID")], 
                    y= ind.dat[,c("species","Light","Moisture","Soil_reaction_pH","Nitrogen","Phosphorus","Grazing_mowing","Soil_disturbance")],
                    by.x="Species", by.y="species", all.x=T)
summary(ASO.sp.ind)
# checking which species didn't find a match
unique(ASO.sp.ind[is.na(ASO.sp.ind$Light & 
                          is.na(ASO.sp.ind$Nitrogen)),'Species'])

# the rest can be omitted


## adding information on ecosystem and condition variables to species data
names(ASO.sp.ind)
names(ASO.geo)
ASO.sp.ind <- merge(x=ASO.sp.ind, 
                    y=ASO.geo[,c("GlobalID","Omradenummer_flatenummer","Eng_ID","ASO_ID","NiN_grunntype")], 
                    by.x="ParentGlobalID", by.y="GlobalID", all.x=T)
# trimming away the points without information on NiN, species or cover
ASO.sp.ind <- ASO.sp.ind[!is.na(ASO.sp.ind$NiN_grunntype),]
ASO.sp.ind <- ASO.sp.ind[!is.na(ASO.sp.ind$Species),]
ASO.sp.ind <- ASO.sp.ind[!is.na(ASO.sp.ind$art_dekning),]

#rm(ASO.sp)
#rm(ASO.geo)


summary(ASO.sp.ind)
head(ASO.sp.ind)


#### 3Q data - data handling




#### reference data - data handling

### generalized species lists for forest, mountain, wetland, and semi-natural ecosystems
str(Eco_State)

# species
Eco_State$Concept_Data$Species$Species_List$species
# environments
t(Eco_State$Concept_Data$Env$Env_Data)
# abundances
t(Eco_State$Concept_Data$Species$Species_Data)

## transposing abundance data
NiN.sp <- t(Eco_State$Concept_Data$Species$Species_Data)
NiN.sp <- as.data.frame(NiN.sp)
NiN.sp$sp <- as.factor(as.vector(Eco_State$Concept_Data$Species$Species_List$species))
# only genus and species name
NiN.sp$sp <- word(NiN.sp$sp, 1,2)
NiN.sp$spgr <- as.factor(as.vector(Eco_State$Concept_Data$Species$Species_List$art.code))
# if relevant, trimming to desired species groups (for forests e.g. removing trees)
#NiN.sp <- NiN.sp[NiN.sp$spgr!="a1a",]

## environment data
NiN.env <- Eco_State$Concept_Data$Env$Env_Data

## merging with indicator values
NiN.sp.ind <- merge(NiN.sp,ind.dat, by.x="sp", by.y="species", all.x=T)
summary(NiN.sp.ind)

NiN.sp.ind[NiN.sp.ind==999] <- NA

## checking which species didn't find a match
unique(NiN.sp.ind[is.na(NiN.sp.ind$Moisture) & NiN.sp.ind$spgr %in% list("a1a","a1b","a1c"),'sp'])

## fix species name issues
#ind.dat <- ind.dat %>% 
#  mutate(species=str_replace(species,"Aconitum lycoctonum", "Aconitum septentrionale")) %>% 
#  mutate(species=str_replace(species,"Carex simpliciuscula", "Kobresia simpliciuscula")) %>%
#  mutate(species=str_replace(species,"Carex myosuroides", "Kobresia myosuroides")) %>%
#  mutate(species=str_replace(species,"Clinopodium acinos", "Acinos arvensis")) %>%
#  mutate(species=str_replace(species,"Artemisia rupestris", "Artemisia norvegica")) %>%
#  mutate(species=str_replace(species,"Cherleria biflora", "Minuartia biflora"))

NiN.sp <- NiN.sp %>% 
  mutate(sp=str_replace(sp,"Aconitum lycoctonum", "Aconitum septentrionale")) %>% 
  mutate(sp=str_replace(sp,"Anagallis arvensis", "Lysimachia arvensis")) %>% 
  mutate(sp=str_replace(sp,"Anagallis minima", "Lysimachia minima")) %>% 
  mutate(sp=str_replace(sp,"Arctous alpinus", "Arctous alpina")) %>%
  mutate(sp=str_replace(sp,"Betula tortuosa", "Betula pubescens")) %>%
  mutate(sp=str_replace(sp,"Blysmopsis rufa", "Blysmus rufus")) %>%
  mutate(sp=str_replace(sp,"Chamerion angustifolium", "Chamaenerion angustifolium")) %>%
  mutate(sp=str_replace(sp,"Cardamine nymanii", "Cardamine pratensis")) %>%
  mutate(sp=str_replace(sp,"Carex adelostoma", "Carex buxbaumii")) %>%
  mutate(sp=str_replace(sp,"Carex leersii", "Carex echinata")) %>%
  mutate(sp=str_replace(sp,"Carex paupercula", "Carex magellanica")) %>%
  mutate(sp=str_replace(sp,"Carex simpliciuscula", "Kobresia simpliciuscula")) %>%
  mutate(sp=str_replace(sp,"Carex _vacillans", "Carex vacillans")) %>%
  mutate(sp=str_replace(sp,"Carex viridula", "Carex flava")) %>%
  mutate(sp=str_replace(sp,"Chamaepericlymenum suecicum", "Cornus suecia")) %>%
  mutate(sp=str_replace(sp,"Cornus suecia", "Cornus suecica")) %>%
  mutate(sp=str_replace(sp,"Cicerbita alpina", "Lactuca alpina")) %>%
  mutate(sp=str_replace(sp,"Dactylorhiza fuchsii", "Dactylorhiza maculata")) %>%
  mutate(sp=str_replace(sp,"Dactylorhiza sphagnicola", "Dactylorhiza majalis")) %>%
  mutate(sp=str_replace(sp,"Diphasiastrum alpinum", "Lycopodium alpinum")) %>%
  mutate(sp=str_replace(sp,"Diphasiastrum complanatum", "Lycopodium complanatum")) %>%
  mutate(sp=str_replace(sp,"Elymus alaskanus", "Elymus kronokensis")) %>%
  mutate(sp=str_replace(sp,"Empetrum hermaphroditum", "Empetrum nigrum")) %>%
  mutate(sp=str_replace(sp,"Erigeron acer", "Erigeron acris")) %>%
  mutate(sp=str_replace(sp,"Erigeron eriocephalus", "Erigeron uniflorus")) %>%
  mutate(sp=str_replace(sp,"Festuca altissima", "Drymochloa sylvatica")) %>%
  mutate(sp=str_replace(sp,"Festuca prolifera", "Festuca rubra")) %>%
  mutate(sp=str_replace(sp,"Galium album", "Galium mollugo")) %>%
  mutate(sp=str_replace(sp,"Galium elongatum", "Galium palustre")) %>%
  mutate(sp=str_replace(sp,"Glaux maritima", "Lysimachia maritima")) %>%
  mutate(sp=str_replace(sp,"Helictotrichon pratense", "Avenula pratensis")) %>%
  mutate(sp=str_replace(sp,"Helictotrichon pubescens", "Avenula pubescens")) %>%
  mutate(sp=str_replace(sp,"Hieracium alpina", "Hieracium Alpina")) %>%
  mutate(sp=str_replace(sp,"Hieracium alpinum", "Hieracium Alpina")) %>%
  mutate(sp=str_replace(sp,"Hieracium aurantiacum", "Pilosella aurantiaca")) %>%
  mutate(sp=str_replace(sp,"Hieracium dovrense", "Hieracium Alpestria")) %>%
  mutate(sp=str_replace(sp,"Hieracium hieracium", "Hieracium Hieracium")) %>%
  mutate(sp=str_replace(sp,"Hieracium hieracioides", "Hieracium umbellatum")) %>%
  mutate(sp=str_replace(sp,"Hieracium lactucella", "Pilosella lactucella")) %>%
  mutate(sp=str_replace(sp,"Hieracium murorum", "Hieracium Vulgata")) %>%
  mutate(sp=str_replace(sp,"Hieracium oreadea", "Hieracium Oreadea")) %>%
  mutate(sp=str_replace(sp,"Hieracium prenanthoidea", "Hieracium Prenanthoidea")) %>%
  mutate(sp=str_replace(sp,"Hieracium vulgata", "Hieracium Vulgata")) %>%
  mutate(sp=str_replace(sp,"Hieracium pilosella", "Pilosella officinarum")) %>%
  mutate(sp=str_replace(sp,"Hieracium vulgatum", "Hieracium umbellatum")) %>%
  mutate(sp=str_replace(sp,"Hierochloã« alpina", "Hierochloë alpina")) %>%
  mutate(sp=str_replace(sp,"Hierochloã« hirta", "Hierochloë hirta")) %>%
  mutate(sp=str_replace(sp,"Hierochloã« odorata", "Hierochloë odorata")) %>%
  mutate(sp=str_replace(sp,"Huperzia appressa", "Huperzia selago")) %>%
  mutate(sp=str_replace(sp,"Hylotelephium maximum", "Hylotelephium telephium")) %>%
  mutate(sp=str_replace(sp,"Lappula myosotis", "Lappula squarrosa")) %>%
  mutate(sp=str_replace(sp,"Lepidotheca suaveolens", "Matricaria discoidea")) %>%
  mutate(sp=str_replace(sp,"Listera cordata", "Neottia cordata")) %>%
  mutate(sp=str_replace(sp,"Listera ovata", "Neottia ovata")) %>%
  mutate(sp=str_replace(sp,"Leontodon autumnalis", "Scorzoneroides autumnalis")) %>%
  mutate(sp=str_replace(sp,"Loiseleuria procumbens", "Kalmia procumbens")) %>%
  mutate(sp=str_replace(sp,"Logfia arvensis", "Filago arvensis")) %>%
  mutate(sp=str_replace(sp,"Mentha _verticillata", "Mentha verticillata")) %>%
  mutate(sp=str_replace(sp,"Minuartia rubella", "Sabulina rubella")) %>%
  mutate(sp=str_replace(sp,"Minuartia stricta", "Sabulina stricta")) %>%
  mutate(sp=str_replace(sp,"Mycelis muralis", "Lactuca muralis")) %>%
  mutate(sp=str_replace(sp,"Omalotheca supina", "Gnaphalium supinum")) %>%
  mutate(sp=str_replace(sp,"Omalotheca norvegica", "Gnaphalium norvegicum")) %>%
  mutate(sp=str_replace(sp,"Omalotheca sylvatica", "Gnaphalium sylvaticum")) %>%
  mutate(sp=str_replace(sp,"Ononis arvensis", "Ononis spinosa")) %>%
  mutate(sp=str_replace(sp,"Oreopteris limbosperma", "Thelypteris limbosperma")) %>%
  mutate(sp=str_replace(sp,"Oxycoccus microcarpus", "Vaccinium microcarpum")) %>%
  mutate(sp=str_replace(sp,"Oxycoccus palustris", "Vaccinium oxycoccos")) %>%
  mutate(sp=str_replace(sp,"Phalaris minor", "Phalaris arundinacea")) %>%
  mutate(sp=str_replace(sp,"Phalaroides arundinacea", "Phalaris arundinacea")) %>%
  mutate(sp=str_replace(sp,"Pinus unicinata", "Pinus mugo")) %>%
  mutate(sp=str_replace(sp,"Platanthera montana", "Platanthera chlorantha")) %>%
  mutate(sp=str_replace(sp,"Poa alpigena", "Poa pratensis")) %>%
  mutate(sp=str_replace(sp,"Poa angustifolia", "Poa pratensis")) %>%
  mutate(sp=str_replace(sp,"Poa laxa", "Poa flexuosa")) %>%
  mutate(sp=str_replace(sp,"Poa _herjedalica", "Poa herjedalica")) %>%
  mutate(sp=str_replace(sp,"Poa _jemtlandica", "Poa jemtlandica")) %>%
  mutate(sp=str_replace(sp,"Poa jemtlandica", "Poa alpina")) %>%
  mutate(sp=str_replace(sp,"Poa lindebergii", "Poa arctica")) %>%
  mutate(sp=str_replace(sp,"Potentilla anserina", "Argentina anserina")) %>%
  mutate(sp=str_replace(sp,"Pyrola grandiflora", "Pyrola rotundifolia")) %>%
  mutate(sp=str_replace(sp,"Rhamnus catharticus", "Rhamnus cathartica")) %>%
  mutate(sp=str_replace(sp,"Rumex alpestris", "Rumex acetosa")) %>%
  mutate(sp=str_replace(sp,"Salix _fragilis", "Salix fragilis")) %>%
  mutate(sp=str_replace(sp,"Saxifraga _opdalensis", "Saxifraga opdalensis")) %>%
  mutate(sp=str_replace(sp,"Sorbus hybrida", "Hedlundia hybrida")) %>%
  mutate(sp=str_replace(sp,"Spergularia salina", "Spergularia marina")) %>%
  mutate(sp=str_replace(sp,"Syringa emodi", "Syringa vulgaris")) %>%
  mutate(sp=str_replace(sp,"Taraxacum crocea", "Taraxacum officinale")) %>%
  mutate(sp=str_replace(sp,"Taraxacum croceum", "Taraxacum officinale")) %>%
  mutate(sp=str_replace(sp,"Taraxacum erythrospermum", "Taraxacum officinale")) %>%
  mutate(sp=str_replace(sp,"Taraxacum hamatum", "Taraxacum officinale")) %>%
  mutate(sp=str_replace(sp,"Trientalis europaea", "Lysimachia europaea")) %>%
  mutate(sp=str_replace(sp,"Trifolium pallidum", "Trifolium pratense")) %>%
  mutate(sp=str_replace(sp,"Vicia orobus", "Vicia cassubica"))


## merge species data with indicators
NiN.sp.ind <- merge(NiN.sp,ind.dat, by.x="sp", by.y="species", all.x=T)
summary(NiN.sp.ind)

NiN.sp.ind[NiN.sp.ind==999] <- NA

# checking which species didn't find a match
unique(NiN.sp.ind[is.na(NiN.sp.ind$Moisture) & NiN.sp.ind$spgr %in% list("a1a","a1b","a1c"),'sp'])
# ok now

## matching with NiN ecosystem types - for wetlands, mountains, and forests
# NB! beware of rogue spaces in the 'Nature_type' & 'Sub_Type' variables, e.g. "Spring_Forest " & "Mountain "
NiN.wet_mount_forest_seminat <- NiN.sp.ind[,c("sp",paste(NiN.env[NiN.env$Nature_Type %in% c("Mire", "Forest", "Mountain ", "Semi_Natural ","Coastal_Heath"),"ID"]),colnames(ind.dat)[c(3:5,16,20:24,26:27)])]   # Grime's C, Grime's S, Grime's R, Heat_requirement, Light, Moisture, Soil_reaction_pH, Nitrogen, Phosphorus, Grazing_mowing, Soil_disturbance
NiN.wet_mount_forest_seminat[1,]
names(NiN.wet_mount_forest_seminat)

cbind(colnames(NiN.wet_mount_forest_seminat),
      c("",
        
        'T34-C1',
        'T34-C2a','T34-C2b','T34-C2c',
        '',
        'T34-C3',
        'T34-C4a','T34-C4b','T34-C4c','T34-C4d',
        'T34-C5a','T34-C5b','T34-C5c',
        'T34-C6a','T34-C6b','T34-C6c',
        '',
        
        'T4-C1','T4-C5','T4-C9','T4-C13',
        rep("",4),
        'T4-C2','T4-C6','T4-C10','T4-C14',
        'T4-C3','T4-C7','T4-C11','T4-C15',
        'T4-C4','T4-C8','T4-C12','T4-C16',
        'T4-C17','T4-C18a','T4-C19a','T4-C18b',
        'T4-C19b','T4-C20',
        rep("",16),
        'T30-C1','T30-C2','T30-C3',
        rep("",3),
        'T30-C4',
        rep("",8),
        
        'T14-C1','T14-C2','T3-C3C6','T3-C9C12',
        'T3-C2C5','T3-C8C11','T3-C1a','T3-C1b',
        'T3-C4','T3-C7','T3-C10','T3-C13',
        'T3-C14','T7-C1','T7-C2','T7-C3',
        'T7-C6','T7-C8',
        "",
        'T7-C12','T7-C13C14','T7-C4','T7-C7C9','T7-C5','T7-C10',
        rep("",8),
        'T22-C1C3a',"",'T22-C1C3b',"",'T22-C2C4',
        
        'V3-C1a','V3-C1b','V3-C1c','V3-C1d','V3-C1e',
        'V1-C1a','V1-C1b','V1-C1c','V1-C1d','V1-C1e',
        'V1-C2a','V1-C2b','V1-C2c','V1-C2d',
        'V1-C3a','V1-C3b','V1-C3c','V1-C3d',
        'V1-C4a','V1-C4b','V1-C4c','V1-C4d',
        'V1-C4e','V1-C4f','V1-C4g','V1-C4h',
        'V3-C2','V1-C5',
        'V1-C6a','V1-C6b',
        'V1-C7a','V1-C7b',
        'V1-C8a','V1-C8b',
        'V2-C1a','V2-C1b',
        'V2-C2a','V2-C2b',
        'V2-C3a','V2-C3b',
        "V4-C2","V4-C3",
        "","",
        'V8-C1','V8-C2','V8-C3',
        rep("",10),
        
        rep('',7),
        'T32-C1C2','T32-C3C4',
        'T32-C5C20a',
        'T32-C7C8',
        'T32-C5C20b',
        'T32-C9a',
        'T32-C9b',
        'T32-C15',
        'T32-C21C6a',
        'T32-C21C6b',
        'T32-C10a',
        'T32-C10b',
        'T32-C16',
        'T41a','T41b',
        'T45-C1C2','T45-C3',
        'V10-C1C2','V10-C3',
        
        rep("",11) # indicators
      )
)

NiN.wet_mount_forest_seminat <- NiN.wet_mount_forest_seminat[,c(1,2:5,7:17,19:22,27:44,61:63,67,
                                                                76:93,95:100,109,111,113,
                                                                114:155,158:160,
                                                                178:196,197:207)]
colnames(NiN.wet_mount_forest_seminat)[2:133] <- c(
                                                  'T34-C1',
                                                  'T34-C2a','T34-C2b','T34-C2c',
                                                  'T34-C3',
                                                  'T34-C4a','T34-C4b','T34-C4c','T34-C4d',
                                                  'T34-C5a','T34-C5b','T34-C5c',
                                                  'T34-C6a','T34-C6b','T34-C6c',
                                            
                                                  'T4-C1','T4-C5','T4-C9','T4-C13',
                                                  'T4-C2','T4-C6','T4-C10','T4-C14',
                                                  'T4-C3','T4-C7','T4-C11','T4-C15',
                                                  'T4-C4','T4-C8','T4-C12','T4-C16',
                                                  'T4-C17','T4-C18a','T4-C19a','T4-C18b',
                                                  'T4-C19b','T4-C20',
                                                  'T30-C1','T30-C2','T30-C3',
                                                  'T30-C4',
                                          
                                                  'T14-C1','T14-C2','T3-C3C6','T3-C9C12',
                                                  'T3-C2C5','T3-C8C11','T3-C1a','T3-C1b',
                                                  'T3-C4','T3-C7','T3-C10','T3-C13',
                                                  'T3-C14','T7-C1','T7-C2','T7-C3',
                                                  'T7-C6','T7-C8',
                                                  'T7-C12','T7-C13C14','T7-C4','T7-C7C9','T7-C5','T7-C10',
                                                  'T22-C1C3a','T22-C1C3b','T22-C2C4',
                                                  
                                                  'V3-C1a','V3-C1b','V3-C1c','V3-C1d','V3-C1e',
                                                  'V1-C1a','V1-C1b','V1-C1c','V1-C1d','V1-C1e',
                                                  'V1-C2a','V1-C2b','V1-C2c','V1-C2d',
                                                  'V1-C3a','V1-C3b','V1-C3c','V1-C3d',
                                                  'V1-C4a','V1-C4b','V1-C4c','V1-C4d',
                                                  'V1-C4e','V1-C4f','V1-C4g','V1-C4h',
                                                  'V3-C2','V1-C5',
                                                  'V1-C6a','V1-C6b',
                                                  'V1-C7a','V1-C7b',
                                                  'V1-C8a','V1-C8b',
                                                  'V2-C1a','V2-C1b',
                                                  'V2-C2a','V2-C2b',
                                                  'V2-C3a','V2-C3b',
                                                  "V4-C2","V4-C3",
                                                  'V8-C1','V8-C2','V8-C3',
                                                  'T32-C1C2','T32-C3C4',
                                                  
                                                  'T32-C5C20a',
                                                  'T32-C7C8',
                                                  'T32-C5C20b',
                                                  'T32-C9a',
                                                  'T32-C9b',
                                                  'T32-C15',
                                                  'T32-C21C6a',
                                                  'T32-C21C6b',
                                                  'T32-C10a',
                                                  'T32-C10b',
                                                  'T32-C16',
                                                  'T41a','T41b',
                                                  'T45-C1C2','T45-C3',
                                                  'V10-C1C2','V10-C3'
)
head(NiN.wet_mount_forest_seminat)


# translating the abundance classes into %-cover
coverscale <- data.frame(orig=0:6,
                         cov=c(0,1/32,1/8,3/8,0.6,4/5,1)
)

NiN.wet_mount_forest_seminat.cov <- NiN.wet_mount_forest_seminat
colnames(NiN.wet_mount_forest_seminat.cov)
for (i in 2:133) {
  NiN.wet_mount_forest_seminat.cov[,i] <- coverscale[,2][ match(NiN.wet_mount_forest_seminat[,i], 0:6 ) ]
}

NiN.wet_mount_forest_seminat.cov$sp <- as.factor(NiN.wet_mount_forest_seminat.cov$sp)


### generalized species lists for naturally open systems below the tree line
head(natopen_NiN_ref)
head(natopen_NiN_ref_spInfo)

colnames(natopen_NiN_ref)[1] <- "sp"
head(natopen_NiN_ref)

natopen_NiN_ref <- merge(natopen_NiN_ref,natopen_NiN_ref_spInfo[,c(1,4)], by.x="sp", by.y="ScientificName", all.x=T)
unique(natopen_NiN_ref[is.na(natopen_NiN_ref$Phylum),'sp']) # Pucinella does not exist in ind.dat, so we don't care
# we're only interested in vascular plants and ferns, which we have indicators on
unique(natopen_NiN_ref$Phylum)
natopen_NiN_ref <- natopen_NiN_ref %>%
  filter(Phylum %in% c("Magnoliophyta","Pteridophyta"))
unique(natopen_NiN_ref$Phylum)



natopen_NiN_ref$sp
# only genus and species name
natopen_NiN_ref$sp.orig <- natopen_NiN_ref$sp
natopen_NiN_ref$sp <- word(natopen_NiN_ref$sp, 1,2)
natopen_NiN_ref <- natopen_NiN_ref[!is.na(natopen_NiN_ref$sp),]
# merging with indicator values
NiN.natopen <- merge(natopen_NiN_ref,ind.dat[,c(1,3:5,20,23,27)], by.x="sp", by.y="species", all.x=T)
head(NiN.natopen)
summary(NiN.natopen)



NiN.natopen
unique(NiN.natopen$sp)
#NiN.sp$spgr <- as.factor(as.vector(Eco_State$Concept_Data$Species$Species_List$art.code))

# checking which species didn't find a match
unique(NiN.natopen[is.na(NiN.natopen$Light) & is.na(NiN.natopen$Nitrogen) & is.na(NiN.natopen$RR),'sp'])

# fix species name issues
natopen_NiN_ref <- natopen_NiN_ref %>% 
  mutate(sp=str_replace(sp,"Cirsium acaulon", "Cirsium acaule")) %>%
  mutate(sp=str_replace(sp,"Hylotelephium maximum", "Hylotelephium telephium"))

ind.dat[2556,'species'] <- "Saxifraga osloënsis"
ind.dat[17,'species'] <- "Hierochloë odorata"
ind.dat[9,'species'] <- "Hippophaë rhamnoides"


# merging with indicator values
NiN.natopen <- merge(natopen_NiN_ref,ind.dat[,c(1,3:5,20,23,27)], by.x="sp", by.y="species", all.x=T)
# checking which species didn't find a match
unique(NiN.natopen[is.na(NiN.natopen$Light) & is.na(NiN.natopen$Nitrogen) & is.na(NiN.natopen$RR),'sp'])
# ok now


# translating the abundance classes into %-cover
coverscale <- data.frame(orig=0:6,
                         cov=c(0, 1/32 ,1/8, 3/8, 0.6, 4/5, 1)
)

NiN.natopen.cov <- NiN.natopen
colnames(NiN.natopen.cov)
for (i in 2:71) {
  NiN.natopen.cov[,i] <- coverscale[,2][ match(NiN.natopen[,i], 0:6 ) ]
}

summary(NiN.natopen)
summary(NiN.natopen.cov)

```


This leaves us with the monitoring data including plant indicators (ANO.sp.ind, GRUK.species.ind, ASO.sp.ind) and the reference data including plant indicators (NiN.wet_mount_forest_seminat.cov, NiN.natopen.cov):

<!-- Print head of data set with horizontal scrolling -->
```{r ano-sp-tab, echo=F}
head(ANO.sp.ind) %>%
  kable("html",caption = "ANO species occurence data set with attached plant trait data.") %>% 
  kable_styling("striped") %>% scroll_box(width = "100%")
```

```{r ano-sp-tab, echo=F}
head(GRUK.species.ind) %>%
  kable("html",caption = "GRUK species occurence data set with attached plant trait data.") %>% 
  kable_styling("striped") %>% scroll_box(width = "100%")
```


```{r aso-sp-tab, echo=F}
head(ASO.sp.ind) %>%
  kable("html",caption = "ASO species occurence data set with attached plant trait data.") %>% 
  kable_styling("striped") %>% scroll_box(width = "100%")
```




```{r wetland_mountain_forest_seminatural-ref-data-tab, echo=FALSE}
head(NiN.wet_mount_forest_seminat.cov) %>% 
  kable("html", caption = "Reference data set for wetland, mountain, forest, and semi-natural ecosystems") %>% 
  kable_styling("striped") %>% scroll_box(width = "100%")
```

```{r naturally open-ref-data-tab, echo=FALSE}
head(NiN.natopen.cov) %>% 
  kable("html", caption = "Reference data set for naturally open ecosystems below the treeline") %>% 
  kable_styling("striped") %>% scroll_box(width = "100%")
```


<br />

For each ecosystem type with a NiN species list, we can calculate a community weighted mean (CWM) for the relevant functional plant indicators, or the cumulative density curve (Heat requirement indicator in mountain ecosystems).
In order to get distributions of these metrics rather than one single value (for comparison with the empirical testing data) the NiN lists can be bootstrapped. For the heat requirement indicator the bootstrapped cumulative density curves for heat requirement 3 and higher are subtracted from the original cumulative density curve and the result summed, i.e. providing a distribution of deviation values.

<br />

##### Bootstrap functions for frequency abundance and cumulative density
- function to calculate community weighted means (indBoot.freq() ) or cumulative density (indBoot.HeatOverhang() ) of selected indicator values (ind)
- for species lists (sp) with given abundances in percent (or on a scale from 0 to 1) in one or more 'sites' (abun)
- with a given number of iterations (iter),
- with species given a certain minimum abundance occurring in all bootstraps (obl), and
- with a given re-sampling ratio of the original species list (rat)
- in every bootstrap iteration the abundance of the sampled species can be randomly changed by a limited amount if wished by introducing a re-sampling of abundance values from adjacent abundance steps with a certain probability (var.abun)

```{r, echo = T}
indBoot.freq <- function(sp,abun,ind,iter,obl,rat=2/3,var.abun=F) {
  
  ind.b <- matrix(nrow=iter,ncol=length(colnames(abun)))
  colnames(ind.b) <- colnames(abun)
  ind.b <- as.data.frame(ind.b)  
  
  ind <- as.data.frame(ind)
  ind.list <- as.list(1:length(colnames(ind)))
  names(ind.list) <- colnames(ind)
  
  for (k in 1:length(colnames(ind)) ) {
    ind.list[[k]] <- ind.b }
  
  for (j in 1:length(colnames(abun)) ) {
    
    dat <- cbind(sp,abun[,j],ind)
    dat <- dat[dat[,2]>0,]            # only species that are present in the ecosystem
    dat <- dat[!is.na(dat[,3]),]      # only species that have indicator values
    
    for (i in 1:iter) {
      
      speciesSample <- sample(dat$sp[dat[,2] < obl], size=round( (length(dat$sp)-length(dat$sp[dat[,2]>=obl])) *rat,0), replace=F)  
      dat.b <- rbind(dat[dat[,2] >= obl,],
                     dat[match(speciesSample,dat$sp),]
      )
      
      if (var.abun==T) {
        for (m in 1:nrow(coverscale[-1,]) ) {
          xxx <- dat.b[dat.b[,2]==coverscale[-1,][m,2],2]
          if ( m==1 ) { dat.b[dat.b[,2]==coverscale[-1,][m,2],2] <- sample( c(0.01,coverscale[2:7,2]), prob = c(0.5, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0) ,size=length(xxx),replace=T) }
          if ( m==2 ) { dat.b[dat.b[,2]==coverscale[-1,][m,2],2] <- sample( c(0.01,coverscale[2:7,2]), prob = c(0.2, 0.3, 0.5, 0.0, 0.0, 0.0, 0.0) ,size=length(xxx),replace=T) }
          if ( m==3 ) { dat.b[dat.b[,2]==coverscale[-1,][m,2],2] <- sample( c(0.01,coverscale[2:7,2]), prob = c(0.0, 0.2, 0.3, 0.5, 0.0, 0.0, 0.0) ,size=length(xxx),replace=T) }
          if ( m==4 ) { dat.b[dat.b[,2]==coverscale[-1,][m,2],2] <- sample( c(0.01,coverscale[2:7,2]), prob = c(0.0, 0.0, 0.2, 0.3, 0.5, 0.0, 0.0) ,size=length(xxx),replace=T) }
          if ( m==5 ) { dat.b[dat.b[,2]==coverscale[-1,][m,2],2] <- sample( c(0.01,coverscale[2:7,2]), prob = c(0.0, 0.0, 0.0, 0.2, 0.3, 0.5, 0.0) ,size=length(xxx),replace=T) }
          if ( m==6 ) { dat.b[dat.b[,2]==coverscale[-1,][m,2],2] <- sample( c(0.01,coverscale[2:7,2]), prob = c(0.0, 0.0, 0.0, 0.0, 0.2, 0.3, 0.5) ,size=length(xxx),replace=T) }
        }
        dat.b[!is.na(dat.b[,2]) & dat.b[,2]<=(0),2] <- 0.01
        dat.b[!is.na(dat.b[,2]) & dat.b[,2]>1,2] <- 1
      }
      
      for (k in 1:length(colnames(ind))) {
        
        if ( nrow(dat.b)>2 ) {
          
          ind.b <- sum(dat.b[!is.na(dat.b[,2+k]),2] * dat.b[!is.na(dat.b[,2+k]),2+k] , na.rm=T) / sum(dat.b[!is.na(dat.b[,2+k]),2],na.rm=T)
          ind.list[[k]][i,j] <- ind.b
          
        } else {ind.list[[k]][i,j] <- NA}
        
      }
 
#      print(paste(i,"",j)) 
    }
    
  }
  return(ind.list)
}


indBoot.HeatOverhang <- function(sp,abun,ind, iter,obl,rat,var.abun=F) {
  
  # data frame to hold the results
  heat.ind.b <- matrix(nrow=iter,ncol=length(colnames(abun)))
  colnames(heat.ind.b) <- colnames(abun)
  heat.ind.b <- as.data.frame(heat.ind.b)  
  
  # looping through the ecosystem types  
  for (j in 1:length(colnames(abun))) {
    
    # creating the species data for the respective ecosystem type
    dat <- cbind(sp,ind,abun[,j])
    dat <- dat[dat[,3]>0,]            # only species that are present in the ecoystem
    dat <- dat[!is.na(dat[,2]),]      # only species that have Heat requirement values
    dat <- as.data.frame(dat)
    colnames(dat) <- c('sp','ind','abun')
    
    # bootstrapping, can specify to always keep certain abundance classes (obl) and how many species to sample (rat)
    if ( nrow(dat)>2 ) {
    
      for (i in 1:iter) {
        
        speciesSample <- sample(dat$sp[dat[,3] < obl], size=round( (length(dat$sp)-length(dat$sp[dat[,3] >= (obl)])) *rat,0), replace=F)  
        dat.b <- rbind(dat[dat[,3] >= (obl),],
                       dat[match(speciesSample,dat$sp),]
        )
        
              if (var.abun==T) {
        for (m in 1:nrow(coverscale[-1,]) ) {
          xxx <- dat.b[dat.b[,3]==coverscale[-1,][m,2],2]
          if ( m==1 ) { dat.b[dat.b[,3]==coverscale[-1,][m,2],3] <- sample( c(0.01,coverscale[2:7,2]), prob = c(0.5, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0) ,size=length(xxx),replace=T) }
          if ( m==2 ) { dat.b[dat.b[,3]==coverscale[-1,][m,2],3] <- sample( c(0.01,coverscale[2:7,2]), prob = c(0.2, 0.3, 0.5, 0.0, 0.0, 0.0, 0.0) ,size=length(xxx),replace=T) }
          if ( m==3 ) { dat.b[dat.b[,3]==coverscale[-1,][m,2],3] <- sample( c(0.01,coverscale[2:7,2]), prob = c(0.0, 0.2, 0.3, 0.5, 0.0, 0.0, 0.0) ,size=length(xxx),replace=T) }
          if ( m==4 ) { dat.b[dat.b[,3]==coverscale[-1,][m,2],3] <- sample( c(0.01,coverscale[2:7,2]), prob = c(0.0, 0.0, 0.2, 0.3, 0.5, 0.0, 0.0) ,size=length(xxx),replace=T) }
          if ( m==5 ) { dat.b[dat.b[,3]==coverscale[-1,][m,2],3] <- sample( c(0.01,coverscale[2:7,2]), prob = c(0.0, 0.0, 0.0, 0.2, 0.3, 0.5, 0.0) ,size=length(xxx),replace=T) }
          if ( m==6 ) { dat.b[dat.b[,3]==coverscale[-1,][m,2],3] <- sample( c(0.01,coverscale[2:7,2]), prob = c(0.0, 0.0, 0.0, 0.0, 0.2, 0.3, 0.5) ,size=length(xxx),replace=T) }
        }
        dat.b[!is.na(dat.b[,3]) & dat.b[,3]<=(0),2] <- 0.01
        dat.b[!is.na(dat.b[,3]) & dat.b[,3]>1,2] <- 1
      }
        
        dat.b[,2] <- as.numeric(dat.b[,2])
        dat.b[,3] <- as.numeric(dat.b[,3])
  
        # calculating the cumulative cover of species with a with heat requirement 3 and above
        if ( nrow(dat.b)>0 ) {
          
          df <- dat.b[,c(2,3)]
          df[,2] <- df[,2]/sum(df[,2]) # scaling to total cover of 100%
          
          abun.cumsums.b <- abun.sums.b <- data.frame(ind=rev(1:13),cumsum=NA)
  
          df <- df %>% add_row(ind=1:13, abun=rep(0,13))
          abun.sums.b[,2] <- rev(with(df,tapply(abun,ind,sum)))
          abun.cumsums.b[,2] <- cumsum(abun.sums.b[,2])
          heat.ind.b[i,j] <- abun.cumsums.b[11,2]
  
        } else {heat.ind.b[i,j] <- NA}
        
  #      print(paste(i,"",j)) 
      }
     
    }
     
  }
  return(heat.ind.b)
}
```

```{r}
colnames(NiN.wet_mount_forest_seminat.cov)
# 1st column is the species
# 2nd-133rd column is the abundances of sp in different ecosystem types
# 134th-144th column is the indicator values of the respective species
# 137th column is the indicator value for Heat_requirement
# we choose 1000 iterations
# species with abundance 0.8 or more (dominant species) must be included in each sample
# each sample re-samples 1/3 of the number of species
# the abundance of the re-sampled species may vary (see bootstrap function for details)

colnames(NiN.natopen.cov)
# 1st column is the species
# 6th-71st column is the abundances of sp in different ecosystem types
# 74th-79th column is the indicator values of the respective species
# we choose 1000 iterations
# species with abundance 0.8 (dominant species) must be included in each sample)
# each sample re-samples 1/3 of the number of species
# the abundance of the re-sampled species may vary (see bootstrap function for details)

```

Running the bootstraps:
```{r, eval = F}
wet_mount_forest_seminat.ref.cov <- indBoot.freq(sp=NiN.wet_mount_forest_seminat.cov[,1],abun=NiN.wet_mount_forest_seminat.cov[,2:133],ind=NiN.wet_mount_forest_seminat.cov[,134:144],
                          iter=1000,obl=0.8,rat=1/3,var.abun=T)

wet_mount_forest_seminat.ref.cov[["Heat_requirement"]] <- indBoot.HeatOverhang(sp=NiN.wet_mount_forest_seminat.cov[,1],
                                   abun=NiN.wet_mount_forest_seminat.cov[,43:69],
                                   ind=NiN.wet_mount_forest_seminat.cov[,137],
                                   iter=1000,obl=0.8,rat=1/3,var.abun=T)

# fixing NaNs
for (i in 1:length(wet_mount_forest_seminat.ref.cov) ) {
  for (j in 1:ncol(wet_mount_forest_seminat.ref.cov[[i]]) ) {
    v <- wet_mount_forest_seminat.ref.cov[[i]][,j]
    v[is.nan(v)] <- NA
    wet_mount_forest_seminat.ref.cov[[i]][,j] <- v
  }
}

#saveRDS(wet_mount_forest_seminat.ref.cov, "C:/Users/joachim.topper/OneDrive - NINA/work/R projects/github/ecRxiv_functional-plant-indicators/indicators/NO_FUNC_001-004/data/cache/wet_mount_forest_seminat.ref.cov.RDS")


natopen.ref.cov <- indBoot.freq(sp=NiN.natopen.cov[,1],abun=NiN.natopen.cov[,6:71],ind=NiN.natopen.cov[,74:79],iter=1000,obl=0.8,rat=1/3,var.abun=T)

### fixing NaN's
for (i in 1:length(natopen.ref.cov) ) {
  for (j in 1:ncol(natopen.ref.cov[[i]]) ) {
    v <- natopen.ref.cov[[i]][,j]
    v[is.nan(v)] <- NA
    natopen.ref.cov[[i]][,j] <- v
  }
}

#saveRDS(natopen.ref.cov, "C:/Users/joachim.topper/OneDrive - NINA/work/R projects/github/ecRxiv_functional-plant-indicators/indicators/NO_FUNC_001-004/data/cache/natopen.ref.cov.RDS")

```

<!-- Please insert all the code that produces the cached data. Probably just needs to add the saveRDS() part to the code chunk above. -->

```{r, include = F}
# Data from cache
wet_mount_forest_seminat.ref.cov<-readRDS(paste0(here::here(), "/indicators/NO_FUNC_001-004/data/cache/wet_mount_forest_seminat.ref.cov.RDS"))
natopen.ref.cov<-readRDS(paste0(here::here(), "/indicators/NO_FUNC_001-004/data/cache/natopen.ref.cov.RDS"))
```

```{r}
head(wet_mount_forest_seminat.ref.cov[[1]]) %>%
    kable("html", caption = "Table showing the first 6 rows of the boostrapped data set.") %>% kable_styling("striped") %>% scroll_box(width = "100%")
```

```{r}
head(natopen.ref.cov[[1]]) %>%
    kable("html", caption = "Table showing the first 6 rows of the boostrapped data set.") %>% kable_styling("striped") %>% scroll_box(width = "100%")
```

This results in two R-lists (one for wetland, mountain, forest and semi-natural ecosystem, and one for naturally open ecosystems below the tree line), each with a data frame for every selected plant indicator and each data frame with as many columns as there are NiN species lists and as many rows as there were iterations in the bootstrap. For the Heat requirement indicator the data frame hold only alpine/arctic ecosystem types.

Next, we need to derive scaling values from these bootstrap-lists (the columns) for every mapping unit in NiN. Here, we define things in the following way:

- Median = reference values
- 0.025 and 0.975 quantiles = lower and upper limit values
- min and max of the respective indicator's scale = min/max values

```{r, attr.output='style="max-height: 300px;"', results='hide'}

### wetland, mountain, forest, and semi-natural ecosystems

# every NiN-type is represented by one 'generalisert artsliste'
# some NiN-types are represented by two such species lists
# in some cases two NiN-types are represented by the same species list
head(wet_mount_forest_seminat.ref.cov[[1]])
wet_mount_forest_seminat.ref.cov[[1]][0,]

# NiN-types where each type is represented by one species list (including when one species list represents two NiN-types)
names(wet_mount_forest_seminat.ref.cov[["Light"]])
x <- c(1,5,16:32,37:47,50:65,68,95:96,109:115,117,121,126,129:132)

# checking the actual NiN-types in the seminat lists
wet_mount_forest_seminat.NiNtypes <- colnames(wet_mount_forest_seminat.ref.cov[["Light"]])
wet_mount_forest_seminat.NiNtypes[-x] <- substr(wet_mount_forest_seminat.NiNtypes[-x], 1, nchar(wet_mount_forest_seminat.NiNtypes[-x])-1)
wet_mount_forest_seminat.NiNtypes

# 11 indicator-value indicators: Tyler's Light, Moisture, Soil_reaction_pH, "Nitrogen"
indEll.n=11
# creating a table to hold:
# for every indicator: the 0.5 quantile (median), 0.025 quantile and  0.975 quantile for each NiN-type (3 metrics -> 3 columns per indicator), for Heat_requirement in alpine/arctic systems we do 0.05 quantile and  0.95 quantile and ignore the former as it is a one-sided indicator
# for every nature type (nrows)
tab <- matrix(ncol=3*indEll.n, nrow=87 ) # 87 basic ecosystem types
# coercing the values into the table

for (i in 1:length(x) ) {
  tab[i,1:3] <- quantile(as.matrix(wet_mount_forest_seminat.ref.cov[["CC"]][,x[i]]),probs=c(0.025,0.5,0.975),na.rm=T)
  tab[i,4:6] <- quantile(as.matrix(wet_mount_forest_seminat.ref.cov[["SS"]][,x[i]]),probs=c(0.025,0.5,0.975),na.rm=T)
  tab[i,7:9] <- quantile(as.matrix(wet_mount_forest_seminat.ref.cov[["RR"]][,x[i]]),probs=c(0.025,0.5,0.975),na.rm=T)

  tab[i,13:15] <- quantile(as.matrix(wet_mount_forest_seminat.ref.cov[["Light"]][,x[i]]),probs=c(0.025,0.5,0.975),na.rm=T)
  tab[i,16:18] <- quantile(as.matrix(wet_mount_forest_seminat.ref.cov[["Moisture"]][,x[i]]),probs=c(0.025,0.5,0.975),na.rm=T)
  tab[i,19:21] <- quantile(as.matrix(wet_mount_forest_seminat.ref.cov[["Soil_reaction_pH"]][,x[i]]),probs=c(0.025,0.5,0.975),na.rm=T)
  tab[i,22:24] <- quantile(as.matrix(wet_mount_forest_seminat.ref.cov[["Nitrogen"]][,x[i]]),probs=c(0.025,0.5,0.975),na.rm=T)
  tab[i,25:27] <- quantile(as.matrix(wet_mount_forest_seminat.ref.cov[["Phosphorus"]][,x[i]]),probs=c(0.025,0.5,0.975),na.rm=T)
  tab[i,28:30] <- quantile(as.matrix(wet_mount_forest_seminat.ref.cov[["Grazing_mowing"]][,x[i]]),probs=c(0.025,0.5,0.975),na.rm=T)
  tab[i,31:33] <- quantile(as.matrix(wet_mount_forest_seminat.ref.cov[["Soil_disturbance"]][,x[i]]),probs=c(0.025,0.5,0.975),na.rm=T)

}

tab <- as.data.frame(tab)
tab$NiN <- NA
tab$NiN[1:length(x)] <- names(wet_mount_forest_seminat.ref.cov[[1]])[x]
tab

names(wet_mount_forest_seminat.ref.cov[["Heat_requirement"]])
x.Hr <- c(1:6,9:24,27)
tab$NiN
x.all <- c(25:47)

for (i in 1:length(x.Hr) ) {
  tab[x.all[i],10:12] <- quantile(as.matrix(wet_mount_forest_seminat.ref.cov[["Heat_requirement"]][,x.Hr[i]]),probs=c(0.05,0.5,0.95),na.rm=T)

}


# NiN-types represented by several species lists
wet_mount_forest_seminat.NiNtypes2 <- wet_mount_forest_seminat.NiNtypes[-x]
unique(wet_mount_forest_seminat.NiNtypes2)
grep(pattern=unique(wet_mount_forest_seminat.NiNtypes2)[1], x=wet_mount_forest_seminat.NiNtypes) # finds columns in e.g. colnames(wet_mount_forest_seminat.ref.cov[["Light"]]) that match the first NiN-type


for (i in 1:length(unique(wet_mount_forest_seminat.NiNtypes2)) ) {
  
  tab[length(x)+i,1:3] <- quantile(as.matrix(wet_mount_forest_seminat.ref.cov[["CC"]][,grep(pattern=unique(wet_mount_forest_seminat.NiNtypes2)[i], x=wet_mount_forest_seminat.NiNtypes)]),probs=c(0.025,0.5,0.975),na.rm=T)
  tab[length(x)+i,4:6] <- quantile(as.matrix(wet_mount_forest_seminat.ref.cov[["SS"]][,grep(pattern=unique(wet_mount_forest_seminat.NiNtypes2)[i], x=wet_mount_forest_seminat.NiNtypes)]),probs=c(0.025,0.5,0.975),na.rm=T)
  tab[length(x)+i,7:9] <- quantile(as.matrix(wet_mount_forest_seminat.ref.cov[["RR"]][,grep(pattern=unique(wet_mount_forest_seminat.NiNtypes2)[i], x=wet_mount_forest_seminat.NiNtypes)]),probs=c(0.025,0.5,0.975),na.rm=T)

  tab[length(x)+i,13:15] <- quantile(as.matrix(wet_mount_forest_seminat.ref.cov[["Light"]][,grep(pattern=unique(wet_mount_forest_seminat.NiNtypes2)[i], x=wet_mount_forest_seminat.NiNtypes)]),probs=c(0.025,0.5,0.975),na.rm=T)
  tab[length(x)+i,16:18] <- quantile(as.matrix(wet_mount_forest_seminat.ref.cov[["Moisture"]][,grep(pattern=unique(wet_mount_forest_seminat.NiNtypes2)[i], x=wet_mount_forest_seminat.NiNtypes)]),probs=c(0.025,0.5,0.975),na.rm=T)
  tab[length(x)+i,19:21] <- quantile(as.matrix(wet_mount_forest_seminat.ref.cov[["Soil_reaction_pH"]][,grep(pattern=unique(wet_mount_forest_seminat.NiNtypes2)[i], x=wet_mount_forest_seminat.NiNtypes)]),probs=c(0.025,0.5,0.975),na.rm=T)
  tab[length(x)+i,22:24] <- quantile(as.matrix(wet_mount_forest_seminat.ref.cov[["Nitrogen"]][,grep(pattern=unique(wet_mount_forest_seminat.NiNtypes2)[i], x=wet_mount_forest_seminat.NiNtypes)]),probs=c(0.025,0.5,0.975),na.rm=T)
  tab[length(x)+i,25:27] <- quantile(as.matrix(wet_mount_forest_seminat.ref.cov[["Phosphorus"]][,grep(pattern=unique(wet_mount_forest_seminat.NiNtypes2)[i], x=wet_mount_forest_seminat.NiNtypes)]),probs=c(0.025,0.5,0.975),na.rm=T)
  tab[length(x)+i,28:30] <- quantile(as.matrix(wet_mount_forest_seminat.ref.cov[["Grazing_mowing"]][,grep(pattern=unique(wet_mount_forest_seminat.NiNtypes2)[i], x=wet_mount_forest_seminat.NiNtypes)]),probs=c(0.025,0.5,0.975),na.rm=T)
  tab[length(x)+i,31:33] <- quantile(as.matrix(wet_mount_forest_seminat.ref.cov[["Soil_disturbance"]][,grep(pattern=unique(wet_mount_forest_seminat.NiNtypes2)[i], x=wet_mount_forest_seminat.NiNtypes)]),probs=c(0.025,0.5,0.975),na.rm=T)
  
  tab$NiN[length(x)+i] <- unique(wet_mount_forest_seminat.NiNtypes2)[i]
  
}

tab[!is.na(tab$NiN) & tab$NiN=="T3-C1",10:12] <- quantile(as.matrix(wet_mount_forest_seminat.ref.cov[["Heat_requirement"]][,c("T3-C1a","T3-C1b")]),probs=c(0.05,0.5,0.95),na.rm=T)
tab[!is.na(tab$NiN) & tab$NiN=="T22-C1C3",10:12] <- quantile(as.matrix(wet_mount_forest_seminat.ref.cov[["Heat_requirement"]][,c("T22-C1C3a","T22-C1C3b")]),probs=c(0.05,0.5,0.95),na.rm=T)

tab

# when species lists represent several NiN-types
tab$NiN
tab <- rbind(tab,tab[c(27:30,42,44,47,55:57,60,62,71,83,85),])
tab$NiN[c(27:30,42,44,47,55:57,60,62,71,83,85,88:102)] <- c("T3-C3","T3-C9","T3-C5","T3-C8",
  "T7-C13","T7-C7","T22-C2","T32-C1",
  "T32-C3","T32-C7","T45-C1","V10-C1","T22-C1",
  "T32-C5","T32-C21",
  
  "T3-C6","T3-C12","T3-C5","T3-C11",
  "T7-C14","T7-C9","T22-C4","T32-C2",
  "T32-C4","T32-C8","T45-C2","V10-C2","T22-C3",
  "T32-C20","T32-C6")
tab

# making it a proper data frame
dim(tab)
round(tab[,1:32],digits=2)

colnames(tab) <- c("CC_q2.5","CC_q50","CC_q97.5",
                   "SS_q2.5","SS_q50","SS_q97.5",
                   "RR_q2.5","RR_q50","RR_q97.5",
                   "Heat_requirement_q5","Heat_requirement_q50","Heat_requirement_q95",
                   "Light_q2.5","Light_q50","Light_q97.5",
                   "Moist_q2.5","Moist_q50","Moist_q97.5",
                   "pH_q2.5","pH_q50","pH_q97.5",
                   "Nitrogen_q2.5","Nitrogen_q50","Nitrogen_q97.5",
                   "Phosphorus_q2.5","Phosphorus_q50","Phosphorus_q97.5",
                   "Grazing_mowing_q2.5","Grazing_mowing_q50","Grazing_mowing_q97.5",
                   "Soil_disturbance_q2.5","Soil_disturbance_q50","Soil_disturbance_q97.5",
                   
                   "NiN")
summary(tab)
tab$NiN <- gsub("C", "C-", tab$NiN) # add extra hyphen after C for NiN-types
tab


# restructuring into separate indicators for lower (q2.5) and higher (q97.5) than reference value (=median, q50)
y.CC <- numeric(length=nrow(tab)*2)
y.CC[((1:dim(tab)[1])*2)-1] <- tab$CC_q2.5 
y.CC[((1:dim(tab)[1])*2)] <- tab$CC_q97.5 

y.SS <- numeric(length=nrow(tab)*2)
y.SS[((1:dim(tab)[1])*2)-1] <- tab$SS_q2.5 
y.SS[((1:dim(tab)[1])*2)] <- tab$SS_q97.5 

y.RR <- numeric(length=nrow(tab)*2)
y.RR[((1:dim(tab)[1])*2)-1] <- tab$RR_q2.5 
y.RR[((1:dim(tab)[1])*2)] <- tab$RR_q97.5 

y.Heat_requirement <- numeric(length=nrow(tab)*2)
y.Heat_requirement[((1:dim(tab)[1])*2)-1] <- tab$Heat_requirement_q5 
y.Heat_requirement[((1:dim(tab)[1])*2)] <- tab$Heat_requirement_q95 

y.Light <- numeric(length=nrow(tab)*2)
y.Light[((1:dim(tab)[1])*2)-1] <- tab$Light_q2.5 
y.Light[((1:dim(tab)[1])*2)] <- tab$Light_q97.5 

y.Moist <- numeric(length=nrow(tab)*2)
y.Moist[((1:dim(tab)[1])*2)-1] <- tab$Moist_q2.5 
y.Moist[((1:dim(tab)[1])*2)] <- tab$Moist_q97.5 

y.pH <- numeric(length=nrow(tab)*2)
y.pH[((1:dim(tab)[1])*2)-1] <- tab$pH_q2.5 
y.pH[((1:dim(tab)[1])*2)] <- tab$pH_q97.5 

y.Nitrogen <- numeric(length=nrow(tab)*2)
y.Nitrogen[((1:dim(tab)[1])*2)-1] <- tab$Nitrogen_q2.5 
y.Nitrogen[((1:dim(tab)[1])*2)] <- tab$Nitrogen_q97.5 

y.Phosphorus <- numeric(length=nrow(tab)*2)
y.Phosphorus[((1:dim(tab)[1])*2)-1] <- tab$Phosphorus_q2.5 
y.Phosphorus[((1:dim(tab)[1])*2)] <- tab$Phosphorus_q97.5 

y.Grazing_mowing <- numeric(length=nrow(tab)*2)
y.Grazing_mowing[((1:dim(tab)[1])*2)-1] <- tab$Grazing_mowing_q2.5 
y.Grazing_mowing[((1:dim(tab)[1])*2)] <- tab$Grazing_mowing_q97.5 

y.Soil_disturbance <- numeric(length=nrow(tab)*2)
y.Soil_disturbance[((1:dim(tab)[1])*2)-1] <- tab$Soil_disturbance_q2.5 
y.Soil_disturbance[((1:dim(tab)[1])*2)] <- tab$Soil_disturbance_q97.5 

# creating final objects holding the reference and limit values for all indicators

# ref object for indicators
wet_mount_forest_seminat.ref.cov.val <- data.frame( grunn=c(rep(rep(tab$NiN,each=2),indEll.n)),
                                                    county=rep('all',(nrow(tab)*2*indEll.n)),
                                                    region=rep('all',(nrow(tab)*2*indEll.n)),
                                                    Ind=c(rep(c('CC1','CC2'),nrow(tab)),
                                                          rep(c('SS1','SS2'),nrow(tab)),
                                                          rep(c('RR1','RR2'),nrow(tab)),
                                                          rep(c('Heat_requirement1','Heat_requirement2'),nrow(tab)),
                                                          rep(c('Light1','Light2'),nrow(tab)),
                                                          rep(c('Moist1','Moist2'),nrow(tab)),
                                                          rep(c('pH1','pH2'),nrow(tab)),
                                                          rep(c('Nitrogen1','Nitrogen2'),nrow(tab)),
                                                          rep(c('Phosphorus1','Phosphorus2'),nrow(tab)),
                                                          rep(c('Grazing_mowing1','Grazing_mowing2'),nrow(tab)),
                                                          rep(c('Soil_disturbance1','Soil_disturbance2'),nrow(tab))
                                                          
                                                    ),
                                                    Rv=c(rep(tab$CC_q50,each=2),
                                                         rep(tab$SS_q50,each=2),
                                                         rep(tab$RR_q50,each=2),
                                                         rep(tab$Heat_requirement_q50,each=2),
                                                         rep(tab$Light_q50,each=2),
                                                         rep(tab$Moist_q50,each=2),
                                                         rep(tab$pH_q50,each=2),
                                                         rep(tab$Nitrogen_q50,each=2),
                                                         rep(tab$Phosphorus_q50,each=2),
                                                         rep(tab$Grazing_mowing_q50,each=2),
                                                         rep(tab$Soil_disturbance_q50,each=2)
                                                    ),
                                                    Gv=c(y.CC,y.SS,y.RR,y.Heat_requirement,y.Light,y.Moist,y.pH,y.Nitrogen,y.Phosphorus,y.Grazing_mowing,y.Soil_disturbance),
                                                    maxmin=c(rep(c(0,1),nrow(tab)), # CSR 0-1
                                                             rep(c(0,1),nrow(tab)), # CSR 0-1
                                                             rep(c(0,1),nrow(tab)), # CSR 0-1
                                                             rep(c(0,1),nrow(tab)), # Heat_requirement (sum of 1 at Heatreq=3 indicates that the vegetation is not alpine any more)
                                                             rep(c(1,7),nrow(tab)), # 7 levels of light
                                                             rep(c(1,12),nrow(tab)), # 12 levels of moisture
                                                             rep(c(1,8),nrow(tab)), # 8 levels of soil reaction pH
                                                             rep(c(1,9),nrow(tab)),  # 9 levels of nitrogen
                                                             rep(c(1,9),nrow(tab)),  # 5 levels of phosphorus
                                                             rep(c(1,9),nrow(tab)),  # 8 levels of grazing_mowing
                                                             rep(c(1,9),nrow(tab))  # 9 levels of soil_disturbance
                                                    )
)

wet_mount_forest_seminat.ref.cov.val
wet_mount_forest_seminat.ref.cov.val$grunn <- as.factor(wet_mount_forest_seminat.ref.cov.val$grunn)
wet_mount_forest_seminat.ref.cov.val$Ind <- as.factor(wet_mount_forest_seminat.ref.cov.val$Ind)
summary(wet_mount_forest_seminat.ref.cov.val)


### naturally open ecosystems below the treeline

# NiN-types where each type is represented by one species list (including when one species list represents two NiN-types)
names(natopen.ref.cov[["Light"]])
x <- 1:66

# checking the actual NiN-types in the natopen lists
natopen.NiNtypes <- colnames(natopen.ref.cov[["Light"]])
natopen.NiNtypes[-x] <- substr(natopen.NiNtypes[-x], 1, nchar(natopen.NiNtypes[-x])-1)
natopen.NiNtypes

# 7 indicator-value indicators: Grimes C, S and R, Tyler's Light, Nitrogen, and Soil_disturbance
indEll.n=6
# creating a table to hold:
# Tyler: the 0.5 quantile (median), 0.05 quantile and  0.95 quantile for each NiN-type
# for every nature type (nrows)
tab <- matrix(ncol=3*indEll.n, nrow=length(unique(natopen.NiNtypes)) ) # 66 basic ecosystem types
# coercing the values into the table


for (i in 1:length(x) ) {
  tab[i,1:3] <- quantile(as.matrix(natopen.ref.cov[["CC"]][,x[i]]),probs=c(0.025,0.5,0.975),na.rm=T)
  tab[i,4:6] <- quantile(as.matrix(natopen.ref.cov[["SS"]][,x[i]]),probs=c(0.025,0.5,0.975),na.rm=T)
  tab[i,7:9] <- quantile(as.matrix(natopen.ref.cov[["RR"]][,x[i]]),probs=c(0.025,0.5,0.975),na.rm=T)
  tab[i,10:12] <- quantile(as.matrix(natopen.ref.cov[["Light"]][,x[i]]),probs=c(0.025,0.5,0.975),na.rm=T)
  tab[i,13:15] <- quantile(as.matrix(natopen.ref.cov[["Nitrogen"]][,x[i]]),probs=c(0.025,0.5,0.975),na.rm=T)
  tab[i,16:18] <- quantile(as.matrix(natopen.ref.cov[["Soil_disturbance"]][,x[i]]),probs=c(0.025,0.5,0.975),na.rm=T)

}

tab <- as.data.frame(tab)
tab$NiN <- NA
tab$NiN[1:length(x)] <- names(natopen.ref.cov[[1]])[x]
tab


# making it a proper data frame
dim(tab)
round(tab[,1:18],digits=2)

colnames(tab) <- c("CC_q2.5","CC_q50","CC_q97.5",
                   "SS_q2.5","SS_q50","SS_q97.5",
                   "RR_q2.5","RR_q50","RR_q97.5",
                   "Light_q2.5","Light_q50","Light_q97.5",
                   "Nitrogen_q2.5","Nitrogen_q50","Nitrogen_q97.5",
                   "Soil_disturbance_q2.5","Soil_disturbance_q50","Soil_disturbance_q97.5",
                   "NiN")
summary(tab)
tab$NiN
#tab$NiN <- gsub("C", "C-", tab$NiN) # add extra hyphen after C for NiN-types
tab


# restructuring into separate indicators for lower (q2.5) and higher (q97.5) than reference value (=median, q50)
y.Light <- numeric(length=nrow(tab)*2)
y.Light[((1:dim(tab)[1])*2)-1] <- tab$Light_q2.5 
y.Light[((1:dim(tab)[1])*2)] <- tab$Light_q97.5 

y.CC <- numeric(length=nrow(tab)*2)
y.CC[((1:dim(tab)[1])*2)-1] <- tab$CC_q2.5 
y.CC[((1:dim(tab)[1])*2)] <- tab$CC_q97.5 

y.SS <- numeric(length=nrow(tab)*2)
y.SS[((1:dim(tab)[1])*2)-1] <- tab$SS_q2.5 
y.SS[((1:dim(tab)[1])*2)] <- tab$SS_q97.5 

y.Nitrogen <- numeric(length=nrow(tab)*2)
y.Nitrogen[((1:dim(tab)[1])*2)-1] <- tab$Nitrogen_q2.5 
y.Nitrogen[((1:dim(tab)[1])*2)] <- tab$Nitrogen_q97.5 

y.RR <- numeric(length=nrow(tab)*2)
y.RR[((1:dim(tab)[1])*2)-1] <- tab$RR_q2.5 
y.RR[((1:dim(tab)[1])*2)] <- tab$RR_q97.5 

y.Soil_disturbance <- numeric(length=nrow(tab)*2)
y.Soil_disturbance[((1:dim(tab)[1])*2)-1] <- tab$Soil_disturbance_q2.5 
y.Soil_disturbance[((1:dim(tab)[1])*2)] <- tab$Soil_disturbance_q97.5 

# creating final objects holding the reference and limit values for all indicators

# ref object for indicators
natopen.ref.cov.val <- data.frame(N1=rep('natopen',(nrow(tab)*2*indEll.n)),
                              hoved=c(rep('NA',(nrow(tab)*2*indEll.n))),
                              grunn=c(rep(rep(tab$NiN,each=2),indEll.n)),
                              county=rep('all',(nrow(tab)*2*indEll.n)),
                              region=rep('all',(nrow(tab)*2*indEll.n)),
                              Ind=c(rep(c('CC1','CC2'),nrow(tab)),
                                    rep(c('SS1','SS2'),nrow(tab)),
                                    rep(c('RR1','RR2'),nrow(tab)),
                                    rep(c('Light1','Light2'),nrow(tab)),
                                    rep(c('Nitrogen1','Nitrogen2'),nrow(tab)),
                                    rep(c('Soil_disturbance1','Soil_disturbance2'),nrow(tab))
                              ),
                              Rv=c(rep(tab$CC_q50,each=2),
                                   rep(tab$SS_q50,each=2),
                                   rep(tab$RR_q50,each=2),
                                   rep(tab$Light_q50,each=2),
                                   rep(tab$Nitrogen_q50,each=2),
                                   rep(tab$Soil_disturbance_q50,each=2)
                              ),
                              Gv=c(y.CC,y.SS,y.RR,y.Light,y.Nitrogen,y.Soil_disturbance),
                              maxmin=c(rep(c(0,1),nrow(tab)), # CC
                                       rep(c(0,1),nrow(tab)), # SS
                                       rep(c(0,1),nrow(tab)), # RR
                                       rep(c(1,7),nrow(tab)),  # 7 levels of Light
                                       rep(c(1,9),nrow(tab)),  # 9 levels of Nitrogen
                                       rep(c(1,9),nrow(tab))  # 9 levels of Soil_disturbance
                              )
)

natopen.ref.cov.val
natopen.ref.cov.val$grunn <- as.factor(natopen.ref.cov.val$grunn)
natopen.ref.cov.val$Ind <- as.factor(natopen.ref.cov.val$Ind)
summary(natopen.ref.cov.val)

```

```{r}
wet_mount_forest_seminat.ref.cov.val %>%
      kable("html", caption = "Reference values (Rv and threshold values (Gv) for each indicator and nature type combination") %>% kable_styling("striped") %>% scroll_box(width = "100%", height = "300px")

natopen.ref.cov.val %>%
      kable("html", caption = "Reference values (Rv and threshold values (Gv) for each indicator and nature type combination") %>% kable_styling("striped") %>% scroll_box(width = "100%", height = "300px")

```

Once test data and the scaling values from the reference data are in place, we can calculate CWMs (or cumulative distributions in the case of the Heat_requirment indicator in alpine/arcitc systems) of the selected indicators for the ANO community data and scale them against the scaling values from the reference distribution. Note that we scale each ANO plot's CWM against either the lower threshold value and the min value OR the upper threshold value and the max value based on whether the CWM is smaller or higher than the reference value. Since the scaled values for both sides range between 0 and 1, we generate separate lower and upper indicators for each plant functional indicator type. An ANO plot can only have a scaled value in either the lower or the upper indicator (the other one will be 'NA'), except for the unlikely event that the CWM exactly matches the reference value, in which case both lower and upper indicator will receive a scaled indicator value of 1.

Here is the scaling function:
```{r}

#### scaled values ####
r.s <- 1    # reference value
l.s <- 0.6  # limit value
a.s <- 0    # abscence of indicator, or indicator at maximum

#### function for calculating scaled values for measured value ####

## scaling function including truncation
scal <- function() {
  # place to hold the result
   x <- numeric()
  if (maxmin < ref) {
    # values >= the reference value equal 1
    if (val >= ref) {x <- 1}
    # values < the reference value and >= the limit value can be deducted from the linear relationship between these two
    if (val < ref & val >= lim) {x <- (l.s + (val-lim) * ( (r.s-l.s) / (ref-lim) ) )}
    # values < the limit value and > maxmin can be deducted from the linear relationship between these two
    if (val < lim & val > maxmin) {x <- (a.s + (val-maxmin) * ( (l.s-a.s) / (lim-maxmin) ) )}
    # value equals or lower than maxmin
    if (val <= maxmin) {x <-0}
  } else {
    # values <= the reference value equal 1
    if (val <= ref) {x <- 1}
    # values > the reference value and <= the limit value can be deducted from the linear relationship between these two
    if (val > ref & val <= lim) {x <- ( r.s - ( (r.s - l.s) * (val - ref) / (lim - ref) ) )}
    # values > the limit value and < maxmin can be deducted from the linear relationship between these two
    if (val > lim) {x <- ( l.s - (l.s * (val - lim) / (maxmin - lim) ) )}
    # value equals or larger than maxmin
    if (val >= maxmin) {x <-0}
  }
  return(x)
  
}

## function for calculating scaled values for measured value, without truncation
scal.2 <- function() {
  # place to hold the result
  x <- numeric()
  if (maxmin < ref) {
    # values >= the reference value estimated from the linear relationship for lim < x < ref (line below)
    if (val >= ref) {x <- (l.s + (val-lim) * ( (r.s-l.s) / (ref-lim) ) )}
    # values < the reference value and >= the limit value can be deducted from the linear relationship between these two
    if (val < ref & val >= lim) {x <- (l.s + (val-lim) * ( (r.s-l.s) / (ref-lim) ) )}
    # values < the limit value and > maxmin can be deducted from the linear relationship between these two
    if (val < lim & val > maxmin) {x <- (a.s + (val-maxmin) * ( (l.s-a.s) / (lim-maxmin) ) )}
    # value equal or lower than maxmin
    if (val <= maxmin) {x <-0}
  } else {
    # values <= the reference value estimated from the linear relationship for lim < x < ref (line below)
    if (val <= ref) {x <- ( r.s - ( (r.s - l.s) * (val - ref) / (lim - ref) ) )}
    # values > the reference value and <= the limit value can be deducted from the linear relationship between these two
    if (val > ref & val <= lim) {x <- ( r.s - ( (r.s - l.s) * (val - ref) / (lim - ref) ) )}
    # values > the limit value and < maxmin can be deducted from the linear relationship between these two
    if (val > lim & val < maxmin) {x <- ( l.s - (l.s * (val - lim) / (maxmin - lim) ) )}
    # value equal og larger than maxmin
    if (val >= maxmin) {x <-0}
  }
  return(x)
  
}


```

We then can prepare a list of data frames to hold the results and perform the scaling according to the principles described in NINA report 1967 (Töpper and Jakobsson 2021).
```{r, results='hide'}

unique(ANO.geo$hovedtype_rute) # NiN main types in data
unique(sub("\\-.*", "", wet_mount_forest_seminat.ref.cov.val$grunn)) # NiN main types in reference
#### creating dataframe to hold the results for wetlands ####
# all ANO points
nrow(ANO.geo)
# all ANO points with a NiN-type represented in the two reference data sets
nrow(ANO.geo[ANO.geo$hovedtype_rute %in% unique( c(sub("\\-.*", "", wet_mount_forest_seminat.ref.cov.val$grunn),sub("\\-.*", "", natopen.ref.cov.val$grunn)) ),])
# ok, we'll be losing 25% that are not covered by the reference

ANO.all <- ANO.geo[ANO.geo$hovedtype_rute %in% unique( c(sub("\\-.*", "", wet_mount_forest_seminat.ref.cov.val$grunn),sub("\\-.*", "", natopen.ref.cov.val$grunn)) ),]
head(ANO.all)
# update row-numbers
row.names(ANO.all) <- 1:nrow(ANO.all)
head(ANO.all)
dim(ANO.all)
colnames(ANO.all)

length(levels(as.factor(ANO.all$ano_flate_id)))
length(levels(as.factor(ANO.all$ano_punkt_id)))
summary(as.factor(ANO.all$ano_punkt_id))
# four points that are triple and many that are double -> needs to be fixed in the original data! Here, we simply proceed

unique(ANO.all$hovedoekosystem_punkt)
unique(ANO.all$hovedtype_rute)
unique(ANO.all$kartleggingsenhet_1m2)
unique(sub("\\ .*", "", ANO.all$kartleggingsenhet_1m2))
ANO.all$hovedtype_rute <- factor(ANO.all$hovedtype_rute)
ANO.all$kartleggingsenhet_1m2 <- factor(sub("\\ .*", "", ANO.all$kartleggingsenhet_1m2))
summary(ANO.all$hovedtype_rute)
summary(ANO.all$kartleggingsenhet_1m2)

results.ANO <- list()
ind <- unique(wet_mount_forest_seminat.ref.cov.val$Ind)
# choose columns for site description
colnames(ANO.all)
results.ANO[['original']] <- ANO.all
# drop geometry
st_geometry(results.ANO[['original']]) <- NULL
results.ANO[['original']]

# add columns for indicators
nvar.site <- ncol(results.ANO[['original']])
for (i in 1:length(ind) ) {results.ANO[['original']][,i+nvar.site] <- NA}
colnames(results.ANO[['original']])[(nvar.site+1):(length(ind)+nvar.site)] <- paste(ind)
for (i in (nvar.site+1):(length(ind)+nvar.site) ) {results.ANO[['original']][,i] <- as.numeric(results.ANO[['original']][,i])}
summary(results.ANO[['original']])
#results.ANO[['original']]$Region <- as.factor(results.ANO[['original']]$Region)
results.ANO[['original']]$globalid <- as.factor(results.ANO[['original']]$globalid)
results.ANO[['original']]$ano_flate_id <- as.factor(results.ANO[['original']]$ano_flate_id)
results.ANO[['original']]$ano_punkt_id <- as.factor(results.ANO[['original']]$ano_punkt_id)
results.ANO[['original']]$hovedoekosystem_250m2 <- as.factor(results.ANO[['original']]$hovedoekosystem_250m2)
#results.ANO[['original']]$Hovedoekosystem_rute  <- as.factor(results.ANO[['original']]$Hovedoekosystem_rute )
results.ANO[['original']]$kartleggingsenhet_1m2 <- as.factor(results.ANO[['original']]$kartleggingsenhet_1m2)
results.ANO[['original']]$hovedtype_rute    <- as.factor(results.ANO[['original']]$hovedtype_rute)


# roll out
results.ANO[['scaled']] <- results.ANO[['non-truncated']] <- results.ANO[['original']]

```

```{r, eval = F}

#### calculating scaled and non-truncated values for the indicators based on the dataset ####
for (i in 1:nrow(ANO.all) ) {  #
  tryCatch({
    print(i)
    print(paste(ANO.all$ano_flate_id[i]))
    print(paste(ANO.all$ano_punkt_id[i]))
    #    ANO.all$Hovedoekosystem_sirkel[i]
    #    ANO.all$Hovedoekosystem_rute[i]
    
    
    
    # if the ANO.hovedtype exists in the wet_mount_forest_seminat reference
    if ( ANO.all$hovedtype_rute[i] %in% unique(sub("\\-.*", "", wet_mount_forest_seminat.ref.cov.val$grunn)) ) {
      
      # if there is any species present in current ANO point  
      if ( length(ANO.sp.ind[ANO.sp.ind$parentglobalid==as.character(ANO.all$globalid[i]),'Species']) > 0 ) {
        
        
        # Light
        dat <- ANO.sp.ind[ANO.sp.ind$parentglobalid==as.character(ANO.all$globalid[i]),c('art_dekning','Light')]
        results.ANO[['original']][i,'richness'] <- nrow(dat)
        dat <- dat[!is.na(dat$Light),]
        
        if ( nrow(dat)>0 ) {
          
          val <- sum(dat[,'art_dekning'] * dat[,'Light'],na.rm=T) / sum(dat[,'art_dekning'],na.rm=T)
          # lower part of distribution
          ref <- wet_mount_forest_seminat.ref.cov.val[wet_mount_forest_seminat.ref.cov.val$Ind=='Light1' & wet_mount_forest_seminat.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'Rv']
          lim <- wet_mount_forest_seminat.ref.cov.val[wet_mount_forest_seminat.ref.cov.val$Ind=='Light1' & wet_mount_forest_seminat.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'Gv']
          maxmin <- wet_mount_forest_seminat.ref.cov.val[wet_mount_forest_seminat.ref.cov.val$Ind=='Light1' & wet_mount_forest_seminat.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'maxmin']
          # coercing x into results.ANO dataframe
          results.ANO[['scaled']][i,'Light1'] <- scal() 
          results.ANO[['non-truncated']][i,'Light1'] <- scal.2() 
          results.ANO[['original']][i,'Light1'] <- val 
          
          # upper part of distribution
          ref <- wet_mount_forest_seminat.ref.cov.val[wet_mount_forest_seminat.ref.cov.val$Ind=='Light2' & wet_mount_forest_seminat.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'Rv']
          lim <- wet_mount_forest_seminat.ref.cov.val[wet_mount_forest_seminat.ref.cov.val$Ind=='Light2' & wet_mount_forest_seminat.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'Gv']
          maxmin <- wet_mount_forest_seminat.ref.cov.val[wet_mount_forest_seminat.ref.cov.val$Ind=='Light2' & wet_mount_forest_seminat.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'maxmin']
          # coercing x into results.ANO dataframe
          results.ANO[['scaled']][i,'Light2'] <- scal() 
          results.ANO[['non-truncated']][i,'Light2'] <- scal.2() 
          results.ANO[['original']][i,'Light2'] <- val
        }
        
        
        # Moisture
        dat <- ANO.sp.ind[ANO.sp.ind$parentglobalid==as.character(ANO.all$globalid[i]),c('art_dekning','Moisture')]
        results.ANO[['original']][i,'richness'] <- nrow(dat)
        dat <- dat[!is.na(dat$Moisture),]
        
        if ( nrow(dat)>0 ) {
          
          val <- sum(dat[,'art_dekning'] * dat[,'Moisture'],na.rm=T) / sum(dat[,'art_dekning'],na.rm=T)
          # lower part of distribution
          ref <- wet_mount_forest_seminat.ref.cov.val[wet_mount_forest_seminat.ref.cov.val$Ind=='Moist1' & wet_mount_forest_seminat.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'Rv']
          lim <- wet_mount_forest_seminat.ref.cov.val[wet_mount_forest_seminat.ref.cov.val$Ind=='Moist1' & wet_mount_forest_seminat.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'Gv']
          maxmin <- wet_mount_forest_seminat.ref.cov.val[wet_mount_forest_seminat.ref.cov.val$Ind=='Moist1' & wet_mount_forest_seminat.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'maxmin']
          # coercing x into results.ANO dataframe
          results.ANO[['scaled']][i,'Moist1'] <- scal() 
          results.ANO[['non-truncated']][i,'Moist1'] <- scal.2() 
          results.ANO[['original']][i,'Moist1'] <- val 
          
          # upper part of distribution
          ref <- wet_mount_forest_seminat.ref.cov.val[wet_mount_forest_seminat.ref.cov.val$Ind=='Moist2' & wet_mount_forest_seminat.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'Rv']
          lim <- wet_mount_forest_seminat.ref.cov.val[wet_mount_forest_seminat.ref.cov.val$Ind=='Moist2' & wet_mount_forest_seminat.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'Gv']
          maxmin <- wet_mount_forest_seminat.ref.cov.val[wet_mount_forest_seminat.ref.cov.val$Ind=='Moist2' & wet_mount_forest_seminat.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'maxmin']
          # coercing x into results.ANO dataframe
          results.ANO[['scaled']][i,'Moist2'] <- scal() 
          results.ANO[['non-truncated']][i,'Moist2'] <- scal.2() 
          results.ANO[['original']][i,'Moist2'] <- val
        }
        
        
        # Soil_reaction_pH
        dat <- ANO.sp.ind[ANO.sp.ind$parentglobalid==as.character(ANO.all$globalid[i]),c('art_dekning','Soil_reaction_pH')]
        results.ANO[['original']][i,'richness'] <- nrow(dat)
        dat <- dat[!is.na(dat$Soil_reaction_pH),]
        
        if ( nrow(dat)>0 ) {
          
          val <- sum(dat[,'art_dekning'] * dat[,'Soil_reaction_pH'],na.rm=T) / sum(dat[,'art_dekning'],na.rm=T)
          # lower part of distribution
          ref <- wet_mount_forest_seminat.ref.cov.val[wet_mount_forest_seminat.ref.cov.val$Ind=='pH1' & wet_mount_forest_seminat.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'Rv']
          lim <- wet_mount_forest_seminat.ref.cov.val[wet_mount_forest_seminat.ref.cov.val$Ind=='pH1' & wet_mount_forest_seminat.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'Gv']
          maxmin <- wet_mount_forest_seminat.ref.cov.val[wet_mount_forest_seminat.ref.cov.val$Ind=='pH1' & wet_mount_forest_seminat.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'maxmin']
          # coercing x into results.ANO dataframe
          results.ANO[['scaled']][i,'pH1'] <- scal() 
          results.ANO[['non-truncated']][i,'pH1'] <- scal.2() 
          results.ANO[['original']][i,'pH1'] <- val 
          
          # upper part of distribution
          ref <- wet_mount_forest_seminat.ref.cov.val[wet_mount_forest_seminat.ref.cov.val$Ind=='pH2' & wet_mount_forest_seminat.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'Rv']
          lim <- wet_mount_forest_seminat.ref.cov.val[wet_mount_forest_seminat.ref.cov.val$Ind=='pH2' & wet_mount_forest_seminat.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'Gv']
          maxmin <- wet_mount_forest_seminat.ref.cov.val[wet_mount_forest_seminat.ref.cov.val$Ind=='pH2' & wet_mount_forest_seminat.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'maxmin']
          # coercing x into results.ANO dataframe
          results.ANO[['scaled']][i,'pH2'] <- scal() 
          results.ANO[['non-truncated']][i,'pH2'] <- scal.2() 
          results.ANO[['original']][i,'pH2'] <- val
        }
        
        
        # Nitrogen
        dat <- ANO.sp.ind[ANO.sp.ind$parentglobalid==as.character(ANO.all$globalid[i]),c('art_dekning','Nitrogen')]
        results.ANO[['original']][i,'richness'] <- nrow(dat)
        dat <- dat[!is.na(dat$Nitrogen),]
        
        if ( nrow(dat)>0 ) {
          
          val <- sum(dat[,'art_dekning'] * dat[,'Nitrogen'],na.rm=T) / sum(dat[,'art_dekning'],na.rm=T)
          # lower part of distribution
          ref <- wet_mount_forest_seminat.ref.cov.val[wet_mount_forest_seminat.ref.cov.val$Ind=='Nitrogen1' & wet_mount_forest_seminat.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'Rv']
          lim <- wet_mount_forest_seminat.ref.cov.val[wet_mount_forest_seminat.ref.cov.val$Ind=='Nitrogen1' & wet_mount_forest_seminat.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'Gv']
          maxmin <- wet_mount_forest_seminat.ref.cov.val[wet_mount_forest_seminat.ref.cov.val$Ind=='Nitrogen1' & wet_mount_forest_seminat.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'maxmin']
          # coercing x into results.ANO dataframe
          results.ANO[['scaled']][i,'Nitrogen1'] <- scal() 
          results.ANO[['non-truncated']][i,'Nitrogen1'] <- scal.2() 
          results.ANO[['original']][i,'Nitrogen1'] <- val 
          
          # upper part of distribution
          ref <- wet_mount_forest_seminat.ref.cov.val[wet_mount_forest_seminat.ref.cov.val$Ind=='Nitrogen2' & wet_mount_forest_seminat.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'Rv']
          lim <- wet_mount_forest_seminat.ref.cov.val[wet_mount_forest_seminat.ref.cov.val$Ind=='Nitrogen2' & wet_mount_forest_seminat.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'Gv']
          maxmin <- wet_mount_forest_seminat.ref.cov.val[wet_mount_forest_seminat.ref.cov.val$Ind=='Nitrogen2' & wet_mount_forest_seminat.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'maxmin']
          # coercing x into results.ANO dataframe
          results.ANO[['scaled']][i,'Nitrogen2'] <- scal() 
          results.ANO[['non-truncated']][i,'Nitrogen2'] <- scal.2() 
          results.ANO[['original']][i,'Nitrogen2'] <- val
        }
        

        # Phosphorus
        dat <- ANO.sp.ind[ANO.sp.ind$parentglobalid==as.character(ANO.all$globalid[i]),c('art_dekning','Phosphorus')]
        results.ANO[['original']][i,'richness'] <- nrow(dat)
        dat <- dat[!is.na(dat$Phosphorus),]
        
        if ( nrow(dat)>0 ) {
          
          val <- sum(dat[,'art_dekning'] * dat[,'Phosphorus'],na.rm=T) / sum(dat[,'art_dekning'],na.rm=T)
          # lower part of distribution
          ref <- wet_mount_forest_seminat.ref.cov.val[wet_mount_forest_seminat.ref.cov.val$Ind=='Phosphorus1' & wet_mount_forest_seminat.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'Rv']
          lim <- wet_mount_forest_seminat.ref.cov.val[wet_mount_forest_seminat.ref.cov.val$Ind=='Phosphorus1' & wet_mount_forest_seminat.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'Gv']
          maxmin <- wet_mount_forest_seminat.ref.cov.val[wet_mount_forest_seminat.ref.cov.val$Ind=='Phosphorus1' & wet_mount_forest_seminat.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'maxmin']
          # coercing x into results.ANO dataframe
          results.ANO[['scaled']][i,'Phosphorus1'] <- scal() 
          results.ANO[['non-truncated']][i,'Phosphorus1'] <- scal.2() 
          results.ANO[['original']][i,'Phosphorus1'] <- val 
          
          # upper part of distribution
          ref <- wet_mount_forest_seminat.ref.cov.val[wet_mount_forest_seminat.ref.cov.val$Ind=='Phosphorus2' & wet_mount_forest_seminat.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'Rv']
          lim <- wet_mount_forest_seminat.ref.cov.val[wet_mount_forest_seminat.ref.cov.val$Ind=='Phosphorus2' & wet_mount_forest_seminat.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'Gv']
          maxmin <- wet_mount_forest_seminat.ref.cov.val[wet_mount_forest_seminat.ref.cov.val$Ind=='Phosphorus2' & wet_mount_forest_seminat.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'maxmin']
          # coercing x into results.ANO dataframe
          results.ANO[['scaled']][i,'Phosphorus2'] <- scal() 
          results.ANO[['non-truncated']][i,'Phosphorus2'] <- scal.2() 
          results.ANO[['original']][i,'Phosphorus2'] <- val
        }
        
        
        # Grazing_mowing
        dat <- ANO.sp.ind[ANO.sp.ind$parentglobalid==as.character(ANO.all$globalid[i]),c('art_dekning','Grazing_mowing')]
        results.ANO[['original']][i,'richness'] <- nrow(dat)
        dat <- dat[!is.na(dat$Grazing_mowing),]
        
        if ( nrow(dat)>0 ) {
          
          val <- sum(dat[,'art_dekning'] * dat[,'Grazing_mowing'],na.rm=T) / sum(dat[,'art_dekning'],na.rm=T)
          # lower part of distribution
          ref <- wet_mount_forest_seminat.ref.cov.val[wet_mount_forest_seminat.ref.cov.val$Ind=='Grazing_mowing1' & wet_mount_forest_seminat.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'Rv']
          lim <- wet_mount_forest_seminat.ref.cov.val[wet_mount_forest_seminat.ref.cov.val$Ind=='Grazing_mowing1' & wet_mount_forest_seminat.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'Gv']
          maxmin <- wet_mount_forest_seminat.ref.cov.val[wet_mount_forest_seminat.ref.cov.val$Ind=='Grazing_mowing1' & wet_mount_forest_seminat.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'maxmin']
          # coercing x into results.ANO dataframe
          results.ANO[['scaled']][i,'Grazing_mowing1'] <- scal() 
          results.ANO[['non-truncated']][i,'Grazing_mowing1'] <- scal.2() 
          results.ANO[['original']][i,'Grazing_mowing1'] <- val 
          
          # upper part of distribution
          ref <- wet_mount_forest_seminat.ref.cov.val[wet_mount_forest_seminat.ref.cov.val$Ind=='Grazing_mowing2' & wet_mount_forest_seminat.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'Rv']
          lim <- wet_mount_forest_seminat.ref.cov.val[wet_mount_forest_seminat.ref.cov.val$Ind=='Grazing_mowing2' & wet_mount_forest_seminat.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'Gv']
          maxmin <- wet_mount_forest_seminat.ref.cov.val[wet_mount_forest_seminat.ref.cov.val$Ind=='Grazing_mowing2' & wet_mount_forest_seminat.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'maxmin']
          # coercing x into results.ANO dataframe
          results.ANO[['scaled']][i,'Grazing_mowing2'] <- scal() 
          results.ANO[['non-truncated']][i,'Grazing_mowing2'] <- scal.2() 
          results.ANO[['original']][i,'Grazing_mowing2'] <- val
        }
        
        
        # Soil_disturbance
        dat <- ANO.sp.ind[ANO.sp.ind$parentglobalid==as.character(ANO.all$globalid[i]),c('art_dekning','Soil_disturbance')]
        results.ANO[['original']][i,'richness'] <- nrow(dat)
        dat <- dat[!is.na(dat$Soil_disturbance),]
        
        if ( nrow(dat)>0 ) {
          
          val <- sum(dat[,'art_dekning'] * dat[,'Soil_disturbance'],na.rm=T) / sum(dat[,'art_dekning'],na.rm=T)
          # lower part of distribution
          ref <- wet_mount_forest_seminat.ref.cov.val[wet_mount_forest_seminat.ref.cov.val$Ind=='Soil_disturbance1' & wet_mount_forest_seminat.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'Rv']
          lim <- wet_mount_forest_seminat.ref.cov.val[wet_mount_forest_seminat.ref.cov.val$Ind=='Soil_disturbance1' & wet_mount_forest_seminat.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'Gv']
          maxmin <- wet_mount_forest_seminat.ref.cov.val[wet_mount_forest_seminat.ref.cov.val$Ind=='Soil_disturbance1' & wet_mount_forest_seminat.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'maxmin']
          # coercing x into results.ANO dataframe
          results.ANO[['scaled']][i,'Soil_disturbance1'] <- scal() 
          results.ANO[['non-truncated']][i,'Soil_disturbance1'] <- scal.2() 
          results.ANO[['original']][i,'Soil_disturbance1'] <- val 
          
          # upper part of distribution
          ref <- wet_mount_forest_seminat.ref.cov.val[wet_mount_forest_seminat.ref.cov.val$Ind=='Soil_disturbance2' & wet_mount_forest_seminat.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'Rv']
          lim <- wet_mount_forest_seminat.ref.cov.val[wet_mount_forest_seminat.ref.cov.val$Ind=='Soil_disturbance2' & wet_mount_forest_seminat.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'Gv']
          maxmin <- wet_mount_forest_seminat.ref.cov.val[wet_mount_forest_seminat.ref.cov.val$Ind=='Soil_disturbance2' & wet_mount_forest_seminat.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'maxmin']
          # coercing x into results.ANO dataframe
          results.ANO[['scaled']][i,'Soil_disturbance2'] <- scal() 
          results.ANO[['non-truncated']][i,'Soil_disturbance2'] <- scal.2() 
          results.ANO[['original']][i,'Soil_disturbance2'] <- val
        }

      }
    }
    
    
    # if the ANO.hovedtype is a mountain ecosystem qualifying for the Heat_requirement indicator
    if ( ANO.all$hovedtype_rute[i] %in% c('T3','T7','T14','T22') ) {
      
      # if there is any species present in current ANO point  
      if ( length(ANO.sp.ind[ANO.sp.ind$parentglobalid==as.character(ANO.all$globalid[i]),'Species']) > 0 ) {
        
        
        #Heat requirement overhang
        dat <- ANO.sp.ind[ANO.sp.ind$parentglobalid==as.character(ANO.all$globalid[i]),c('art_dekning','Heat_requirement')]
        results.ANO[['original']][i,'richness'] <- nrow(dat)
        dat <- dat[!is.na(dat$Heat_requirement) & dat$art_dekning>0,]
        
        if ( nrow(dat)>0 ) {
          
          dat$art_dekning <- dat$art_dekning/sum(dat$art_dekning) # scaling to total cover of 100%
          
          abun.cumsums <- abun.sums <- data.frame(Heat_requirement=rev(1:13),cumsum=NA)
          
          dat <- dat %>% add_row(Heat_requirement=1:13, art_dekning =rep(0,13))
          abun.sums[,2] <- rev(with(dat,tapply(art_dekning,Heat_requirement,sum)))
          abun.cumsums[,2] <- cumsum(abun.sums[,2])
          
          val <- abun.cumsums[11,2]
          ref <- wet_mount_forest_seminat.ref.cov.val[wet_mount_forest_seminat.ref.cov.val$Ind=='Heat_requirement2' & wet_mount_forest_seminat.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'Rv']
          lim <- wet_mount_forest_seminat.ref.cov.val[wet_mount_forest_seminat.ref.cov.val$Ind=='Heat_requirement2' & wet_mount_forest_seminat.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'Gv']
          maxmin <- wet_mount_forest_seminat.ref.cov.val[wet_mount_forest_seminat.ref.cov.val$Ind=='Heat_requirement2' & wet_mount_forest_seminat.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'maxmin']
          
          # coercing x into results.ANO dataframe
          results.ANO[['scaled']][i,'Heat_requirement2'] <- scal() 
          results.ANO[['non-truncated']][i,'Heat_requirement2'] <- scal.2() 
          results.ANO[['original']][i,'Heat_requirement2'] <- val          
        } 
        
      }
    }
    
    
    # if the ANO.hovedtype exists in the natopen reference
    if ( ANO.all$hovedtype_rute[i] %in% unique(sub("\\-.*", "", natopen.ref.cov.val$grunn)) ) {
      
      # if there is any species present in current ANO point  
      if ( length(ANO.sp.ind[ANO.sp.ind$parentglobalid==as.character(ANO.all$globalid[i]),'Species']) > 0 ) {
        
        # Grime's C
        
        dat <- ANO.sp.ind[ANO.sp.ind$parentglobalid==as.character(ANO.all$globalid[i]),c('art_dekning','CC')]
        results.ANO[['original']][i,'richness'] <- nrow(dat)
        dat <- dat[!is.na(dat$CC),]
        
        if ( nrow(dat)>0 ) {
          
          val <- sum(dat[,'art_dekning'] * dat[,'CC'],na.rm=T) / sum(dat[,'art_dekning'],na.rm=T)
          # lower part of distribution
          if( ANO.all$kartleggingsenhet_1m2[i] %in% c("T2-C-7","T2-C-8") ) {
            ref <- natopen.ref.cov.val[natopen.ref.cov.val$Ind=='CC1' & natopen.ref.cov.val$grunn==paste(as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),"_BN",sep=""),'Rv']
            lim <- natopen.ref.cov.val[natopen.ref.cov.val$Ind=='CC1' & natopen.ref.cov.val$grunn==paste(as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),"_BN",sep=""),'Gv']
          } else {
            ref <- natopen.ref.cov.val[natopen.ref.cov.val$Ind=='CC1' & natopen.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'Rv']
            lim <- natopen.ref.cov.val[natopen.ref.cov.val$Ind=='CC1' & natopen.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'Gv']
          }
          maxmin <- natopen.ref.cov.val[natopen.ref.cov.val$Ind=='CC1' & natopen.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'maxmin']
          # coercing x into results.ANO dataframe
          results.ANO[['scaled']][i,'CC1'] <- scal() 
          results.ANO[['non-truncated']][i,'CC1'] <- scal.2() 
          results.ANO[['original']][i,'CC1'] <- val 
          
          # upper part of distribution
          if( ANO.all$kartleggingsenhet_1m2[i] %in% c("T2-C-7","T2-C-8") ) {
            ref <- natopen.ref.cov.val[natopen.ref.cov.val$Ind=='CC2' & natopen.ref.cov.val$grunn==paste(as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),"_BN",sep=""),'Rv']
            lim <- natopen.ref.cov.val[natopen.ref.cov.val$Ind=='CC2' & natopen.ref.cov.val$grunn==paste(as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),"_BN",sep=""),'Gv']
          } else {
            ref <- natopen.ref.cov.val[natopen.ref.cov.val$Ind=='CC2' & natopen.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'Rv']
            lim <- natopen.ref.cov.val[natopen.ref.cov.val$Ind=='CC2' & natopen.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'Gv']
          }          
          maxmin <- natopen.ref.cov.val[natopen.ref.cov.val$Ind=='CC2' & natopen.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'maxmin']
          # coercing x into results.ANO dataframe
          results.ANO[['scaled']][i,'CC2'] <- scal() 
          results.ANO[['non-truncated']][i,'CC2'] <- scal.2() 
          results.ANO[['original']][i,'CC2'] <- val
        }
        
        
        # Grime's S
        dat <- ANO.sp.ind[ANO.sp.ind$parentglobalid==as.character(ANO.all$globalid[i]),c('art_dekning','SS')]
        results.ANO[['original']][i,'richness'] <- nrow(dat)
        dat <- dat[!is.na(dat$SS),]
        
        if ( nrow(dat)>0 ) {
          
          val <- sum(dat[,'art_dekning'] * dat[,'SS'],na.rm=T) / sum(dat[,'art_dekning'],na.rm=T)
          # lower part of distribution
          if( ANO.all$kartleggingsenhet_1m2[i] %in% c("T2-C-7","T2-C-8") ) {
            ref <- natopen.ref.cov.val[natopen.ref.cov.val$Ind=='SS1' & natopen.ref.cov.val$grunn==paste(as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),"_BN",sep=""),'Rv']
            lim <- natopen.ref.cov.val[natopen.ref.cov.val$Ind=='SS1' & natopen.ref.cov.val$grunn==paste(as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),"_BN",sep=""),'Gv']
          } else {
            ref <- natopen.ref.cov.val[natopen.ref.cov.val$Ind=='SS1' & natopen.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'Rv']
            lim <- natopen.ref.cov.val[natopen.ref.cov.val$Ind=='SS1' & natopen.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'Gv']
          }          
          maxmin <- natopen.ref.cov.val[natopen.ref.cov.val$Ind=='SS1' & natopen.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'maxmin']
          # coercing x into results.ANO dataframe
          results.ANO[['scaled']][i,'SS1'] <- scal() 
          results.ANO[['non-truncated']][i,'SS1'] <- scal.2() 
          results.ANO[['original']][i,'SS1'] <- val 
          
          # upper part of distribution
          if( ANO.all$kartleggingsenhet_1m2[i] %in% c("T2-C-7","T2-C-8") ) {
            ref <- natopen.ref.cov.val[natopen.ref.cov.val$Ind=='SS2' & natopen.ref.cov.val$grunn==paste(as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),"_BN",sep=""),'Rv']
            lim <- natopen.ref.cov.val[natopen.ref.cov.val$Ind=='SS2' & natopen.ref.cov.val$grunn==paste(as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),"_BN",sep=""),'Gv']
          } else {
            ref <- natopen.ref.cov.val[natopen.ref.cov.val$Ind=='SS2' & natopen.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'Rv']
            lim <- natopen.ref.cov.val[natopen.ref.cov.val$Ind=='SS2' & natopen.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'Gv']
          }          
          maxmin <- natopen.ref.cov.val[natopen.ref.cov.val$Ind=='SS2' & natopen.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'maxmin']
          # coercing x into results.ANO dataframe
          results.ANO[['scaled']][i,'SS2'] <- scal() 
          results.ANO[['non-truncated']][i,'SS2'] <- scal.2() 
          results.ANO[['original']][i,'SS2'] <- val
        }
        
        
        # Grime's R
        dat <- ANO.sp.ind[ANO.sp.ind$parentglobalid==as.character(ANO.all$globalid[i]),c('art_dekning','RR')]
        results.ANO[['original']][i,'richness'] <- nrow(dat)
        dat <- dat[!is.na(dat$RR),]
        
        if ( nrow(dat)>0 ) {
          
          val <- sum(dat[,'art_dekning'] * dat[,'RR'],na.rm=T) / sum(dat[,'art_dekning'],na.rm=T)
          # lower part of distribution
          if( ANO.all$kartleggingsenhet_1m2[i] %in% c("T2-C-7","T2-C-8") ) {
            ref <- natopen.ref.cov.val[natopen.ref.cov.val$Ind=='RR1' & natopen.ref.cov.val$grunn==paste(as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),"_BN",sep=""),'Rv']
            lim <- natopen.ref.cov.val[natopen.ref.cov.val$Ind=='RR1' & natopen.ref.cov.val$grunn==paste(as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),"_BN",sep=""),'Gv']
          } else {
            ref <- natopen.ref.cov.val[natopen.ref.cov.val$Ind=='RR1' & natopen.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'Rv']
            lim <- natopen.ref.cov.val[natopen.ref.cov.val$Ind=='RR1' & natopen.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'Gv']
          }          
          maxmin <- natopen.ref.cov.val[natopen.ref.cov.val$Ind=='RR1' & natopen.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'maxmin']
          # coercing x into results.ANO dataframe
          results.ANO[['scaled']][i,'RR1'] <- scal() 
          results.ANO[['non-truncated']][i,'RR1'] <- scal.2() 
          results.ANO[['original']][i,'RR1'] <- val 
          
          # upper part of distribution
          if( ANO.all$kartleggingsenhet_1m2[i] %in% c("T2-C-7","T2-C-8") ) {
            ref <- natopen.ref.cov.val[natopen.ref.cov.val$Ind=='RR2' & natopen.ref.cov.val$grunn==paste(as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),"_BN",sep=""),'Rv']
            lim <- natopen.ref.cov.val[natopen.ref.cov.val$Ind=='RR2' & natopen.ref.cov.val$grunn==paste(as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),"_BN",sep=""),'Gv']
          } else {
            ref <- natopen.ref.cov.val[natopen.ref.cov.val$Ind=='RR2' & natopen.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'Rv']
            lim <- natopen.ref.cov.val[natopen.ref.cov.val$Ind=='RR2' & natopen.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'Gv']
          }          
          maxmin <- natopen.ref.cov.val[natopen.ref.cov.val$Ind=='RR2' & natopen.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'maxmin']
          # coercing x into results.ANO dataframe
          results.ANO[['scaled']][i,'RR2'] <- scal() 
          results.ANO[['non-truncated']][i,'RR2'] <- scal.2() 
          results.ANO[['original']][i,'RR2'] <- val
        }
        
        
        # Light
        dat <- ANO.sp.ind[ANO.sp.ind$parentglobalid==as.character(ANO.all$globalid[i]),c('art_dekning','Light')]
        results.ANO[['original']][i,'richness'] <- nrow(dat)
        dat <- dat[!is.na(dat$Light),]
        
        if ( nrow(dat)>0 ) {
          
          val <- sum(dat[,'art_dekning'] * dat[,'Light'],na.rm=T) / sum(dat[,'art_dekning'],na.rm=T)
          # lower part of distribution
          if( ANO.all$kartleggingsenhet_1m2[i] %in% c("T2-C-7","T2-C-8") ) {
            ref <- natopen.ref.cov.val[natopen.ref.cov.val$Ind=='Light1' & natopen.ref.cov.val$grunn==paste(as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),"_BN",sep=""),'Rv']
            lim <- natopen.ref.cov.val[natopen.ref.cov.val$Ind=='Light1' & natopen.ref.cov.val$grunn==paste(as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),"_BN",sep=""),'Gv']
          } else {
            ref <- natopen.ref.cov.val[natopen.ref.cov.val$Ind=='Light1' & natopen.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'Rv']
            lim <- natopen.ref.cov.val[natopen.ref.cov.val$Ind=='Light1' & natopen.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'Gv']
          }            
          maxmin <- natopen.ref.cov.val[natopen.ref.cov.val$Ind=='Light1' & natopen.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'maxmin']
          # coercing x into results.ANO dataframe
          results.ANO[['scaled']][i,'Light1'] <- scal() 
          results.ANO[['non-truncated']][i,'Light1'] <- scal.2() 
          results.ANO[['original']][i,'Light1'] <- val 
          
          # upper part of distribution
          if( ANO.all$kartleggingsenhet_1m2[i] %in% c("T2-C-7","T2-C-8") ) {
            ref <- natopen.ref.cov.val[natopen.ref.cov.val$Ind=='Light2' & natopen.ref.cov.val$grunn==paste(as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),"_BN",sep=""),'Rv']
            lim <- natopen.ref.cov.val[natopen.ref.cov.val$Ind=='Light2' & natopen.ref.cov.val$grunn==paste(as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),"_BN",sep=""),'Gv']
          } else {
            ref <- natopen.ref.cov.val[natopen.ref.cov.val$Ind=='Light2' & natopen.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'Rv']
            lim <- natopen.ref.cov.val[natopen.ref.cov.val$Ind=='Light2' & natopen.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'Gv']
          }            
          maxmin <- natopen.ref.cov.val[natopen.ref.cov.val$Ind=='Light2' & natopen.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'maxmin']
          # coercing x into results.ANO dataframe
          results.ANO[['scaled']][i,'Light2'] <- scal() 
          results.ANO[['non-truncated']][i,'Light2'] <- scal.2() 
          results.ANO[['original']][i,'Light2'] <- val
        }
        
        
        # Nitrogen
        dat <- ANO.sp.ind[ANO.sp.ind$parentglobalid==as.character(ANO.all$globalid[i]),c('art_dekning','Nitrogen')]
        results.ANO[['original']][i,'richness'] <- nrow(dat)
        dat <- dat[!is.na(dat$Nitrogen),]
        
        if ( nrow(dat)>0 ) {
          
          val <- sum(dat[,'art_dekning'] * dat[,'Nitrogen'],na.rm=T) / sum(dat[,'art_dekning'],na.rm=T)
          # lower part of distribution
          if( ANO.all$kartleggingsenhet_1m2[i] %in% c("T2-C-7","T2-C-8") ) {
            ref <- natopen.ref.cov.val[natopen.ref.cov.val$Ind=='Nitrogen1' & natopen.ref.cov.val$grunn==paste(as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),"_BN",sep=""),'Rv']
            lim <- natopen.ref.cov.val[natopen.ref.cov.val$Ind=='Nitrogen1' & natopen.ref.cov.val$grunn==paste(as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),"_BN",sep=""),'Gv']
          } else {
            ref <- natopen.ref.cov.val[natopen.ref.cov.val$Ind=='Nitrogen1' & natopen.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'Rv']
            lim <- natopen.ref.cov.val[natopen.ref.cov.val$Ind=='Nitrogen1' & natopen.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'Gv']
          }            
          maxmin <- natopen.ref.cov.val[natopen.ref.cov.val$Ind=='Nitrogen1' & natopen.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'maxmin']
          # coercing x into results.ANO dataframe
          results.ANO[['scaled']][i,'Nitrogen1'] <- scal() 
          results.ANO[['non-truncated']][i,'Nitrogen1'] <- scal.2() 
          results.ANO[['original']][i,'Nitrogen1'] <- val 
          
          # upper part of distribution
          if( ANO.all$kartleggingsenhet_1m2[i] %in% c("T2-C-7","T2-C-8") ) {
            ref <- natopen.ref.cov.val[natopen.ref.cov.val$Ind=='Nitrogen2' & natopen.ref.cov.val$grunn==paste(as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),"_BN",sep=""),'Rv']
            lim <- natopen.ref.cov.val[natopen.ref.cov.val$Ind=='Nitrogen2' & natopen.ref.cov.val$grunn==paste(as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),"_BN",sep=""),'Gv']
          } else {
            ref <- natopen.ref.cov.val[natopen.ref.cov.val$Ind=='Nitrogen2' & natopen.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'Rv']
            lim <- natopen.ref.cov.val[natopen.ref.cov.val$Ind=='Nitrogen2' & natopen.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'Gv']
          }            
          maxmin <- natopen.ref.cov.val[natopen.ref.cov.val$Ind=='Nitrogen2' & natopen.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'maxmin']
          # coercing x into results.ANO dataframe
          results.ANO[['scaled']][i,'Nitrogen2'] <- scal() 
          results.ANO[['non-truncated']][i,'Nitrogen2'] <- scal.2() 
          results.ANO[['original']][i,'Nitrogen2'] <- val
        }
        
        
        # Soil_disturbance
        dat <- ANO.sp.ind[ANO.sp.ind$parentglobalid==as.character(ANO.all$globalid[i]),c('art_dekning','Soil_disturbance')]
        results.ANO[['original']][i,'richness'] <- nrow(dat)
        dat <- dat[!is.na(dat$Soil_disturbance),]
        
        if ( nrow(dat)>0 ) {
          
          val <- sum(dat[,'art_dekning'] * dat[,'Soil_disturbance'],na.rm=T) / sum(dat[,'art_dekning'],na.rm=T)
          # lower part of distribution
          if( ANO.all$kartleggingsenhet_1m2[i] %in% c("T2-C-7","T2-C-8") ) {
            ref <- natopen.ref.cov.val[natopen.ref.cov.val$Ind=='Soil_disturbance1' & natopen.ref.cov.val$grunn==paste(as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),"_BN",sep=""),'Rv']
            lim <- natopen.ref.cov.val[natopen.ref.cov.val$Ind=='Soil_disturbance1' & natopen.ref.cov.val$grunn==paste(as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),"_BN",sep=""),'Gv']
          } else {
            ref <- natopen.ref.cov.val[natopen.ref.cov.val$Ind=='Soil_disturbance1' & natopen.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'Rv']
            lim <- natopen.ref.cov.val[natopen.ref.cov.val$Ind=='Soil_disturbance1' & natopen.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'Gv']
          }           
          maxmin <- natopen.ref.cov.val[natopen.ref.cov.val$Ind=='Soil_disturbance1' & natopen.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'maxmin']
          # coercing x into results.ANO dataframe
          results.ANO[['scaled']][i,'Soil_disturbance1'] <- scal() 
          results.ANO[['non-truncated']][i,'Soil_disturbance1'] <- scal.2() 
          results.ANO[['original']][i,'Soil_disturbance1'] <- val 
          
          # upper part of distribution
          if( ANO.all$kartleggingsenhet_1m2[i] %in% c("T2-C-7","T2-C-8") ) {
            ref <- natopen.ref.cov.val[natopen.ref.cov.val$Ind=='Soil_disturbance2' & natopen.ref.cov.val$grunn==paste(as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),"_BN",sep=""),'Rv']
            lim <- natopen.ref.cov.val[natopen.ref.cov.val$Ind=='Soil_disturbance2' & natopen.ref.cov.val$grunn==paste(as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),"_BN",sep=""),'Gv']
          } else {
            ref <- natopen.ref.cov.val[natopen.ref.cov.val$Ind=='Soil_disturbance2' & natopen.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'Rv']
            lim <- natopen.ref.cov.val[natopen.ref.cov.val$Ind=='Soil_disturbance2' & natopen.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'Gv']
          }
          maxmin <- natopen.ref.cov.val[natopen.ref.cov.val$Ind=='Soil_disturbance2' & natopen.ref.cov.val$grunn==as.character(results.ANO[['original']][i,"kartleggingsenhet_1m2"]),'maxmin']
          # coercing x into results.ANO dataframe
          results.ANO[['scaled']][i,'Soil_disturbance2'] <- scal() 
          results.ANO[['non-truncated']][i,'Soil_disturbance2'] <- scal.2() 
          results.ANO[['original']][i,'Soil_disturbance2'] <- val
        }
        
      }
      
    }

  }, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
}

# for using both sides of the plant indicators
results.ANO[['2-sided']] <- results.ANO[['non-truncated']]

# remove values >1 for 2-sided indicators
results.ANO[['2-sided']]$CC1[results.ANO[['2-sided']]$CC1>1] <- NA
results.ANO[['2-sided']]$CC2[results.ANO[['2-sided']]$CC2>1] <- NA

results.ANO[['2-sided']]$SS1[results.ANO[['2-sided']]$SS1>1] <- NA
results.ANO[['2-sided']]$SS2[results.ANO[['2-sided']]$SS2>1] <- NA

results.ANO[['2-sided']]$RR1[results.ANO[['2-sided']]$RR1>1] <- NA
results.ANO[['2-sided']]$RR2[results.ANO[['2-sided']]$RR2>1] <- NA

results.ANO[['2-sided']]$Light1[results.ANO[['2-sided']]$Light1>1] <- NA
results.ANO[['2-sided']]$Light2[results.ANO[['2-sided']]$Light2>1] <- NA

results.ANO[['2-sided']]$Moist1[results.ANO[['2-sided']]$Moist1>1] <- NA
results.ANO[['2-sided']]$Moist2[results.ANO[['2-sided']]$Moist2>1] <- NA

results.ANO[['2-sided']]$pH1[results.ANO[['2-sided']]$pH1>1] <- NA
results.ANO[['2-sided']]$pH2[results.ANO[['2-sided']]$pH2>1] <- NA

results.ANO[['2-sided']]$Nitrogen1[results.ANO[['2-sided']]$Nitrogen1>1] <- NA
results.ANO[['2-sided']]$Nitrogen2[results.ANO[['2-sided']]$Nitrogen2>1] <- NA

results.ANO[['2-sided']]$Phosphorus1[results.ANO[['2-sided']]$Phosphorus1>1] <- NA
results.ANO[['2-sided']]$Phosphorus2[results.ANO[['2-sided']]$Phosphorus2>1] <- NA

results.ANO[['2-sided']]$Grazing_mowing1[results.ANO[['2-sided']]$Grazing_mowing1>1] <- NA
results.ANO[['2-sided']]$Grazing_mowing2[results.ANO[['2-sided']]$Grazing_mowing2>1] <- NA

results.ANO[['2-sided']]$Soil_disturbance1[results.ANO[['2-sided']]$Soil_disturbance1>1] <- NA
results.ANO[['2-sided']]$Soil_disturbance2[results.ANO[['2-sided']]$Soil_disturbance2>1] <- NA

results.ANO[['2-sided']]$Heat_requirement1 <- NA
results.ANO[['2-sided']]$Heat_requirement2 <- results.ANO[['scaled']]$Heat_requirement2

#saveRDS(results.ANO, "C:/R projects github/ecRxiv_functional-plant-indicators/indicators/NO_FUNC_001-004/data/cache/results.ANO.RDS")

#saveRDS(ANO.all, "C:/R projects github/ecRxiv_functional-plant-indicators/indicators/NO_FUNC_001-004/data/cache/ANO.all.RDS")


```

```{r, include = F}
# Use cache data
results.ANO<-readRDS(paste0(here::here(),"/indicators/NO_FUNC_001-004/data/cache/results.ANO.RDS"))
ANO.all<-readRDS(paste0(here::here(),"/indicators/NO_FUNC_001-004/data/cache/ANO.all.RDS"))
```

```{r}
head(results.ANO[['2-sided']]) %>%
      kable("html", caption = "ANO plots for ecosystems with scaled indicator values in the far-right columns.") %>% 
  kable_styling("striped") %>% scroll_box(width = "100%")
```
#### Scaled value analyses

In order to calculate regional indices for the indicator(s) in addition to national ones we need add information on region to the results-object before rearrange the results-object from wide to long format (note that there is both a lower and an upper condition indicator for each of the functional plant community indicators other than Heat-requirement).

```{r, message = FALSE}
#### preparing results data for calculating of indices ####
## continuing with 2-sided
res.ANO <- results.ANO[['2-sided']]

# keep wide format and add geometry again
st_geometry(res.ANO) <- st_geometry(ANO.all)

nor <- st_read("C:/R projects github/ecRxiv_functional-plant-indicators/indicators/NO_FUNC_001-004/data/spatial/outlineOfNorway_EPSG25833.shp")%>%
  st_as_sf() %>%
  st_transform(crs = crs(ANO.all))

reg <- st_read("C:/R projects github/ecRxiv_functional-plant-indicators/indicators/NO_FUNC_001-004/data/spatial/regions.shp")%>%
  st_as_sf() %>%
  st_transform(crs = crs(ANO.all))

# change region names to something R-friendly
reg$region
reg$region <- c("Northern Norway","Central Norway","Eastern Norway","Western Norway","Southern Norway")

regnor <- st_intersection(reg,nor)

res.ANO = st_join(res.ANO, regnor, left = TRUE)

# make long version of the scaled value part
res.ANO.long <-
res.ANO %>%
pivot_longer(
cols = c("CC1","CC2","SS1","SS2","RR1","RR2","Light1","Light2","Moist1","Moist2","pH1","pH2","Nitrogen1","Nitrogen2","Phosphorus1","Phosphorus2","Grazing_mowing1","Grazing_mowing2","Soil_disturbance1","Soil_disturbance2","Heat_requirement2"),
names_to = "fp_ind",
values_to = "scaled_value",
values_drop_na = FALSE
)

# add original values as well
res.ANO.long <-
res.ANO.long %>% add_column(original = results.ANO[['original']] %>%
pivot_longer(
cols = c("CC1","CC2","SS1","SS2","RR1","RR2","Light1","Light2","Moist1","Moist2","pH1","pH2","Nitrogen1","Nitrogen2","Phosphorus1","Phosphorus2","Grazing_mowing1","Grazing_mowing2","Soil_disturbance1","Soil_disturbance2","Heat_requirement2"),
names_to = NULL,
values_to = "original",
values_drop_na = FALSE
) %>%
pull(original)
)

```

### Calculating national and regional indices for the single plant indicators and for the overall functional plant community indicator

We can calculate national and region-wise means and their related standard errors. But note that calculating a simple mean would be inappropriate for these data. This is because:
(i) the scaled data are bound between 0 and 1, and thus follow a beta-distribution rather than a Gaussian one, and
(ii) the ANO dataset has a nested structure

Therefore, we need to (i) use a beta-model, that (ii) can account for the nested structure of the data.
Here, we apply the following function using either a glmmTMB null-model with a beta-distribution, logit link, and the nesting as a random intercept, or a simple betareg null-model with logit link if the nesting is not extensive enough for a mixed model.
```{r}
expit <- function(L) exp(L) / (1+exp(L)) # since the beta-models use a logit link, we need to calculate the estimates back to the identity scale

# the function performs a glmmTMB if there's >= 5 random levels in the nesting structure
# if that is not the case, then the function performs a betareg if theres >= 2 observations
# if that is not the case either, then the function returns the value of the single observation with NA standard error

indmean.beta <- function(df) {

  st_geometry(df) <- NULL
  colnames(df) <- c("y","ran")
  
  if ( nrow(df[!is.na(df[,1]),]) >= 2 ) {
    
    if ( length(unique(df[!is.na(df[,1]),2])) >=5 ) {
      
      mod1 <- glmmTMB(y ~ 1 +(1|ran), family=beta_family(), data=df)
      
      return(c(
        expit(summary( mod1 )$coefficients$cond[1]),
        
        expit( summary( mod1 )$coefficients$cond[1] + 
                 summary( mod1 )$coefficients$cond[2] )-
          expit( summary( mod1 )$coefficients$cond[1] ),
        
        nrow(df[!is.na(df$y),]),
        summary( mod1 )$coefficients$cond[1],
        summary( mod1 )$coefficients$cond[2]
      ))
      
    } else {
      
      mod2 <- betareg(y ~ 1, data=df)
      
      return(c(
        expit(summary( mod2 )$coefficients$mean[1]),
        expit( summary( mod2 )$coefficients$mean[1] + 
                 summary( mod2 )$coefficients$mean[2] )-
          expit( summary( mod2 )$coefficients$mean[1] ),
        nrow(df[!is.na(df$y),]),
        summary( mod2 )$coefficients$mean[1],
        summary( mod2 )$coefficients$mean[2]
      ))
      
    }
    
  } else {
    
    return(c(df$y,NA,1,NA,NA))
    
  }

}

```


```{r}


```









### Ecosystem sub-types {#ecosystem-sub-types-fpiw}
And we can show the resulting scaled values as Violin plots for each indicator and main ecosystem type 
```{r fpiw-plot-maintype, message=FALSE, warning=FALSE, fig.cap="Scaled vegetation indicator values for wetlands. 1 = cases where variable is lower than the reference value- 2 = cases where variablei is higher than the reference value.", out.width='100%', echo=F}
# making the plot
ggplot(res.wetland, aes(x=factor(hovedtype_rute), y=scaled_value, fill=fp_ind)) + 
  geom_hline(yintercept=0.6, linetype="dashed") + 
  geom_violin() +
#  geom_boxplot(width=0.2, color="grey") +
  geom_point(size=0.7, shape=16, color="grey") +
  facet_wrap(~factor(fp_ind,levels=c("Light1","Moist1","pH1","Nitrogen1","Light2","Moist2","pH2","Nitrogen2")), ncol = 4) + 
  xlab("Wetland ecosystem sub-type") + 
  ylab("Scaled indicator value") 
```

This figure is a bit easier to read if we remove the sub-types with very few data points:
```{r fpiw-plot-maintype-v2, message=FALSE, warning=FALSE, fig.cap="Scaled vegetation indicator values for the four most common sub-types of wetland. 1 = cases where variable is lower than the reference value- 2 = cases where variablei is higher than the reference value.", out.width='100%'}
ggplot(res.wetland[res.wetland$hovedtype_rute %in% c("V1", "V2", "V3", "V4"),], aes(x=factor(hovedtype_rute), y=scaled_value, fill=fp_ind)) + 
  geom_hline(yintercept=0.6, linetype="dashed") + 
  geom_violin() +
#  geom_boxplot(width=0.2, color="grey") +
  geom_point(size=0.7, shape=16, color="grey") +
  facet_wrap(~factor(fp_ind,levels=c("Light1","Moist1","pH1","Nitrogen1","Light2","Moist2","pH2","Nitrogen2")), ncol = 4) + 
  xlab("Wetland ecosystem sub-type") + 
  ylab("Scaled indicator value") +
  guides(fill='none')
```


### Indicator index maps
We can also show the results as a map, for instance for pH1 (the lower pH indicator), either by directly plotting the data onto the map...

```{r ph-lower-map-fpiw, warning=FALSE, message = FALSE, fig.cap="Functional plant indicator values for pH (lower) in wetlands."}
#### scaled value maps ####
# keep wide format and add geometry again
res.wetland2 <- results.wetland[['2-sided']]
st_geometry(res.wetland2) <- st_geometry(ANO.wetland)

#nor <- readRDS('P:/41201785_okologisk_tilstand_2022_2023/data/rds/norway_outline.RDS')%>%
#  st_as_sf() %>%
#  st_transform(crs = crs(ANO.geo))

nor <- st_read("data/outlineOfNorway_EPSG25833.shp")%>%
  st_as_sf() %>%
  st_transform(crs = crs(ANO.geo))

#reg <- st_read("P:/41201785_okologisk_tilstand_2022_2023/data/regioner/regNorway_wgs84 - MERGED.shp")%>%
#  st_as_sf() %>%
#  st_transform(crs = crs(ANO.geo))

reg <- st_read("data/regions.shp")%>%
  st_as_sf() %>%
  st_transform(crs = crs(ANO.geo))

# change region names to something R-friendly
reg$region
reg$region <- c("Northern Norway","Central Norway","Eastern Norway","Western Norway","Southern Norway")

regnor <- st_intersection(reg,nor)


## scaled value maps
# pH1 (lower indicator)
tm_shape(regnor) +
  tm_fill('GID_0', labels="", title="", legend.show = FALSE) + 
  tm_borders() +
  tm_shape(res.wetland2) +
  tm_dots('pH1',midpoint=NA, palette=tmaptools::get_brewer_pal("YlOrRd", 7, plot = FALSE), scale=1, legend.show = FALSE) + # 
  tm_layout(main.title = "pH (lower), wetland",legend.position = c("right", "bottom"), main.title.size=1.2) + 
  tm_add_legend(type = "fill", 
                col = c(tmaptools::get_brewer_pal("YlOrRd", 5, plot = FALSE),'grey'),
                labels = c("0.0 - 0.2", "0.2 - 0.4", "0.4 - 0.6", 
                           "0.6 - 0.8", "0.8 - 1.0", "NA"),
                title = "index values")


```

...but here the colors and values of the data points on the map are hard to make out.

### Regions - maps and statistics

```{r ph-map-fpiw, fig.cap="Mean index value by region for the lower pH indicator (i.e. index shows deviations towards a more acidic environment). Numbers in grey fields show the number of observations in the respective region."}

res.wetland2 = st_join(res.wetland2, regnor, left = TRUE)

regnor <- regnor %>%
  mutate(
    pH1.reg.mean = c(indmean.beta(df=res.wetland2[res.wetland2$region=="Northern Norway",c("pH1","ano_flate_id")])[1],
            indmean.beta(df=res.wetland2[res.wetland2$region=="Central Norway",c("pH1","ano_flate_id")])[1],
            indmean.beta(df=res.wetland2[res.wetland2$region=="Eastern Norway",c("pH1","ano_flate_id")])[1],
            indmean.beta(df=res.wetland2[res.wetland2$region=="Western Norway",c("pH1","ano_flate_id")])[1],
            indmean.beta(df=res.wetland2[res.wetland2$region=="Southern Norway",c("pH1","ano_flate_id")])[1]
    ),
    pH1.reg.se = c(indmean.beta(df=res.wetland2[res.wetland2$region=="Northern Norway",c("pH1","ano_flate_id")])[2],
            indmean.beta(df=res.wetland2[res.wetland2$region=="Central Norway",c("pH1","ano_flate_id")])[2],
            indmean.beta(df=res.wetland2[res.wetland2$region=="Eastern Norway",c("pH1","ano_flate_id")])[2],
            indmean.beta(df=res.wetland2[res.wetland2$region=="Western Norway",c("pH1","ano_flate_id")])[2],
            indmean.beta(df=res.wetland2[res.wetland2$region=="Southern Norway",c("pH1","ano_flate_id")])[2]
    ),
    pH1.reg.n = c(nrow(res.wetland2[res.wetland2$region=="Northern Norway" & !is.na(res.wetland2$pH1),]),
            nrow(res.wetland2[res.wetland2$region=="Central Norway" & !is.na(res.wetland2$pH1),]),
            nrow(res.wetland2[res.wetland2$region=="Eastern Norway" & !is.na(res.wetland2$pH1),]),
            nrow(res.wetland2[res.wetland2$region=="Western Norway" & !is.na(res.wetland2$pH1),]),
            nrow(res.wetland2[res.wetland2$region=="Southern Norway" & !is.na(res.wetland2$pH1),])
    )
  )

# Colour palettes
myCol <- "RdYlGn"

## scaled value maps for pH1 (lower indicator)
# mean
tm_shape(regnor) +
  tm_polygons(col="pH1.reg.mean", title="pH (lower), mean", style="fixed", 
              palette=myCol,
              breaks = seq(0,1,.2)) +
  tm_text("pH1.reg.n",col="black",bg.color="grey")
```


We can also plot the uncertainty, here represented as the spatial variation:
```{r ph-se-fpiw, fig.cap="Standard error to the mean index value by region for the lower pH indicator. Numbers in grey fields show the number of observations in the respective region."}

tm_shape(regnor) +
  tm_polygons(col="pH1.reg.se", title="pH (lower), sd", style="quantile", palette=get_brewer_pal(palette="OrRd", n=5, plot=FALSE)) +
  tm_text("pH1.reg.n",col="black",bg.color="grey")

```


### Unscaled values vs. reference
We can also compare the unscaled values to the reference distribution in order to identify ecosystem types and functional plant indicators showing a deviation from the expectation. Since pH and nitrogen show some deviation in the lower indicator we exemplify this with these two indicators for unscaled values. (Only the code for the first figure is shown).

```{r pH-distcomp-fpiw, fig.cap="Comparing the reference and variable distribution for the pH indicator in ecosystem sub-type V1."}
    #summary(res.wetland$kartleggingsenhet_1m2)
    #length(unique(res.wetland$kartleggingsenhet_1m2))
# 16 NiN-types to plot
    #colnames(wetland.ref.cov[['Soil_reaction_pH']])

### pH
par(mfrow=c(2,4))
## V1s
# V1-C-1
plot(density( as.matrix(wetland.ref.cov[['Soil_reaction_pH']][,c("V1-C1a","V1-C1b","V1-C1c","V1-C1d","V1-C1e")]) ,na.rm=T),
     xlim=c(1,7), type="l", main='V1-C1',xlab='pH value')
points(density(res.wetland[res.wetland$fp_ind=="pH1" & res.wetland$fp_ind=="pH1" & res.wetland$kartleggingsenhet_1m2=="V1-C-1",]$original,na.rm=T),
       type="l", col="red")
points(res.wetland[res.wetland$fp_ind=="pH1" & res.wetland$fp_ind=="pH1" & res.wetland$kartleggingsenhet_1m2=="V1-C-1",]$original,
       rep(0,length(res.wetland[res.wetland$fp_ind=="pH1" & res.wetland$fp_ind=="pH1" & res.wetland$kartleggingsenhet_1m2=="V1-C-1",]$original)),
       col="red")

# V1-C-2
plot(density( as.matrix(wetland.ref.cov[['Soil_reaction_pH']][,c("V1-C2a","V1-C2b","V1-C2c","V1-C2d")]) ,na.rm=T),
     xlim=c(1,7), type="l", main='V1-C2',xlab='pH value')
points(density(res.wetland[res.wetland$fp_ind=="pH1" & res.wetland$kartleggingsenhet_1m2=="V1-C-2",]$original,na.rm=T),
       type="l", col="red")
points(res.wetland[res.wetland$fp_ind=="pH1" & res.wetland$kartleggingsenhet_1m2=="V1-C-2",]$original,
       rep(0,length(res.wetland[res.wetland$fp_ind=="pH1" & res.wetland$kartleggingsenhet_1m2=="V1-C-2",]$original)),
       col="red")

# V1-C-3
plot(density( as.matrix(wetland.ref.cov[['Soil_reaction_pH']][,c("V1-C3a","V1-C3b","V1-C3c","V1-C3d")]) ,na.rm=T),
     xlim=c(1,7), type="l", main='V1-C3',xlab='pH value')
points(density(res.wetland[res.wetland$fp_ind=="pH1" & res.wetland$kartleggingsenhet_1m2=="V1-C-3",]$original,na.rm=T),
       type="l", col="red")
points(res.wetland[res.wetland$fp_ind=="pH1" & res.wetland$kartleggingsenhet_1m2=="V1-C-3",]$original,
       rep(0,length(res.wetland[res.wetland$fp_ind=="pH1" & res.wetland$kartleggingsenhet_1m2=="V1-C-3",]$original)),
       col="red")

# V1-C-4
plot(density( as.matrix(wetland.ref.cov[['Soil_reaction_pH']][,c("V1-C4a","V1-C4b","V1-C4c","V1-C4d","V1-C4e","V1-C4f","V1-C4g","V1-C4h")]) ,na.rm=T),
     xlim=c(1,7), type="l", main='V1-C4',xlab='pH value')
points(density(res.wetland[res.wetland$fp_ind=="pH1" & res.wetland$kartleggingsenhet_1m2=="V1-C-4",]$original,na.rm=T),
       type="l", col="red")
points(res.wetland[res.wetland$fp_ind=="pH1" & res.wetland$kartleggingsenhet_1m2=="V1-C-4",]$original,
       rep(0,length(res.wetland[res.wetland$fp_ind=="pH1" & res.wetland$kartleggingsenhet_1m2=="V1-C-4",]$original)),
       col="red")

# V1-C-5
plot(density( as.matrix(wetland.ref.cov[['Soil_reaction_pH']][,c("V1-C5")]) ,na.rm=T),
     xlim=c(1,7), type="l", main='V1-C5',xlab='pH value')
points(density(res.wetland[res.wetland$fp_ind=="pH1" & res.wetland$kartleggingsenhet_1m2=="V1-C-5",]$original,na.rm=T),
       type="l", col="red")
points(res.wetland[res.wetland$fp_ind=="pH1" & res.wetland$kartleggingsenhet_1m2=="V1-C-5",]$original,
       rep(0,length(res.wetland[res.wetland$fp_ind=="pH1" & res.wetland$kartleggingsenhet_1m2=="V1-C-5",]$original)),
       col="red")

# V1-C-6
plot(density( as.matrix(wetland.ref.cov[['Soil_reaction_pH']][,c("V1-C6a","V1-C6b")]) ,na.rm=T),
     xlim=c(1,7), type="l", main='V1-C6',xlab='pH value')
points(density(res.wetland[res.wetland$fp_ind=="pH1" & res.wetland$kartleggingsenhet_1m2=="V1-C-6",]$original,na.rm=T),
       type="l", col="red")
points(res.wetland[res.wetland$fp_ind=="pH1" & res.wetland$kartleggingsenhet_1m2=="V1-C-6",]$original,
       rep(0,length(res.wetland[res.wetland$fp_ind=="pH1" & res.wetland$kartleggingsenhet_1m2=="V1-C-6",]$original)),
       col="red")

# V1-C-7
plot(density( as.matrix(wetland.ref.cov[['Soil_reaction_pH']][,c("V1-C7a","V1-C7b")]) ,na.rm=T),
     xlim=c(1,7), type="l", main='V1-C7',xlab='pH value')
points(density(res.wetland[res.wetland$fp_ind=="pH1" & res.wetland$kartleggingsenhet_1m2=="V1-C-7",]$original,na.rm=T),
       type="l", col="red")
points(res.wetland[res.wetland$fp_ind=="pH1" & res.wetland$kartleggingsenhet_1m2=="V1-C-7",]$original,
       rep(0,length(res.wetland[res.wetland$fp_ind=="pH1" & res.wetland$kartleggingsenhet_1m2=="V1-C-7",]$original)),
       col="red")

# V1-C-8
plot(density( as.matrix(wetland.ref.cov[['Soil_reaction_pH']][,c("V1-C8a","V1-C8b")]) ,na.rm=T),
     xlim=c(1,7), type="l", main='V1-C8',xlab='pH value')
points(density(res.wetland[res.wetland$fp_ind=="pH1" & res.wetland$kartleggingsenhet_1m2=="V1-C-8",]$original,na.rm=T),
       type="l", col="red")
points(res.wetland[res.wetland$fp_ind=="pH1" & res.wetland$kartleggingsenhet_1m2=="V1-C-8",]$original,
       rep(0,length(res.wetland[res.wetland$fp_ind=="pH1" & res.wetland$kartleggingsenhet_1m2=="V1-C-8",]$original)),
       col="red")
```

```{r ph-distcomp2-fpiw, fig.cap="Comparing the reference and variable distribution for the pH indicator in ecosystem sub-types other than V1.", echo=FALSE}
par(mfrow=c(2,4))
## V2s
# V2-C-1
plot(density( as.matrix(wetland.ref.cov[['Soil_reaction_pH']][,c("V2-C1a","V2-C1b")]) ,na.rm=T),
     xlim=c(1,7), type="l", main='V2-C1',xlab='pH value')
points(density(res.wetland[res.wetland$fp_ind=="pH1" & res.wetland$fp_ind=="pH1" & res.wetland$kartleggingsenhet_1m2=="V2-C-1",]$original,na.rm=T),
       type="l", col="red")
points(res.wetland[res.wetland$fp_ind=="pH1" & res.wetland$fp_ind=="pH1" & res.wetland$kartleggingsenhet_1m2=="V2-C-1",]$original,
       rep(0,length(res.wetland[res.wetland$fp_ind=="pH1" & res.wetland$fp_ind=="pH1" & res.wetland$kartleggingsenhet_1m2=="V2-C-1",]$original)),
       col="red")

# V2-C-2
plot(density( as.matrix(wetland.ref.cov[['Soil_reaction_pH']][,c("V2-C2a","V2-C2b")]) ,na.rm=T),
     xlim=c(1,7), type="l", main='V2-C2',xlab='pH value')
points(density(res.wetland[res.wetland$fp_ind=="pH1" & res.wetland$fp_ind=="pH1" & res.wetland$kartleggingsenhet_1m2=="V2-C-2",]$original,na.rm=T),
       type="l", col="red")
points(res.wetland[res.wetland$fp_ind=="pH1" & res.wetland$fp_ind=="pH1" & res.wetland$kartleggingsenhet_1m2=="V2-C-2",]$original,
       rep(0,length(res.wetland[res.wetland$fp_ind=="pH1" & res.wetland$fp_ind=="pH1" & res.wetland$kartleggingsenhet_1m2=="V2-C-2",]$original)),
       col="red")

# V2-C-3
plot(density( as.matrix(wetland.ref.cov[['Soil_reaction_pH']][,c("V2-C3a","V2-C3b")]) ,na.rm=T),
     xlim=c(1,7), type="l", main='V2-C3',xlab='pH value')
points(density(res.wetland[res.wetland$fp_ind=="pH1" & res.wetland$fp_ind=="pH1" & res.wetland$kartleggingsenhet_1m2=="V2-C-3",]$original,na.rm=T),
       type="l", col="red")
points(res.wetland[res.wetland$fp_ind=="pH1" & res.wetland$fp_ind=="pH1" & res.wetland$kartleggingsenhet_1m2=="V2-C-3",]$original,
       rep(0,length(res.wetland[res.wetland$fp_ind=="pH1" & res.wetland$fp_ind=="pH1" & res.wetland$kartleggingsenhet_1m2=="V2-C-3",]$original)),
       col="red")

## V3s
# V3-C-1
plot(density( as.matrix(wetland.ref.cov[['Soil_reaction_pH']][,c("V3-C1a","V3-C1b","V3-C1c","V3-C1d","V3-C1e")]) ,na.rm=T),
     xlim=c(1,7), type="l", main='V3-C1',xlab='pH value')
points(density(res.wetland[res.wetland$fp_ind=="pH1" & res.wetland$fp_ind=="pH1" & res.wetland$kartleggingsenhet_1m2=="V3-C-1",]$original,na.rm=T),
       type="l", col="red")
points(res.wetland[res.wetland$fp_ind=="pH1" & res.wetland$fp_ind=="pH1" & res.wetland$kartleggingsenhet_1m2=="V3-C-1",]$original,
       rep(0,length(res.wetland[res.wetland$fp_ind=="pH1" & res.wetland$fp_ind=="pH1" & res.wetland$kartleggingsenhet_1m2=="V3-C-1",]$original)),
       col="red")

# V3-C-2
plot(density( as.matrix(wetland.ref.cov[['Soil_reaction_pH']][,c("V3-C2")]) ,na.rm=T),
     xlim=c(1,7), type="l", main='V3-C2',xlab='pH value')
points(density(res.wetland[res.wetland$fp_ind=="pH1" & res.wetland$fp_ind=="pH1" & res.wetland$kartleggingsenhet_1m2=="V3-C-2",]$original,na.rm=T),
       type="l", col="red")
points(res.wetland[res.wetland$fp_ind=="pH1" & res.wetland$fp_ind=="pH1" & res.wetland$kartleggingsenhet_1m2=="V3-C-2",]$original,
       rep(0,length(res.wetland[res.wetland$fp_ind=="pH1" & res.wetland$fp_ind=="pH1" & res.wetland$kartleggingsenhet_1m2=="V3-C-2",]$original)),
       col="red")

## V4s
# V4-C-2
plot(density( as.matrix(wetland.ref.cov[['Soil_reaction_pH']][,c("V4-C2")]) ,na.rm=T),
     xlim=c(1,7), type="l", main='V4-C2',xlab='pH value')
points(density(res.wetland[res.wetland$fp_ind=="pH1" & res.wetland$fp_ind=="pH1" & res.wetland$kartleggingsenhet_1m2=="V4-C-2",]$original,na.rm=T),
       type="l", col="red")
points(res.wetland[res.wetland$fp_ind=="pH1" & res.wetland$fp_ind=="pH1" & res.wetland$kartleggingsenhet_1m2=="V4-C-2",]$original,
       rep(0,length(res.wetland[res.wetland$fp_ind=="pH1" & res.wetland$fp_ind=="pH1" & res.wetland$kartleggingsenhet_1m2=="V4-C-2",]$original)),
       col="red")


## V8s
# V8-C-1
plot(density( as.matrix(wetland.ref.cov[['Soil_reaction_pH']][,c("V8-C1")]) ,na.rm=T),
     xlim=c(1,7), type="l", main='V8-C1',xlab='pH value')
#points(density(res.wetland[res.wetland$fp_ind=="pH1" & res.wetland$fp_ind=="pH1" & res.wetland$kartleggingsenhet_1m2=="V8-C-1",]$original,na.rm=T),
#       type="l", col="red")
points(res.wetland[res.wetland$fp_ind=="pH1" & res.wetland$fp_ind=="pH1" & res.wetland$kartleggingsenhet_1m2=="V8-C-1",]$original,
       rep(0,length(res.wetland[res.wetland$fp_ind=="pH1" & res.wetland$fp_ind=="pH1" & res.wetland$kartleggingsenhet_1m2=="V8-C-1",]$original)),
       col="red")

# V8-C-2
plot(density( as.matrix(wetland.ref.cov[['Soil_reaction_pH']][,c("V8-C2")]) ,na.rm=T),
     xlim=c(1,7), type="l", main='V8-C2',xlab='pH value')
#points(density(res.wetland[res.wetland$fp_ind=="pH1" & res.wetland$fp_ind=="pH1" & res.wetland$kartleggingsenhet_1m2=="V8-C-2",]$original,na.rm=T),
#       type="l", col="red")
points(res.wetland[res.wetland$fp_ind=="pH1" & res.wetland$fp_ind=="pH1" & res.wetland$kartleggingsenhet_1m2=="V8-C-2",]$original,
       rep(0,length(res.wetland[res.wetland$fp_ind=="pH1" & res.wetland$fp_ind=="pH1" & res.wetland$kartleggingsenhet_1m2=="V8-C-2",]$original)),
       col="red")
legend("topleft", legend=c("reference","field data"), pch=c(NA,1), lty=1, col=c("black","red"))
```

```{r n-distcomp-fpiw, fig.cap="Comparing the reference and variable distribution for the nitrogen affiliation indicator in ecosystem sub-type V1.", echo=F}
### Nitrogen
par(mfrow=c(2,4))
## V1s
# V1-C-1
plot(density( as.matrix(wetland.ref.cov[['Nitrogen']][,c("V1-C1a","V1-C1b","V1-C1c","V1-C1d","V1-C1e")]) ,na.rm=T),
     xlim=c(1,7), type="l", main='V1-C1',xlab='Nitrogen value')
points(density(res.wetland[res.wetland$fp_ind=="Nitrogen1" & res.wetland$fp_ind=="Nitrogen1" & res.wetland$kartleggingsenhet_1m2=="V1-C-1",]$original,na.rm=T),
       type="l", col="red")
points(res.wetland[res.wetland$fp_ind=="Nitrogen1" & res.wetland$fp_ind=="Nitrogen1" & res.wetland$kartleggingsenhet_1m2=="V1-C-1",]$original,
       rep(0,length(res.wetland[res.wetland$fp_ind=="Nitrogen1" & res.wetland$fp_ind=="Nitrogen1" & res.wetland$kartleggingsenhet_1m2=="V1-C-1",]$original)),
       col="red")

# V1-C-2
plot(density( as.matrix(wetland.ref.cov[['Nitrogen']][,c("V1-C2a","V1-C2b","V1-C2c","V1-C2d")]) ,na.rm=T),
     xlim=c(1,7), type="l", main='V1-C2',xlab='Nitrogen value')
points(density(res.wetland[res.wetland$fp_ind=="Nitrogen1" & res.wetland$kartleggingsenhet_1m2=="V1-C-2",]$original,na.rm=T),
       type="l", col="red")
points(res.wetland[res.wetland$fp_ind=="Nitrogen1" & res.wetland$kartleggingsenhet_1m2=="V1-C-2",]$original,
       rep(0,length(res.wetland[res.wetland$fp_ind=="Nitrogen1" & res.wetland$kartleggingsenhet_1m2=="V1-C-2",]$original)),
       col="red")

# V1-C-3
plot(density( as.matrix(wetland.ref.cov[['Nitrogen']][,c("V1-C3a","V1-C3b","V1-C3c","V1-C3d")]) ,na.rm=T),
     xlim=c(1,7), type="l", main='V1-C3',xlab='Nitrogen value')
points(density(res.wetland[res.wetland$fp_ind=="Nitrogen1" & res.wetland$kartleggingsenhet_1m2=="V1-C-3",]$original,na.rm=T),
       type="l", col="red")
points(res.wetland[res.wetland$fp_ind=="Nitrogen1" & res.wetland$kartleggingsenhet_1m2=="V1-C-3",]$original,
       rep(0,length(res.wetland[res.wetland$fp_ind=="Nitrogen1" & res.wetland$kartleggingsenhet_1m2=="V1-C-3",]$original)),
       col="red")

# V1-C-4
plot(density( as.matrix(wetland.ref.cov[['Nitrogen']][,c("V1-C4a","V1-C4b","V1-C4c","V1-C4d","V1-C4e","V1-C4f","V1-C4g","V1-C4h")]) ,na.rm=T),
     xlim=c(1,7), type="l", main='V1-C4',xlab='Nitrogen value')
points(density(res.wetland[res.wetland$fp_ind=="Nitrogen1" & res.wetland$kartleggingsenhet_1m2=="V1-C-4",]$original,na.rm=T),
       type="l", col="red")
points(res.wetland[res.wetland$fp_ind=="Nitrogen1" & res.wetland$kartleggingsenhet_1m2=="V1-C-4",]$original,
       rep(0,length(res.wetland[res.wetland$fp_ind=="Nitrogen1" & res.wetland$kartleggingsenhet_1m2=="V1-C-4",]$original)),
       col="red")

# V1-C-5
plot(density( as.matrix(wetland.ref.cov[['Nitrogen']][,c("V1-C5")]) ,na.rm=T),
     xlim=c(1,7), type="l", main='V1-C5',xlab='Nitrogen value')
points(density(res.wetland[res.wetland$fp_ind=="Nitrogen1" & res.wetland$kartleggingsenhet_1m2=="V1-C-5",]$original,na.rm=T),
       type="l", col="red")
points(res.wetland[res.wetland$fp_ind=="Nitrogen1" & res.wetland$kartleggingsenhet_1m2=="V1-C-5",]$original,
       rep(0,length(res.wetland[res.wetland$fp_ind=="Nitrogen1" & res.wetland$kartleggingsenhet_1m2=="V1-C-5",]$original)),
       col="red")

# V1-C-6
plot(density( as.matrix(wetland.ref.cov[['Nitrogen']][,c("V1-C6a","V1-C6b")]) ,na.rm=T),
     xlim=c(1,7), type="l", main='V1-C6',xlab='Nitrogen value')
points(density(res.wetland[res.wetland$fp_ind=="Nitrogen1" & res.wetland$kartleggingsenhet_1m2=="V1-C-6",]$original,na.rm=T),
       type="l", col="red")
points(res.wetland[res.wetland$fp_ind=="Nitrogen1" & res.wetland$kartleggingsenhet_1m2=="V1-C-6",]$original,
       rep(0,length(res.wetland[res.wetland$fp_ind=="Nitrogen1" & res.wetland$kartleggingsenhet_1m2=="V1-C-6",]$original)),
       col="red")

# V1-C-7
plot(density( as.matrix(wetland.ref.cov[['Nitrogen']][,c("V1-C7a","V1-C7b")]) ,na.rm=T),
     xlim=c(1,7), type="l", main='V1-C7',xlab='Nitrogen value')
points(density(res.wetland[res.wetland$fp_ind=="Nitrogen1" & res.wetland$kartleggingsenhet_1m2=="V1-C-7",]$original,na.rm=T),
       type="l", col="red")
points(res.wetland[res.wetland$fp_ind=="Nitrogen1" & res.wetland$kartleggingsenhet_1m2=="V1-C-7",]$original,
       rep(0,length(res.wetland[res.wetland$fp_ind=="Nitrogen1" & res.wetland$kartleggingsenhet_1m2=="V1-C-7",]$original)),
       col="red")

# V1-C-8
plot(density( as.matrix(wetland.ref.cov[['Nitrogen']][,c("V1-C8a","V1-C8b")]) ,na.rm=T),
     xlim=c(1,7), type="l", main='V1-C8',xlab='Nitrogen value')
points(density(res.wetland[res.wetland$fp_ind=="Nitrogen1" & res.wetland$kartleggingsenhet_1m2=="V1-C-8",]$original,na.rm=T),
       type="l", col="red")
points(res.wetland[res.wetland$fp_ind=="Nitrogen1" & res.wetland$kartleggingsenhet_1m2=="V1-C-8",]$original,
       rep(0,length(res.wetland[res.wetland$fp_ind=="Nitrogen1" & res.wetland$kartleggingsenhet_1m2=="V1-C-8",]$original)),
       col="red")
```

```{r n-distcomp2-fpiw, fig.cap="Comparing the reference and variable distribution for the nitrogen affiliation indicator in ecosystem sub-types other than V1.", echo=F}
par(mfrow=c(2,4))
## V2s
# V2-C-1
plot(density( as.matrix(wetland.ref.cov[['Nitrogen']][,c("V2-C1a","V2-C1b")]) ,na.rm=T),
     xlim=c(1,7), type="l", main='V2-C1',xlab='Nitrogen value')
points(density(res.wetland[res.wetland$fp_ind=="Nitrogen1" & res.wetland$fp_ind=="Nitrogen1" & res.wetland$kartleggingsenhet_1m2=="V2-C-1",]$original,na.rm=T),
       type="l", col="red")
points(res.wetland[res.wetland$fp_ind=="Nitrogen1" & res.wetland$fp_ind=="Nitrogen1" & res.wetland$kartleggingsenhet_1m2=="V2-C-1",]$original,
       rep(0,length(res.wetland[res.wetland$fp_ind=="Nitrogen1" & res.wetland$fp_ind=="Nitrogen1" & res.wetland$kartleggingsenhet_1m2=="V2-C-1",]$original)),
       col="red")

# V2-C-2
plot(density( as.matrix(wetland.ref.cov[['Nitrogen']][,c("V2-C2a","V2-C2b")]) ,na.rm=T),
     xlim=c(1,7), type="l", main='V2-C2',xlab='Nitrogen value')
points(density(res.wetland[res.wetland$fp_ind=="Nitrogen1" & res.wetland$fp_ind=="Nitrogen1" & res.wetland$kartleggingsenhet_1m2=="V2-C-2",]$original,na.rm=T),
       type="l", col="red")
points(res.wetland[res.wetland$fp_ind=="Nitrogen1" & res.wetland$fp_ind=="Nitrogen1" & res.wetland$kartleggingsenhet_1m2=="V2-C-2",]$original,
       rep(0,length(res.wetland[res.wetland$fp_ind=="Nitrogen1" & res.wetland$fp_ind=="Nitrogen1" & res.wetland$kartleggingsenhet_1m2=="V2-C-2",]$original)),
       col="red")

# V2-C-3
plot(density( as.matrix(wetland.ref.cov[['Nitrogen']][,c("V2-C3a","V2-C3b")]) ,na.rm=T),
     xlim=c(1,7), type="l", main='V2-C3',xlab='Nitrogen value')
points(density(res.wetland[res.wetland$fp_ind=="Nitrogen1" & res.wetland$fp_ind=="Nitrogen1" & res.wetland$kartleggingsenhet_1m2=="V2-C-3",]$original,na.rm=T),
       type="l", col="red")
points(res.wetland[res.wetland$fp_ind=="Nitrogen1" & res.wetland$fp_ind=="Nitrogen1" & res.wetland$kartleggingsenhet_1m2=="V2-C-3",]$original,
       rep(0,length(res.wetland[res.wetland$fp_ind=="Nitrogen1" & res.wetland$fp_ind=="Nitrogen1" & res.wetland$kartleggingsenhet_1m2=="V2-C-3",]$original)),
       col="red")

## V3s
# V3-C-1
plot(density( as.matrix(wetland.ref.cov[['Nitrogen']][,c("V3-C1a","V3-C1b","V3-C1c","V3-C1d","V3-C1e")]) ,na.rm=T),
     xlim=c(1,7), type="l", main='V3-C1',xlab='Nitrogen value')
points(density(res.wetland[res.wetland$fp_ind=="Nitrogen1" & res.wetland$fp_ind=="Nitrogen1" & res.wetland$kartleggingsenhet_1m2=="V3-C-1",]$original,na.rm=T),
       type="l", col="red")
points(res.wetland[res.wetland$fp_ind=="Nitrogen1" & res.wetland$fp_ind=="Nitrogen1" & res.wetland$kartleggingsenhet_1m2=="V3-C-1",]$original,
       rep(0,length(res.wetland[res.wetland$fp_ind=="Nitrogen1" & res.wetland$fp_ind=="Nitrogen1" & res.wetland$kartleggingsenhet_1m2=="V3-C-1",]$original)),
       col="red")

# V3-C-2
plot(density( as.matrix(wetland.ref.cov[['Nitrogen']][,c("V3-C2")]) ,na.rm=T),
     xlim=c(1,7), type="l", main='V3-C2',xlab='Nitrogen value')
points(density(res.wetland[res.wetland$fp_ind=="Nitrogen1" & res.wetland$fp_ind=="Nitrogen1" & res.wetland$kartleggingsenhet_1m2=="V3-C-2",]$original,na.rm=T),
       type="l", col="red")
points(res.wetland[res.wetland$fp_ind=="Nitrogen1" & res.wetland$fp_ind=="Nitrogen1" & res.wetland$kartleggingsenhet_1m2=="V3-C-2",]$original,
       rep(0,length(res.wetland[res.wetland$fp_ind=="Nitrogen1" & res.wetland$fp_ind=="Nitrogen1" & res.wetland$kartleggingsenhet_1m2=="V3-C-2",]$original)),
       col="red")

## V4s
# V4-C-2
plot(density( as.matrix(wetland.ref.cov[['Nitrogen']][,c("V4-C2")]) ,na.rm=T),
     xlim=c(1,7), type="l", main='V4-C2',xlab='Nitrogen value')
points(density(res.wetland[res.wetland$fp_ind=="Nitrogen1" & res.wetland$fp_ind=="Nitrogen1" & res.wetland$kartleggingsenhet_1m2=="V4-C-2",]$original,na.rm=T),
       type="l", col="red")
points(res.wetland[res.wetland$fp_ind=="Nitrogen1" & res.wetland$fp_ind=="Nitrogen1" & res.wetland$kartleggingsenhet_1m2=="V4-C-2",]$original,
       rep(0,length(res.wetland[res.wetland$fp_ind=="Nitrogen1" & res.wetland$fp_ind=="Nitrogen1" & res.wetland$kartleggingsenhet_1m2=="V4-C-2",]$original)),
       col="red")

## V8s
# V8-C-1
plot(density( as.matrix(wetland.ref.cov[['Nitrogen']][,c("V8-C1")]) ,na.rm=T),
     xlim=c(1,7), type="l", main='V8-C1',xlab='Nitrogen value')
#points(density(res.wetland[res.wetland$fp_ind=="Nitrogen1" & res.wetland$fp_ind=="Nitrogen1" & res.wetland$kartleggingsenhet_1m2=="V8-C-1",]$original,na.rm=T),
#       type="l", col="red")
points(res.wetland[res.wetland$fp_ind=="Nitrogen1" & res.wetland$fp_ind=="Nitrogen1" & res.wetland$kartleggingsenhet_1m2=="V8-C-1",]$original,
       rep(0,length(res.wetland[res.wetland$fp_ind=="Nitrogen1" & res.wetland$fp_ind=="Nitrogen1" & res.wetland$kartleggingsenhet_1m2=="V8-C-1",]$original)),
       col="red")

# V8-C-2
plot(density( as.matrix(wetland.ref.cov[['Nitrogen']][,c("V8-C2")]) ,na.rm=T),
     xlim=c(1,7), type="l", main='V8-C2',xlab='Nitrogen value')
#points(density(res.wetland[res.wetland$fp_ind=="Nitrogen1" & res.wetland$fp_ind=="Nitrogen1" & res.wetland$kartleggingsenhet_1m2=="V8-C-2",]$original,na.rm=T),
#       type="l", col="red")
points(res.wetland[res.wetland$fp_ind=="Nitrogen1" & res.wetland$fp_ind=="Nitrogen1" & res.wetland$kartleggingsenhet_1m2=="V8-C-2",]$original,
       rep(0,length(res.wetland[res.wetland$fp_ind=="Nitrogen1" & res.wetland$fp_ind=="Nitrogen1" & res.wetland$kartleggingsenhet_1m2=="V8-C-2",]$original)),
       col="red")

legend("topleft", legend=c("reference","field data"), pch=c(NA,1), lty=1, col=c("black","red"))
```


## 10. Results

<!--# 

Repeat the final results here. Typically this is a map or table of indicator values.

This is typically where people will harvest data from, so make sure to include all relevant output here, but don't clutter this section with too much output either.

-->

## 11. Export file

<!--# 

Optional: Display the code (don't execute it) or the workflow for exporting the indicator values to file. Ideally the indicator values are exported as a georeferenced shape or raster file with indicators values, reference values and errors. You can also chose to export the raw (un-normalised or unscaled variable) as a seperate product. You should not save large sptaial output data on GitHub. You can use eval=FALSE to avoid code from being executed (example below - delete if not relevant) 

-->

```{r export}
#| eval: false
```
