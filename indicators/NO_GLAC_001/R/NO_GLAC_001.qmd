---
title: "Glacier area"
subtitle: "[NO_GLAC_001]"
format: 
  html:
    embed-resources: true
    code-fold: true
    toc: true
    toc-title: Contents
    toc-depth: 3
    smooth-scroll: true
execute: 
  cache: true
author:
  - name: Anders L. Kolstad
    email: anders.kolstad@nina.no
    affiliations:
      - id: myID
        name: Norwegian Institute for Nature Research 
date: May 15, 2025
callout-icon: false
lightbox: true
css: ../../../style.css
code-links:
      - text: Add a review
        icon: github
        href: https://github.com/NINAnor/ecRxiv
bibliography: references.bib
editor: 
  markdown: 
    wrap: 72
---

```{r setup}
#| include: false
library(knitr)
library(tidyverse)
library(kableExtra)
library(here)
library(sf)
library(ggridges)
library(ggpubr)
library(webr)
knitr::opts_chunk$set(echo = TRUE)
path <- here::here("indicators/NO_GLAC_001")
```

```{r source}
#| echo: false
source(here::here("_common.R"))
```

```{r}
#| echo: false
meta <- readxl::read_xlsx("../metadata.xlsx")
st <- meta |>
  filter(Variable == "status") |>
  pull(Value)
version <- meta |>
  filter(Variable == "Version") |>
  pull(Value)
auth <- meta |>
  filter(Variable == "authors") |>
  pull(Value)
year <- meta |>
  filter(Variable == "yearAdded") |>
  pull(Value)
id <- meta |>
  filter(Variable == "indicatorID") |>
  pull(Value)
name <- meta |>
  filter(Variable == "indicatorName") |>
  pull(Value)
url <- meta |>
  filter(Variable == "url") |>
  pull(Value)

meta <- meta |>
  mutate(Variable = case_match(Variable,
    "indicatorID" ~ "Indicator ID" ,
    "indicatorName" ~ "Indicator Name",
    "country" ~ "Country",
    "continent" ~ "Continent",
    "ECT" ~ "Ecosystem Condition Typology Class",
    "yearAdded" ~ "Year added",
    "yearLastUpdate" ~ "Last update",
    .default = Variable
   )
  ) |>
  filter(Variable != "authors")

```

<!--# The following parts are autogenerated. Do not edit. -->

```{r}
#| echo: false
#| results: asis
status(st)
```

::: {layout-ncol="2"}
> **Recomended citation**:
> `r paste(auth, " ", year, ". ", name, " (ID: ", id, ") ", "v. ", version, ". ecRxiv: ", url, sep="")`

> **Version**: `r version`
:::

```{=html}
<details>
<summary>Show metadata</summary>
```

```{r tbl-meta}
#| tbl-cap: 'Indicator metadata'
#| echo: false
#| warning: false

meta |>
  select(Variable, Value) |>
  kbl(col.names = NULL) 

```

</details>

::: {.callout-tip collapse="true"}
## Logg

<!--# Update this logg with short messages for each update -->

-   26 Mar. 2025 - Original PR
-   25 Apr. 2025 - New reference levels
-   15 May  2025 - revision following code review 
:::

<hr />

<!--# Document you work below.  -->

## 1. Summary

Glaciers represents important structural elements in alpine ecosystems,
providing melt water and local climate control. It is also a unique
nature type and habitat in itself, with few, but very specialised, species living on
or in association with the ice. Glaciers are permanently ice covered
areas and they are sensitive to climate change, especially climate
warming, which melts the ice. In Norway we have a rather detailed and
precise map of the glacier cover or extent from the period 1947-1985. Here I use
this data as a representation of the climatic reference condition (pre
climate warming), and compare this with an updated glacier cover map
from 2018-2019 to create a normalised ecosystem condition indicator. 
Glacier area and glacier area change is calculated for each unique combination of 
bioclimatic and geographical regions (refered to as _strata_). 
A threshold value (X~60~) have tentatively been defined as 60% remaining glacier 
area inside each EA with the interpretation that a 60% loss of glaciers inside
each strata represents a scenario where the ecological functions provided
by glaciers are clearly deteriorated.

Indicator uncertainty originates from two sources. Firste we introduce a
3% error in the glacier cover estimates, based on the reported uncertainties
in the mapping method. In practice we create a gaussian probability
distribution (*n* = 1000, sd = 0.03 × mean), rather than a point
estimate, to each strata. I then resample these probability distributions
for each stratum n times, with n equal to the area weight, and combine these
samples into a joint sample distribution for the next spatial
aggregation level. This also introduces the second type of uncertainty,
which is the spatial variation in indicator values across strata.

The indicator is ready to be used. Future updates will require new maps
of glacier cover in Norway, which is highly possible to produce from
satellite imagery.

I also include an analyses of the influence of using
different areal weight, and different strata definitions. This work
concludes that initial glacier extent should be used as area weights
rather than total mountain area, and that the modifiable area unit
problem is not having a very strong influence on the resulting
aggregated probabilities.

**Interpretation**: The indicator value represents the negative
ecological effect of melting glacier ice, as a mean across the strata. It
does NOT directly represent the area of remaining glacier ice.

**Simlified workflow**

1.  Import glacier cover maps from two time periods

2.  Import delineations for bioclimatic regions and geographical regions
    and intersect to create strata

3.  Import alpine ecosystem mask

4.  Compile spatial dataset where each strata has data on strata category,
    glacier area at two time points and total mountain area.

5.  Add 3% uncertainty to glacier cover estimates by replacing point
    estimate with a probability sample (n = 1000)

6.  Normalise variable at strata level by scaling, transforming and
    truncating.

7.  Make a weighted sample within strata and create a new, joint sampling
    distribution for a spatially aggregate indicator value for
    geographical regions.

8.  Similarly, aggregate spatially from geographical region to national
    level.

9.  Summarise national estimate and 50%CI in a table

## 2. About the underlying data

<!--# Describe the data you have used in more detail, it's origin, biases, availabilit ect.-->

I mainly make use of two datasets on glacier extent in Norway. One
covering the years 1947 to 1985 [@winsvold2014], and one covering
2018-2019 [@andreassen2022]. The first dataset is made to represent the
climatic reference condition (pre-climate change). It as a digitalised
version of the N50 map, made based on the interpretation of aerial
photos. The newer map is a classification based on Sentinel imagery. The
uncertainties in both maps is said to be 3% (interpreted here as sd =
mean × 0.03), but these are several generalisations embedded in this
single number.

### 2.1 Spatial and temporal resolution and extent

<!--# Describe the temporal and spatial resolution and extent of the data used -->

The data covers all of mainland Norway (defined here as the ecosystem
accounting area, EAA), and two time steps (see above).

### 2.2 Original units

<!--# What are the original units for the most relevant  variables in the data-->

The original data is a vector map. Early in the workflow, I summarise
these as summed area (m^2^) per strata.

### 2.3 Additional comments about the dataset

<!--# Text here -->

I know of no concrete plans to update the glacier cover map, but with
of remote sensing, this is indeed possible to to, and quite
easy as well probably.

#### 2.3.1 Instructions for citing, using and accessing data

<!--# Is the data openly available? If not, how can one access it? What are the key references to the datasets?   -->

The glacier cover maps are distributed under CC-BY 4.0. We have made a
simplified (less columns) version of the dataset available on github in
order to make the workflow more reproducible.

## 3. Indicator properties

### 3.1 Ecosystem Condition Typology Class (ECT)

Area of glaciers is categorised as describing a *C1 - Landscape and
seascape characteristic*. This puts emphasis in the role of glaciers as
a unique habitat type and a structural element in alpine ecosystems. The
indicator has previously been attributed to *A1 - Physical state
characteristics* due to the importance of melt water.

### 3.2 Ecosystem condition characteristic

### 3.3 Other standards

In the Norwegian standard [@nybø2017] I place the indicator under the
category *Landskapsøkologiske mønstre*.

### 3.4 Collinearities with other indicators

The indicator is in many ways unique, but will likely be collinear with
other indicators that are similarly affected by climate warming.

### 3.5 Impact factors

Glaciers are mainly affected by climate change, especially climate
warming [@zemp2025].

## 4. Reference condition and levels

### 4.1 Reference condition

The reference condition of mountain ecosystems are defined, in general
terms, as one with minimal human impact. For the climate, the definition
is more precisely defined as the time period 1961-1990, which is the
last 30 year normal period before climate change became really
prominent.

### 4.2 Reference levels

The reference level X~100~ is defined for each strat uniquely based on the glacier
extent in 1947-1985. X~0~ equates to an absence of glaciers.
X~60~ is defined as 60% loss of glaciers, and this value originated from expert opinion
and a discussion mainly between the author and with Erik Framstad. The reasoning is that
with 60% loss of glacier ice, the ecological functions provided by glaciers is 
reduced so much that we call the system deteriorated, or strongly modified. 
There is no empirical evidence to back this up, and that is at least partly
because the effect that glaciers have on ecosystem condition as many-faceted.
We base our estimate on a 100 year time span for natural variation, which exludes
from our evaluation the fact that most glaciers in Norway were melted away in the 
warm period between 7500 and 6000 year before present.

```{r X60}
scalar <- 0.4
```



#### 4.2.1 Spatial resolution and validity

The reference levels are defined for each strata, and can therefore only be
used to normalise variables at that scale. However, reference levels can
easily be recalculated for any spatial scale, as I have also done here.
When testing out alternative aggregation pathways I had to create new
reference levels for larger regions.

## 5. Uncertainties

There is some uncertainty in the mapping method, and this is said to be
3% [@andreassen2022]. There is also some uncertainty, or at least some arbitrariness, in
how X~60~ is defined as 60% of X~100~.

## 6. References

::: {#refs}
:::

## 7. Datasets

### 7.1 Dataset A - Glacier cover 1947-1985

This data is based on a combination of landsat imagery and digitized
topographic maps [@winsvold2014]. We use this map as our reference
condition and assume this glacier cover represents the climatic period
1961-1990.

The dataset is manually downloaded.

URL: <https://nve.brage.unit.no/nve-xmlui/handle/11250/2831053>

```{r import1}
#| eval: false
#| code-summary: "Structure and cache historic glacier data"
path1 <- paste0(path, "/data/cryoclim_GAO_NO_1947_1985_UTM_33N/cryoclim_GAO_NO_1947_1985_UTM_33N.shp")
dat_old <- sf::read_sf(path1) |>
  select(areal_km2)
saveRDS(dat_old, paste0(path, "/data/glacial_extent_old.rds"))
```

```{r readCache1}
#| code-summary: "Read data"
dat_old <- readRDS(paste0(path, "/data/glacial_extent_old.rds"))
```

### 7.2 Dataset B - Glacier cover 2018-2019

This is the map of glacier cover measured in the period 2018-2019
[@andreassen2022].

URL: <https://nve.brage.unit.no/nve-xmlui/handle/11250/2836926>

```{r import2}
#| eval: false
#| code-summary: "Structure and cache modern glacier data"
path2 <- paste0(path, "/data/GlacierAreaOutline_NO_2018_2019_N/GlacierAreaOutline_2018_2019_N.shp")

dat_new <- sf::read_sf(path2) |>
  select(areal_km2)
saveRDS(dat_new, paste0(path, "/data/glacial_extent_new.rds"))
```

```{r readCache2}
#| code-summary: "Read data"
dat_new <- readRDS(paste0(path, "/data/glacial_extent_new.rds"))
```

### 7.3 Dataset C - Geographical regions

I import a delineation of five geographical regions in Norway that I
will use as an intermediate aggregation level and for defining strata.

```{r greg2}
#| code-fold: true
#| code-summary: "Importing geographical regions"

greg <- readRDS(paste0(path, "/data/regions.rds")) |>
  mutate(region = case_when(
    id == 3 ~ "Oestlandet",
    .default = region
  ))

```

### 7.4 Dataset D - Bioclimatic regions

Here I import a map dataset of bioclimatic zones and sections for Norway
[@bakkestuen2008]. The data licence is unknown, but we have the authors
permission to use the data (Bakkestuen, *pers. com.*). There is,
however, a [public WMS
service](https://kartkatalog.geonorge.no/metadata/66f09e22-23a4-43c6-a0df-426d2b317890),
but I don't known if the data is downloadable anywhere.

I combine the zones (related to heat sums and the north-south gradient)
and sections (related to oceanity and the west-east gradient) into
regions. There are 24 regions, but I will combine some zones and
sections to reduce this amount. Since there are few glaciers in
continental areas I will combine sections 4 and 5, since we don't need
that high resolution in the strata here. Similarly, I will combine the
warmer zones 1 and 2. The total and relative area of each bioclimatic region is shown
in @fig-sonerOgSeksjoner and @fig-sonerOgSeksjonerPie, respectively.

```{r makeReg}
#| eval: false
#| code-summary: 'Create bioclimatic regions map'

# file path to locally stored data
pathD <- "R:/GeoSpatialData/BiogeographicalRegions/Norway_PCA_klima/Original/20170614_Bioklima/20170614_Bioklima.gdb"

# read in the data and convert to tibbles for easy joins
soner <- sf::read_sf(pathD, layer = "Soner2017") |> 
  as_tibble() |>
  mutate(Sone = case_when(
    Sone_kode %in% c("6SO-1", "6SO-2") ~ "6SO-1-2",
    .default = Sone_kode
  ))

# unique(soner$Sone) # where is the middle and high alpine sone?
# I checked the WMS data and there the alpine sones are all combined
# I check the extents against the geographical region map to ensure no big data holes
# and it looks ok. 

#soner |>
#  mutate(area = st_area(Shape)) |>
#  summarise(area = sum(area)/10^6) # 351 402 [km^2]
#
#greg |>
#  mutate(area = st_area(geometry)) |>
#  summarise(area = sum(area)/10^6) # 325 462.2 [km^2]

seksjoner <- sf::read_sf(pathD, layer = "Seksjoner2017") |> 
  as_tibble() |>
  mutate(Seksjon = case_when(
    Seksjon_ko %in% c("6SE-4", "6SE-5") ~ "6SE-4-5",
    .default = Seksjon_ko
  ))

# unique(seksjoner$Seksjon)

# join based on SSB IDs and convert to sf object again
BCreg <- dplyr::left_join(soner , seksjoner |> select(-Shape), by = join_by(SSBID)) |>
  mutate(BCregion = paste(Seksjon, Sone)) |>
  sf::st_as_sf() |>
  select(SSBID,
  Sone,
  Seksjon,
  BCregion) |>
  st_transform(st_crs(greg))

```

```{r makeFig}
#| eval: false
#| code-summary: 'Make figure'
BCreg |>
  ggplot(aes(x = Sone, fill = BCregion)) +
  geom_bar() +
  facet_grid(Seksjon ~ Sone, scales = "free") +
  guides(fill = "none") +
  theme(axis.text.x = element_blank(),
    axis.title.x.bottom = element_blank()) +
  labs(y = "km-2")
ggsave("../img/bcreg.png")

# amke pie chart
png("../img/bcregPie.png", width = 1480, height = 1480)
BCreg |>
  as_tibble() |>
  webr::PieDonut(aes(Sone, Seksjon),
                 ratioByGroup=FALSE,
                 labelposition=1,
                 r0=0,
                 r1 = 0.8,
                 r2 = 1.2,
                 showPieName = F,
                 pieLabelSize = 10,
                 donutLabelSize = 8)
dev.off()
```

```{r fig-sonerOgSeksjoner}
#| fig-cap: "Distribution of area within each combination of bioclimatic zone and section (i.e. each bioclimatic region). Zones (SE, rows) range from 1 (boreonemoral) to 5 (alpine), and sections (SO, columns) range from 1 (strongly oceanic) to 5 (contintal)."

knitr::include_graphics("../img/bcreg.png")
```


```{r fig-sonerOgSeksjonerPie}
#| fig-cap: "Relative distribution of area within each combination of bioclimatic zone and section (i.e. each bioclimatic region). Zones (SE) range from 1 (boreonemoral) to 5 (alpine), and sections (SO) range from 1 (strongly oceanic) to 5 (contintal)."
#| fig-width: 12

knitr::include_graphics("../img/bcregPie.png")
```

```{r}
#| eval: false
#| code-fold: true
#| code-summary: "Union and cache bioclimatic region data"

BCreg <- BCreg |>
  group_by(BCregion) |>
  summarize(Shape = st_union(Shape))
saveRDS(BCreg, paste0(path, "/data/bioclimatic_regions.rds"))
```

```{r}
#| include: false
# read cache
BCreg <- readRDS(paste0(path, "/data/bioclimatic_regions.rds"))
```



### 7.5 Dataset E - Alpine ecosystem extent

I use a map of alpine extent that was also used by @framstad2021. It is
based on certain open, terrestrial land cover types above the current
/realised forest line. There is ongoing work to replace the ecosystem
mask for the alpine main ecosystem. When such a map is ready, the
workflow here can easily be updated.

```{r}
#| eval: false
#| code-fold: true
#| code-summary: "Prepare and cache alpine extent map"

pathE <- paste0(path, "/data/temp/alpine_extent.tif")

alpine <- stars::read_stars(pathE) |>
  st_as_sf(merge = T)

# intersections are much quicker on multipolygons, so I will union the geometries. 
alpine <- st_union(alpine)

saveRDS(alpine, paste0(path, "/data/alpine_extent.rds"))
```

```{r}
#| include: false
alpine <- readRDS(paste0(path, "/data/alpine_extent.rds"))
```

## 8. Spatial units


I use basically three spatial units: Strata (level 1; 70 units),
geographical region (level 2, 5 units), and the EAA.

Ecosystem assetsa re not defined. Although we have an ecosystem map and could
potentially assogn indicator values to individual polygons of alpine ecosystems,
this would require a lot of computing power and no real added benefit.

### 8.1 Strata

Here I create a dataset for the strata. The strat will be defined as the
intersection between bioclimatic regions and geographical regions. Then
I add total mountain area and glacier area as variables to this dataset.

Note that the strata are not contiguous (and therefore can not be classes as EAs).
Therefore metric values shold not be presented at the strata level as maps 
since within each strata, 
data is aggregated (summed) across rather large geographical areas.

```{r}
#| eval: false
#| code-summary: 'Create strata dataset'
# As a legacy, the strata dataset is called EA, but I changed this in the text since they do not conform to the SEEA EA definition of EAs.
EA <- BCreg |>
  sf::st_intersection(greg)

# create new variable for the unique EA IDs
EA <- EA |>
  mutate(EA_ID = row_number())

saveRDS(EA, paste0(path, "/data/EAs.rds"))
```

```{r}
#| include: false
EA <- readRDS(paste0(path, "/data/EAs.rds"))
```

```{r mountainArea}
#| warning: false
#| code-summary: 'Intersect EAs and alpine extent map'

# get mountain area for each strata (called EA below) 
temp_alpine <- EA |>
  st_intersection(alpine) |>
  mutate(mountainArea = units::drop_units(st_area(Shape))) |>
  as_tibble()

# Plot to show amount of maountain area per strata
#temp_alpine |>
#  group_by(BCregion) |>
#  summarise(area = sum(mountainArea)) |>
#  ggplot(aes(x = fct_reorder(BCregion, area), y = area)) +
#  geom_col() +
#  labs(x = "Bioclimatic region",
#       y = "Total mountain area (m2)") +
#  coord_flip()+
#  theme_bw()

```

```{r calcCurrent}
#| eval: true
#| code-summary: 'Intersect EAs and glacier maps'

# Runs only if the files are not cached, in which case they are simply read back.

if(!file.exists(paste0(path, "/data/dat_new_union.rds"))) {
  dat_new_union <- st_union(dat_new)
  temp_new <- EA |>
    st_intersection(dat_new_union) |>
    mutate(glacierAreaCurrent = units::drop_units(st_area(Shape))) |>
    as_tibble()
  saveRDS(temp_new, paste0(path, "/data/temp_new.rds"))
  saveRDS(dat_new_union, paste0(path, "/data/dat_new_union.rds"))
} else {
  dat_new_union <- readRDS(paste0(path, "/data/dat_new_union.rds"))
  temp_new <- readRDS(paste0(path, "/data/temp_new.rds"))
  }

if(!file.exists(paste0(path, "/data/dat_old_union.rds"))){
  dat_old_union <- st_union(dat_old)
  temp_old <- EA |>
    st_intersection(dat_old_union) |>
    mutate(glacierAreaOld = units::drop_units(st_area(Shape))) |>
    as_tibble()
  saveRDS(dat_old_union, paste0(path, "/data/dat_old_union.rds"))
  saveRDS(temp_old, paste0(path, "/data/temp_old.rds"))
} else {
    dat_old_union <- readRDS(paste0(path, "/data/dat_old_union.rds"))
    temp_old <- readRDS(paste0(path, "/data/temp_old.rds"))
  }

```


```{r join}
#| code-summary: 'Add glacier and mountain extent to EA dataset' 
EA <- EA |>
  as_tibble() |>
  left_join(
    temp_new |> select(
      glacierAreaCurrent,
      EA_ID
    ),
    by = join_by(EA_ID)
  ) |>
  left_join(
    temp_old |> select(
      glacierAreaOld,
      EA_ID
    ),
    by = join_by(EA_ID)
  ) |>
  left_join(
    temp_alpine |> select(
      mountainArea,
      EA_ID
    ),
    by = join_by(EA_ID)
  ) |>
  st_as_sf()

```

We see from @fig-area that glaciers are rare in sections 4 and 5 (good
reason for combining them), and zones 1-3. We could perhaps have
combined zone 3 along with zones 1 and 2, but it makes little
difference. @fig-arealUnits show the summed glacier area for different
spatial units.

```{r fig-area}
#| fig-cap: 'The extent of glacier and total mountain area for each geographical region (top), bioclimatic section (middle) and sone (bottom). The area for mountains is divided by 100 to get it on the same scale as glacier area for comparisons across regions.'
#| code-summary: 'Make figure'
myVars <- c("Current",
            "Historic",
            "Mountains"
            )

one <- EA |>
  as_tibble() |>
  group_by(region) |>
  summarise(Current = sum(glacierAreaCurrent, na.rm = T),
            Historic = sum(glacierAreaOld, na.rm = T),
            Mountains = sum(mountainArea, na.rm = T)/100) |>
  pivot_longer(cols = all_of(myVars),
               names_to = "Variable",
               values_to = "Area") |>
  ggplot(aes(fill = Variable, 
             y = Area,
             x = region)) +
  geom_col(position = "dodge") +
  labs(x = "Geographical region",
       y = "Areal extent (m2) (divided by 100 in the case of mountain area)") +
  coord_flip()+
  theme_bw()

two <- EA |>
  as_tibble() |>
  mutate(seksjon = str_split_i(BCregion, " ", 1),
         sone = str_split_i(BCregion, " ", 2)) |>
  group_by(seksjon) |>
  summarise(Current = sum(glacierAreaCurrent, na.rm = T),
            Historic = sum(glacierAreaOld, na.rm = T),
            Mountains = sum(mountainArea, na.rm = T)/100) |>
  pivot_longer(cols = all_of(myVars),
               names_to = "Variable",
               values_to = "Area") |>
  ggplot(aes(fill = Variable, 
             y = Area,
             x = seksjon)) +
  geom_col(position = "dodge") +
  labs(x = "Section",
       y = "Areal extent (m2) (divided by 100 in the case of mountain area)") +
  coord_flip()+
  theme_bw()


three <- EA |>
  as_tibble() |>
  mutate(seksjon = str_split_i(BCregion, " ", 1),
         sone = str_split_i(BCregion, " ", 2)) |>
  group_by(sone) |>
  summarise(Current = sum(glacierAreaCurrent, na.rm = T),
            Historic = sum(glacierAreaOld, na.rm = T),
            Mountains = sum(mountainArea, na.rm = T)/100) |>
  pivot_longer(cols = all_of(myVars),
               names_to = "Variable",
               values_to = "Area") |>
  ggplot(aes(fill = Variable, 
             y = Area,
             x = sone)) +
  geom_col(position = "dodge") +
  labs(x = "zones",
       y = "Areal extent (m2) (divided by 100 in the case of mountain area)") +
  coord_flip()+
  theme_bw()


ggpubr::ggarrange(one, two, three, ncol= 1)

```

```{r figCurrent}
#| code-summary: 'Make maps A and B'

map1 <- EA |>
  mutate(glacierAreaCurrent = replace_na(glacierAreaCurrent, 0)) |>
  ggplot() +
  geom_sf(aes(fill = glacierAreaCurrent),
    colour = NA,
    show.legend = F
  ) +
  scale_fill_gradient(low = "skyblue", high = "dodgerblue4")  

map2 <- ggplot()+
  geom_sf(data = greg,
    fill = "skyblue",
    colour = NA) +
  geom_sf(data = dat_new,
    fill = "dodgerblue4",
    colour = NA)

# ggpubr::ggarrange(map1, map2, labels="AUTO")

```

### 8.2 Alternative strata

In order to test the influence of the modifiable area unit problem
(MAUP; @openshaw1984), I will define two alternative strata sets, meaning two
alternative minimum mapping units: geographical region (`greg`), and
country (`EAA`).

We also use the `greg` dataset as intermediate data when we aggregate
from strata to EAA.

#### 8.2.1 greg and EEA

```{r greg}
#| code-fold: true
#| code-summary: "Create greg dataset"
#| warning: false

# add id column
greg <- greg |>
  mutate(greg_ID = row_number())

# intersect with maps to get extents per geographic regoin
temp_alpine_2 <- greg |>
  st_intersection(alpine) |>
  mutate(mountainArea = units::drop_units(st_area(geometry))) |>
  as_tibble()
temp_new_2 <- greg |>
  st_intersection(dat_new_union) |>
  mutate(glacierAreaCurrent = units::drop_units(st_area(geometry))) |>
  as_tibble()
temp_old_2 <- greg |>
  st_intersection(dat_old_union) |>
  mutate(glacierAreaOld = units::drop_units(st_area(geometry))) |>
  as_tibble()

# Add data into greg dataset
greg <- greg |>
  as_tibble() |>
  left_join(
    temp_new_2 |> select(
      glacierAreaCurrent,
      greg_ID
    ),
    by = join_by(greg_ID)
  ) |>
  left_join(
    temp_old_2 |> select(
      glacierAreaOld,
      greg_ID
    ),
    by = join_by(greg_ID)
  ) |>
  left_join(
    temp_alpine_2 |> select(
      mountainArea,
      greg_ID
    ),
    by = join_by(greg_ID)
  ) |>
  st_as_sf()

```

```{r EAAcreate}
#| code-fold: true
#| code-summary: "Create EEA dataset"
#| warning: false

# and the same for EAA
EAA <- readRDS(paste0(path, "/data/norway.rds")) |>
  add_column(EAA_ID = "1")


# I could get these area sums easier, but here I just copy over the method from above
temp_alpine_3 <- EAA |>
  st_intersection(alpine) |>
  mutate(mountainArea = units::drop_units(st_area(geometry))) |>
  as_tibble()
temp_new_3 <- EAA |>
  st_intersection(dat_new_union) |>
  mutate(glacierAreaCurrent = units::drop_units(st_area(geometry))) |>
  as_tibble()
temp_old_3 <- EAA |>
  st_intersection(dat_old_union) |>
  mutate(glacierAreaOld = units::drop_units(st_area(geometry))) |>
  as_tibble()

# Add data into EA_v3 dataset
EAA <- EAA |>
  as_tibble() |>
  left_join(
    temp_new_3 |> select(
      glacierAreaCurrent,
      EAA_ID
    ),
    by = join_by(EAA_ID)
  ) |>
  left_join(
    temp_old_3 |> select(
      glacierAreaOld,
      EAA_ID
    ),
    by = join_by(EAA_ID)
  ) |>
  left_join(
    temp_alpine_3 |> select(
      mountainArea,
      EAA_ID
    ),
    by = join_by(EAA_ID)
  ) |>
  st_as_sf()

```

```{r fig-arealUnits}
#| fig-cap: 'Current glacier extent, either as the actuall occurences (A); the the summed area per strata (B); the summed area per gegrapical region (C); or across the entire country (D). The legend is omitted for simplicity. The point here is simply to illustrate the sizes of the different spatial units, and how the minimum mapping unit affects the information in the maps.'
#| warning: false
#| fig-height: 10
#| fig-width: 8
#| code-summary: 'Make maps C and D and plot'

map3 <- greg |>
  mutate(glacierAreaCurrent = replace_na(glacierAreaCurrent, 0)) |>
  ggplot() +
  geom_sf(aes(fill = glacierAreaCurrent),
    colour = NA,
    show.legend = F
  ) +
  scale_fill_gradient(low = "skyblue", high = "dodgerblue4")

map4 <- EAA |>
  #mutate(glacierAreaCurrent = replace_na(glacierAreaCurrent, 0)) |>
  ggplot() +
  geom_sf(aes(fill = glacierAreaCurrent),
    colour = NA,
    show.legend = F
  ) +
  scale_fill_gradient(low = "skyblue", high = "dodgerblue4")


ggpubr::ggarrange(
  map2, map1,  
  map3, map4, 
  labels="AUTO")

# ggsave("../img/spUnits.png", bg = "white")
```

## 9. Analyses

I now go on to calculate indicator values for the different strata, and then
spatially aggregating them.

### 9.1 Calculating indicator values (distributions) for the strata

The next steps are a follows:

1.  Add 3% methodological uncertainty to the data at the strata level by
    sampling *n* numbers from a normal distribution with sd =
    mean × 0.03.
2.  Normalise the variable (now a prob. dist.) at the strata level using a
    piecewise linear transformation.
3.  Aggregate to next spatial level by sampling each probability
    distribution with *n* scaled to the area weights, thus creatuing a jiont sampling distribution. Try different area
    weightings, both by total mountain area and initial glacier area.
4.  Aggregate one more time to national level.
5.  Repeat for two alternative *entry points*, using either geographical
    region or the EEA as alternative EAs.

The papers describing the glacier extent data report an estimated 3%
uncertainty with their method [@andreassen2022]. I assume this to mean
the standard deviation is 3% of the mean. I start by replacing the point
estimates in each strata (and alternative strat definitions) with a probability
distribution centered on the point estimate, and with sd = mean × 0.03.
In ecosystem accounting it is not common to allow uncertainty in the
reference levels, but here it is quite easy to implement, and I
therefore see no reason not to.

```{r}
#| warning: false
#| code-fold: true
#| code-summary: "Replace estimates with prob. distributions"

EA <- EA |>
  # adding 3% uncertainty
  rowwise() |>
  mutate(
    glacierAreaCurrent_dist = 
      if_else(!is.na(glacierAreaCurrent),
              list(rnorm(1000, glacierAreaCurrent, glacierAreaCurrent*0.03)),
              NA), 
    glacierAreaOld_dist = 
      if_else(!is.na(glacierAreaOld),
              list(rnorm(1000, glacierAreaOld, glacierAreaOld*0.03)),
              NA))

```

Then I normalise, using a piecewise linear transformation, and get
similar probability distribution for indicator values. @tbl-normalise
shows the dataset with indicator values (just the median value) at the
strata level. Also in that dataset are the actual indicator probability
distributions, which can be sampled.

```{r tbl-normalise}
#| tbl-cap: 'Table of ecosystem assets, with variable values, X100 values (glacier area 1947-1985), indicator values and quartiles.'
#| code-fold: true
#| code-summary: "Normalise variable"


# create a temporary dataframe
EAtemp <- EA |>
  as_tibble() |>
  # unlist and create new rows for each random pair of current and old glacier area estimate
  unnest_longer(c(
    glacierAreaCurrent_dist,
    glacierAreaOld_dist), 
    keep_empty = T) |>
  rename(variable = glacierAreaCurrent_dist, 
         x100 = glacierAreaOld_dist) |>
  mutate(
    # replace NA with zero if EA had glaciers, but lost them
    variable = case_when(
      is.na(variable) & x100 > 0 ~ 0,
      .default = variable),
    # define x60 value as 60% glacier loss (40% of X100)
    x60 = x100*scalar,
    # normalise using piecewise linear transfomation
    indicator =  ifelse(
      variable < x60, 
        ((variable - 0)/(x60 - 0)) * 0.6, 
        ((variable - x60)/(x100 - x60)) * (1 - 0.6) + 0.6),
    # truncate
    indicator = case_when(
      indicator > 1 ~ 1,
      indicator < 0 ~ 0,
      .default = indicator
    )) |>
  # recast into list column
  drop_na(indicator) |>
  group_by(EA_ID) |>
  summarise(indicator_dist = list(indicator), .groups = "drop")

# we then paste these distributions back into the EA object

EA <- EA |>
  as_tibble() |>
  # simplify datafra by removing some columns...
  select(-glacierAreaCurrent_dist,
         -glacierAreaOld_dist,
         -GID_0,
         -NAME_0) |>
  # add the probability distribution of indicator values
  left_join(
    EAtemp,
    by = join_by(EA_ID)
  ) |>  
  # summarise the distribution
  rowwise() |>
  mutate(
    indicator = ifelse(
      !is.null(indicator_dist),
      median(unlist(indicator_dist)),
      NA),
  # add first and third quartile
    indicator_Q1 = ifelse(
      !is.null(indicator_dist),
      quantile(unlist(indicator_dist), probs = 0.25),
      NA), 
    indicator_Q3 = ifelse(
      !is.null(indicator_dist),
      quantile(unlist(indicator_dist), probs = 0.75),
      NA), 
  ) |>
  st_as_sf()

DT::datatable(EA |>
  as_tibble() |>
  mutate(across(where(is.numeric), ~ round(.x, digits = 2))) |>
  select(
    EA_ID,
    glacierAreaCurrent,
    X100 = glacierAreaOld,
    mountainArea,
    indicator,
    indicator_Q1,
    indicator_Q3
  ))
```

@fig-EAglacArea show the current (2018-2019) glacier extent per strata,
stratified by bioclimatic zone and region. Clearly most glaciers are in section 2, 
which is the _clearly oceanic section_. 
High percipitation is a prerequitese for glaciers. 
Section 1 has even more precipitation, but is also warmer and has less total extent (@fig-sonerOgSeksjoner).

Of the zones, its mainly in the alpine zones (zone 5) where we find glaciers. 
@fig-gradientIndicator show how the warmer sones also have a little lower indicator values,
as expected.

```{r fig-EAglacArea}
#| fig-cap: 'Current glacier extent (2018-2019) for individual strata (bars). Facets are bioclimatic sections and coulrs refer to bioclimatic zones (legend). Note the logarithmic axis.'

EA |>
  ungroup() |>
  separate(BCregion,
    into = c("section", "sone"),
    sep = " ",
    extra = "merge",
    remove = F) |>
  drop_na(glacierAreaCurrent) |>
  ggplot() +
  geom_col(aes(
    x = fct_reorder(factor(EA_ID), glacierAreaCurrent), 
    y = glacierAreaCurrent,
    fill = sone),
    ) +
  coord_flip(clip = "off") +
  theme_bw() +
  labs(y = "Glacier extent (m2)") +
  facet_wrap(.~section,
             scales = "free_y") +
  theme(
    axis.text.y = element_blank(),
    axis.title.y = element_blank(),
    axis.ticks.y = element_blank()
  )+
  scale_y_log10(guide = "axis_logticks",
                minor_breaks = seq(0, 10^9, 10^6)
    #breaks = scales::trans_breaks("log10", function(x) 10^x),
    #labels = scales::trans_format("log10", scales::math_format(10^.x))
    )

```

```{r fig-gradientIndicator}
#| fig-cap: 'Indicator values for individual strata (bars). Facets are bioclimatic sections and coulrs refer to bioclimatic zones (legend). The missing strata in the bottom right pane represents a case when a strata had no glaciers before, but some glaciers where mapped in the last survey (possibly due to mapping inconsistencies). The missing strata in the top right pane is a case of a strat having an indicator value of zero (some glaciers found in the first survey but none in the second)'

EA |>
  ungroup() |>
  separate(BCregion,
    into = c("section", "sone"),
    sep = " ",
    extra = "merge",
    remove = F) |>
  drop_na(indicator) |>
  ggplot() +
  geom_col(aes(
    x = fct_reorder(factor(EA_ID), indicator), 
    y = indicator,
    fill = sone),
    ) +
  coord_flip() +
  theme_bw() +
  labs(y = "Indicator value") +
  facet_wrap(.~section,
             scales = "free_y") +
  theme(
    axis.text.y = element_blank(),
    axis.title.y = element_blank(),
    axis.ticks.y = element_blank()
  )
```



### 9.2 Aggregating to geographical regions

Now I spatially aggregate the indicator values to the level of
geographic region by sampling the probability distributions of each stratum
proportional to the weight. As the weight, we we use the X~100~ value,
i.e. the initial glacier area. Stratum with no glaciers in them get NA, and
are not included in the aggregated value.

For comparison, we also calculate the aggregated values using mountain
area (`mtArea`) as alternative weights, and we refer to these indicator
values with a *mtArea* suffix. We also try an approach where we
calculate indicator values for geographical regions or EAA level
directly, that is to say, without using the original strata at all. These
indicator values get a *level2* or *level3* suffix, respectively.

@tbl-gregAgg shows is the indicator values for the geographical regions.
The estimates differ quite a lot depending onthe weights used, which we
also see in @fig-ridgde1.

```{r gregAggx}
#| code-fold: true
#| code-summary: "Aggregate from strata to geographical region"

# In order to control the n for how many samples we draw,
# we first calculate the summed area of glaciers and mountains

#EA |>
#  as_tibble() |>
#  summarise(total_m2 = sum(glacierAreaOld, na.rm=T)) |> 
#  pull(total_m2)
## Resul: 3 327 251 347. We can divide this by 10^4

#EA |>
#  as_tibble() |>
#  #ungroup() |>
#  summarise(total_m2 = sum(mountainArea, na.rm=T)) |> 
#  pull(total_m2)
## Result: 323 871 072 604. We can divide this by 10^6


## 
EA_to_greg <- ungroup(EA) |>
  drop_na(indicator) |>
  group_by(EA_ID, region) |>
  # sample with weights
  reframe(
    indicator = 
      list(
        sample(
          unlist(indicator_dist),
          size = glacierAreaOld*10^-4,
          replace = T)),
    indicator_mtArea = 
      list(
        sample(
          unlist(indicator_dist),
          size = mountainArea*10^-6,
          replace = T))
  ) |>
  # concactenate the weighted samples
  group_by(region) |>
  summarise(indicator_dist = list(unlist(indicator)),
            indicator_mtArea_dist = list(unlist(indicator_mtArea))) |>
  # get summary values
  ungroup() |>
  rowwise() |>
  mutate(
    indicator = ifelse(
      !is.null(indicator_dist),
      median(unlist(indicator_dist)),
      NA),
  # add first and third quartile
    indicator_Q1 = ifelse(
      !is.null(indicator_dist),
      quantile(unlist(indicator_dist), probs = 0.25),
      NA), 
    indicator_Q3 = ifelse(
      !is.null(indicator_dist),
      quantile(unlist(indicator_dist), probs = 0.75),
      NA),
  # add the same for indicator_mtArea
    indicator_mtArea = ifelse(
      !is.null(indicator_mtArea_dist),
      median(unlist(indicator_mtArea_dist)),
      NA),
  # add first and third quartile
    indicator_mtArea_Q1 = ifelse(
      !is.null(indicator_mtArea_dist),
      quantile(unlist(indicator_mtArea_dist), probs = 0.25),
      NA), 
    indicator_mtArea_Q3 = ifelse(
      !is.null(indicator_mtArea_dist),
      quantile(unlist(indicator_mtArea_dist), probs = 0.75),
      NA)
  )


```

```{r createRidgePlot}
#| eval: true
#| code-fold: true
#| code-summary: "Create ridge plot"

# set bandwidth
bw <- 0.015


# the ridge plots are huge files and stop the rendering of the html.
# thats why I sample 300 values, enough to get a smooth curve, and
# run the code only on first excecution.

if(!file.exists(paste0(path, "/data/temp_oneRidge.rds"))){
  oneRidge <- ungroup(EA_to_greg) |>
    unnest_longer(indicator_dist) |>
    slice_sample(n = 300,
                 by = region) |>
    ggplot(aes(x = indicator_dist,
               y = region)) +
    geom_density_ridges(
           fill = "skyblue",
           bandwidth = bw) +
    labs(y = "",
         x = "Indicator values")+
    xlim(0, 1)
  saveRDS(oneRidge, paste0(path, "/data/temp_oneRidge.rds"))
} else {
    oneRidge <- readRDS(paste0(path, "/data/temp_oneRidge.rds"))
  }

if(!file.exists(paste0(path, "/data/temp_twoRidge.rds"))){
  twoRidge <- ungroup(EA_to_greg) |>
    unnest_longer(indicator_mtArea_dist) |>
    slice_sample(n = 300,
                 by = region) |>
    ggplot(aes(x = indicator_mtArea_dist,
               y = region)) +
    geom_density_ridges(
           fill = "lightgreen",
           bandwidth = bw) +
    labs(y = "",
         x = "Indicator values (alternative weights)")+
    xlim(0, 1)
  saveRDS(twoRidge, paste0(path, "/data/temp_twoRidge.rds"))
} else {
    twoRidge <- readRDS(paste0(path, "/data/temp_twoRidge.rds"))
  }



# ggpubr::ggarrange(oneRidge, twoRidge, ncol=1, labels = "auto")  

```

Now I add the spatially aggregated indicator values to the sf object
with the geographical regions so that we can make a map.

```{r}
#| code-fold: true
#| code-summary: "Add indicators to greg dataset with the regional delineations"

greg <- greg |>
  as_tibble() |>
  left_join(EA_to_greg, by = join_by(region)) |>
  st_as_sf()
```

### 9.3. Alternative strata/MMUs {#sec-ea2}

What if we used different minimal mapping units MMUs, or strata?

Now I calculate the indicator value directly to the geographical
regions. This indicator will be named `indicator_level2` in the code and
the figures. As we see from @fig-ridgde1 this creates smoother density
plots. In fact they are practically perfect gaussian distributions,
since the 3% error was added to the summed glacier area for the regions,
and not on the initial glacier polygons (which would also be a valid
approach, but it would require a lot more memory). We also see that the
distributions generally match up well with pane a and the original
weighting scheme. But @tbl-gregAgg show us that the point estimates are
not identical, meaning that the two approaches are not perfectly
commutative, and that some other dataset could give bigger (or smaller)
differences between the two approaches than what we see here.

```{r}
#| code-fold: true
#| code-summary: "Replace glacier estimates with probability distributions"

greg <- greg |>
# adding 3% uncertainty
  rowwise() |>
  mutate(
    glacierAreaCurrent_dist = 
      if_else(!is.na(glacierAreaCurrent),
              list(rnorm(1000, glacierAreaCurrent, glacierAreaCurrent*0.03)),
              NA), 
    glacierAreaOld_dist = 
      if_else(!is.na(glacierAreaOld),
              list(rnorm(1000, glacierAreaOld, glacierAreaOld*0.03)),
              NA))
```

```{r}
#| code-fold: true
#| code-summary: "Estimate indicator_level2"

# create a temporary dataframe
greg_temp <- greg |>
  as_tibble() |>
  # unlist and create new rows for each random pair of current and old glacier area estimate
  unnest_longer(c(
    glacierAreaCurrent_dist,
    glacierAreaOld_dist), 
    keep_empty = T) |>
  rename(variable = glacierAreaCurrent_dist, 
         x100 = glacierAreaOld_dist) |>
  mutate(
    # define x60 value
    x60 = x100*scalar,
    # normalise using piecewise linear transfomation
    indicator_level2 =  ifelse(
      variable < x60, 
        ((variable - 0)/(x60 - 0)) * 0.6, 
        ((variable - x60)/(x100 - x60)) * (1 - 0.6) + 0.6),
    # truncate
    indicator_level2 = case_when(
      indicator_level2 > 1 ~ 1,
      indicator_level2 < 0 ~ 0,
      .default = indicator_level2
    )) |>
  # recast into list column
  drop_na(indicator_level2) |>
  group_by(greg_ID, region) |>
  summarise(indicator_dist_level2 = list(indicator_level2), .groups = "drop")

# we then paste these distributions back into the greg object

greg <- greg |>
  as_tibble() |>
  # simplify datafra by removing some columns...
  select(-glacierAreaCurrent_dist,
         -glacierAreaOld_dist,
         -GID_0,
         -NAME_0) |>
  # add the probability distribution of indicator values
  left_join(
    greg_temp |> select(-region),
    by = join_by(greg_ID)
  ) |>  
  # summarise the distribution
  rowwise() |>
  mutate(
    indicator_level2 = ifelse(
      !is.null(indicator_dist_level2),
      median(unlist(indicator_dist_level2)),
      NA),
  # add first and third quartile
    indicator_Q1_level2 = ifelse(
      !is.null(indicator_dist_level2),
      quantile(unlist(indicator_dist_level2), probs = 0.25),
      NA), 
    indicator_Q3_level2 = ifelse(
      !is.null(indicator_dist_level2),
      quantile(unlist(indicator_dist_level2), probs = 0.75),
      NA), 
  ) |>
  st_as_sf()

```

```{r tbl-gregAgg}
#| tbl-cap: 'Table with indicator values and quartiles for geographical regions.'
#| code-fold: true
#| code-summary: "Make table"


DT::datatable(greg |>
  as_tibble() |>
  mutate(across(where(is.numeric), ~ round(.x, digits = 2))) |>
  select(
    greg_ID,
    region,
    #glacierAreaCurrent,
    #X100 = glacierAreaOld,
    #mountainArea,
    indicator,
    indicator_mtArea,
    indicator_level2
  ))
```

```{r ridge3}
#| eval: true
#| code-fold: true
#| code-summary: "Make third ridge plot"
#| warning: false

bw <- 0.015


if(!file.exists(paste0(path, "/data/temp_threeRidge.rds"))){
  threeRidge <- greg_temp |>
    unnest_longer(indicator_dist_level2) |>
    ggplot(aes(x = indicator_dist_level2,
               y = region)) +
    geom_density_ridges(
           fill = "orchid1",
           bandwidth = bw) +
    labs(y = "",
         x = "Indicator values (alternative strata approach)") +
    xlim(0, 1)
  saveRDS(threeRidge, paste0(path, "/data/temp_threeRidge.rds"))
} else {
    threeRidge <- readRDS(paste0(path, "/data/temp_threeRidge.rds"))
  }


```

@fig-ridgde1 and @tbl-gregAgg show how the weighting by the mountain
area of each EA generally reduces the indicator value. See for example Norther Norway (Nord-Norge)
where where one strata has an indicator value of 0. This strata had very little
glaciers to begin with, and in the øastest survey i had none lesft. 
The alpine area of that strata, however, is quite large. Therefore, thata strata 
is give en weight in the spatial aggregation only when the weights are determined by the alpine extent. 
We also see how *preaggregating* to geographical regions creates more unimodal
sample distributions (pane C).

```{r fig-ridgde1}
#| echo: false
#| fig-cap: 'Sample distributions for indicator values aggregated to the scale of geographical regions. a) is aggregated from the original strata using a weighting based on the initial glacier area. b) uses a weighting based on total mountain area in each strata. c) uses geographical regions as alternative strata.'
#| warning: false
ggpubr::ggarrange(oneRidge, twoRidge, threeRidge, 
                  ncol=1, labels = "auto") 

#ggsave(paste0(path, "/img/ridge.png"))
#knitr::include_graphics(paste0(path, "/img/ridge.png"))
```

### 9.4 Aggregating to EAA

Then I aggregate the regional sample distributions to the entire
ecosystem accounting area (EAA), which is mainland Norway.

```{r tblEAAAgg}
#| code-fold: true
#| code-summary: "Aggregate indicator values from regions to EAA"

# In order to control the n for how many samples we draw,
# we first calculate the summed area of glaciers

#greg |>
#  as_tibble() |>
#  summarise(total_m2 = sum(glacierAreaOld, na.rm=T)) |> 
#  pull(total_m2)
## Resul: 33 327 254 334. We can divide this by 10^5


greg_to_EAA <- ungroup(greg) |>
  group_by(greg_ID, region) |>
  # sample with weights
  reframe(
    indicator = 
      list(
        sample(
          unlist(indicator_dist),
          size = glacierAreaOld*10^-5,
          replace = T)),
    indicator_mtArea = 
      list(
        sample(
          unlist(indicator_mtArea_dist),
          size = glacierAreaOld*10^-5,
          replace = T)),
    indicator_level2 = 
      list(
        sample(
          unlist(indicator_dist_level2),
          size = glacierAreaOld*10^-5,
          replace = T))
  ) |>
  # concactenate the weighted samples
  ungroup() |>
  summarise(indicator = list(unlist(indicator)),
            indicator_mtArea = list(unlist(indicator_mtArea)),
            indicator_level2 = list(unlist(indicator_level2))) |>
  pivot_longer(everything(),
               names_to = "Indicator_variant",
               values_to = "prob_dist") |>
  # get summary values
  rowwise() |>
  mutate(
    indicator_value = median(unlist(prob_dist)),
  # add first and third quartile
    indicator_Q1 = quantile(unlist(prob_dist), probs = 0.25), 
    indicator_Q3 = quantile(unlist(prob_dist), probs = 0.75))
  


```

### 9.5 Alternative MMU (EAA)

Similar to in @sec-ea2 I will see what happens if I estimate the
indicator value directly at the EAA level.

```{r}
#| code-fold: true
#| code-summary: "Replace glacier estimates with probability distributions"

EAA <- EAA |>
# adding 3% uncertainty
  rowwise() |>
  mutate(
    glacierAreaCurrent_dist = 
      if_else(!is.na(glacierAreaCurrent),
              list(rnorm(1000, glacierAreaCurrent, glacierAreaCurrent*0.03)),
              NA), 
    glacierAreaOld_dist = 
      if_else(!is.na(glacierAreaOld),
              list(rnorm(1000, glacierAreaOld, glacierAreaOld*0.03)),
              NA))
```

```{r tbl-NormaliseEAA}
#| tbl-cap: 'Indicator values (four approaches) aggregated to the EAA level.'
#| code-fold: true
#| code-summary: "Estimate indicator directly at EAA level"

# create a temporary dataframe
EAA_temp <- EAA |>
  as_tibble() |>
  # unlist and create new rows for each random pair of current and old glacier area estimate
  unnest_longer(c(
    glacierAreaCurrent_dist,
    glacierAreaOld_dist), 
    keep_empty = T) |>
  rename(variable = glacierAreaCurrent_dist, 
         x100 = glacierAreaOld_dist) |>
  mutate(
    # define x60 value
    x60 = x100*scalar,
    # normalise using piecewise linear transfomation
    indicator_level3 =  ifelse(
      variable < x60, 
        ((variable - 0)/(x60 - 0)) * 0.6, 
        ((variable - x60)/(x100 - x60)) * (1 - 0.6) + 0.6),
    # truncate
    indicator_level3 = case_when(
      indicator_level3 > 1 ~ 1,
      indicator_level3 < 0 ~ 0,
      .default = indicator_level3
    )) |>
  # recast into list column
  group_by(EAA_ID) |>
  summarise(prob_dist = list(indicator_level3), .groups = "drop") |>
  add_column(Indicator_variant = "indicator_level3") |>
  # get summary values
  rowwise() |>
  mutate(
    indicator_value = median(unlist(prob_dist)),
  # add first and third quartile
    indicator_Q1 = quantile(unlist(prob_dist), probs = 0.25), 
    indicator_Q3 = quantile(unlist(prob_dist), probs = 0.75))

# combine with the eariler dataset
greg_to_EAA <- greg_to_EAA |>
  bind_rows(EAA_temp)

DT::datatable(greg_to_EAA |>
  mutate(across(where(is.numeric), ~ round(.x, digits = 2))) |>
  select(
    -prob_dist,
    -EAA_ID
  ))

```

```{r fig-eaaRidge}
#| fig.cap: 'Distribution of indicator values for the EAA level using four alternative aggregation pathways. Vertical lines are quartiles.'
#| warning: false
#| code-fold: true
#| code-summary: "Make ridge plot"

bw <- 0.015


greg_to_EAA |>
  unnest_longer(prob_dist) |>
  ggplot(aes(x = prob_dist,
             y = Indicator_variant,
             fill = Indicator_variant)) +
  geom_density_ridges(
         bandwidth = bw,
         alpha = .6,
         quantile_lines = T,
         show.legend = F) +
  labs(y = "",
       x = "Indicator values") +
  xlim(.45, 1)

```


## 10. Results

@tbl-NormaliseEAA and @fig-eaaRidge show the indicator estaimates and
distributions for the EAA level. I recomend using the *indicator*, i.e.
the indicator version using the aggregation pathway

$$
sp.agg^1 - [scale - transform - truncate] - sp.agg^2 - sp.agg^3
$$

where ^1^ refers to the summation of glacier area inside each EA
(*pre-aggregation*); ^2^ refers to aggregation to geographical region
using weighted sampling and taking the median from the resulting
distribution; and ^3^ refers to further aggregation to the EAA, also
using weighted sampling from the sample distribution of indicator
values for the geographical region level.

@fig-maps show that at least three of the aggregation shemes are
qualitatively similar, but not identical.

```{r}
#| message: false
#| eval: false
#| code-fold: true
#| code-summary: "Make maps"



# add indicator data to EAA 
EAA <- EAA |>
  ungroup() |>
  as_tibble() |>
  left_join(greg_to_EAA |>
              mutate(EAA_ID = "1"),
            by = join_by(EAA_ID)) |>
  st_as_sf()

# prepare the greg data a little to ba able to row bind with the others
temp <- greg |>
  pivot_longer(cols = c(
    indicator,
    indicator_level2,
    indicator_mtArea
  ),
  names_to = "Indicator_variant",
  values_to = "indicator_value") |>
  select(
    region,
    Indicator_variant,
    indicator_value
  )

# function for renaming geomatry column in sf
rename_geometry <- function(g, name){
    current = attr(g, "sf_column")
    names(g)[names(g)==current] = name
    st_geometry(g)=name
    g
}

one <- EA |>
  rename(indicator_value = indicator) |>
  add_column(level = 1,
             Indicator_variant = "indicator") |>
  select(indicator_value,
         level,
         Indicator_variant)
one <- rename_geometry(one, "geometry")

two <-  EAA |> 
    add_column(level = 3) |>
    select(indicator_value,
         level,
         Indicator_variant)

three <- temp |> 
    add_column(level = 2) |>
    select(indicator_value,
         level,
         Indicator_variant)

plotdat <- rbind(
  one, two, three
)


plotdat |>
  ggplot() +
  geom_sf(aes(fill = indicator_value),
          colour = NA) +
  facet_grid(rows = vars(level),
             cols = vars(Indicator_variant),
             drop = T) +
  scale_fill_gradient(na.value = "grey80") +
  #geom_sf(data = EAA, fill = NA) +
  theme_bw()

ggsave(paste0(path, "/img/allmaps.png"))
```

```{r fig-maps}
#| fig-cap: 'Indicator estimates (median of sample distributions) at three spatial levels: Strata level (top row, level 1); geographical region (second row, level 2); ecosystem accounting area (bottom row, level 3). The two latter aggregation levels are represented with several approaches. _Indicator_ and _indicator_mtArea_ relies on data aggregated through the strata level, but _indicator_mtArea_ uses total mountain area, rather than initial glacier area, as the area weight during the aggregation. _Indicator level2_ refers to the approach where indicator values were estimated directly at the level of geographical regions, and _indicator_level3_ was estimated directly at the EAA level.'
#| echo: false
knitr::include_graphics(paste0(path, "/img/allmaps.png"))
```

The final output is then the indicator estimate for the EAA level
(@tbl-finalTable).

```{r tbl-finalTable}
#| tbl-cap: 'Indicator values and the first and third quartile for NO_GLA_001 aggregated to EAA level'
#| code-fold: true
#| code-summary: "Make table"



greg_to_EAA |>
  filter(Indicator_variant == "indicator") |>
  mutate(across(where(is.numeric), ~ round(.x, digits = 2))) |>
  select(
    -prob_dist,
    -EAA_ID,
    -Indicator_variant
  ) |>
  add_column(
    Indicator = "Glacier area",
    Indicator_ID = "NO_GLAC_001",
    Ecosystem = "Alpine",
    Area = "Mainland Norway",
    .before = "indicator_value"
  ) |>
  rename(Q1 = indicator_Q1,
         Q3 = indicator_Q3) |>
  DT::datatable()
```
