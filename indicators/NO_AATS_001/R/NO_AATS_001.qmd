---
title: "Absence of alien coniferous tree species"
subtitle: |
  [NO_AATS_001]
# delete the line with the second indicatorID (line 5) 
# if it's not relevant for you.
# In the parentheses you can add a word to distinguish multiple indicators 
# from each other, for example the ecosystem type that they cover
indicatorID: 
  - NO_AATS_001
# If you are presenting multiple indicators, and have multiple 
# indicator IDs, then add them as a list here, and make sure you add
# the same number of list entries, 
# and in the same order that corresponds to the indicator IDs,  
# to the meta data fields where the indicators differ. 
# For example, if the indicators cover different ecosystem types, 
# add the ecosystems as a list under 'Ecosystems', but if they are in the
# same realm, same country etc., then you only need to write the realm and
# country once. 
indicatorName: 
  - Alien coniferous tree species # add more by adding another line starting '-'
country: Norway
continent: Europe
ECT: write ECT here # e.g. A2 - Chemical State characteristics
Realm: 
  - Terrestrial (T) # e.g. Freshwater (F)
Biome: 
  - write biome here # e.g. F1 Rivers and streams biome
Ecosystem: 
  - write ecosystem here # e.g. F1.3 Freeze-thaw streams
yearAdded: 2024 # the year when the indicator was first submitted to ecRxiv
yearLastUpdate: 2025
status: incomplete # options are complete, incomplete, or deprecated
Version: "000.001" # Beta-versions are numbers incrementally with values below 0. Operational versions can be given the version numbers above 0. Use this terms similar as for software versioning,
VersionComment: Comment here # Describe briefly how this version differs from earlier versions 
url: https://github.com/NINAnor/ecRxiv/tree/main/indicators/XX_YYYY_ZZZ
# Leave the url as is, but replace XX_YYYY_ZZ with the name of the root folder for the current indicator(s). It should be the same as the indicatorID, but if there are more indicator IDs presented in the same folder, the folder name might be different, e.g. XX_YYYY_AAA-BBB 
Normalised: # Yes or no depending on whether the metric has been normliased or not.
SpatialAggregationPathway: Describe the aggregation using the standrdaise terminology # e.g. Scale - Transform - Aggregate (length-weighted arithmetic mean) - Truncate
format: 
  html:
    embed-resources: true
    code-fold: true
    toc: true
    toc-title: Contents
    toc-depth: 3
    smooth-scroll: true
execute: 
  cache: true
author:
  - name: Erik Framstad              # Enter name
    email: erik.framstad@nina.no  # Enter email
    affiliations:
      - id: myID
        name: Norwegian Institute for Nature Research # Enter affiliations
  - name: Ken Olav Storaunet            #  Enter subsequent authors like this, or remove if not relevant
    affiliations:
      - ref: myID               # To reuse affiliations reference the id like this
        name: Norwegian Institute of Bioeconomy Research # Enter affiliations
  - name: Aud H. Halbritter              #  Enter subsequent authors like this, or remove if not relevant
    affiliations:
      - ref: myID               # To reuse affiliations reference the id like this
        name: University of Bergen # Enter affiliations
AuthorList: Framstad, E. and Halbritter, A. H.
date: October 26, 2025 # Enter date
data_availability: gold
code_reproducibility: bronze
open_science_badge: silver
callout-icon: false
lightbox: true
css: ../../../style.css
bibliography: bibliography.bib
code-links:
      - text: Add a review
        icon: github
        href: https://github.com/NINAnor/ecRxiv
---

<!--# This is a template for how to document the indicator analyses. Make sure also to not change the order, or modify, the headers, unless you really need to. This is because it easier to read if all the indicators are presented using the same layout. If there is one header where you don't have anything to write, just leave the header as is, and don't write anything below it. If you are providing code, be careful to annotate and comment on every step in the analysis. Before starting it is recommended to fill in as much as you can in the metadata file. This file will populate the initial table in your output.-->

<!--# Load all you dependencies here -->

```{r setup}
#| include: false
#| cache: false
library(knitr)
library(tidyverse)
library(kableExtra)
library(here)
library(anybadger)
library(yaml)
library(conflicted)
library(janitor)
library(stringi)
library(geodata)
library(terra)
library(sf)
library(DT)
# weird workarounds for cache issues
conflicts_prefer(dplyr::filter)
conflicts_prefer(dplyr::lag)
conflicts_prefer(dplyr::select)
pull<-dplyr::pull

knitr::opts_chunk$set(echo = TRUE)
```

```{r source}
#| echo: false
#| cache: false
source(here::here("_common.R"))
source(here("indicators", "NO_AATS_001", "R", "functions.R"))
```

```{r extractFromYML}
#| echo: false
#| cache: false
this_file <- get_file_info()

# Read the YAML front matter
lines <- readLines(this_file$path, warn = FALSE)
dash_lines <- which(trimws(lines) == "---")
yaml_block <- lines[(dash_lines[1] + 1):(dash_lines[2] - 1)]
yaml_data <- yaml::yaml.load(paste(yaml_block, collapse = "\n"))

# Robust flatten function
flatten_to_string <- function(x) {
  if (is.list(x)) {
    # recursively flatten any nested lists
    x <- unlist(x, recursive = TRUE)
  }
  # convert to single string
  paste(x, collapse = "; ")
}

# Apply to all YAML entries
yaml_data_flat <- lapply(yaml_data, flatten_to_string)

# Create tibble
meta <- tibble::enframe(yaml_data_flat, name = "Variable", value = "Value")

# Check structure
#str(meta)

st <- meta |>
  dplyr::filter(Variable == "status") |>
  pull(Value)
version <- meta |>
  dplyr::filter(Variable == "Version") |>
  pull(Value)
auth <- meta |>
  dplyr::filter(Variable == "AuthorList") |>
  pull(Value)
year <- meta |>
  dplyr::filter(Variable == "yearAdded") |>
  pull(Value)
id <- meta |>
  dplyr::filter(Variable == "indicatorID") |>
  pull(Value)
name <- meta |>
  dplyr::filter(Variable == "indicatorName") |>
  pull(Value)
url <- meta |>
  dplyr::filter(Variable == "url") |>
  pull(Value)
badges<-meta |> 
  dplyr::filter(Variable %in% c("data_availability",
         "code_reproducibility", "open_science_badge")) |> 
  pull(Value)

meta <- meta |>
  dplyr::mutate(Variable = dplyr::case_match(Variable,
    "indicatorID" ~ "Indicator ID" ,
    "indicatorName" ~ "Indicator Name",
    "continent" ~ "Continent",
    "country" ~ "Country",
    "ECT" ~ "Ecosystem Condition Typology Class",
    "yearAdded" ~ "Year added",
    "yearLastUpdate" ~ "Last update",
    "VersionComment" ~ "Version comment",
    "SpatialAggregationPathway" ~ "Spatial aggregation pathway",
    .default = Variable
  )) |>
  dplyr::filter(Variable != "authors")

```



<!--# The following parts are autogenerated. Do not edit. -->

::: {layout-ncol="5"}

```{r statusBadge}
#| echo: false
status_badge(as.character(st))
```

```{r versionBadge}
#| echo: false
version_badge(version_number = as.character(version[[1]]))
```

```{r dataBadge}
#| echo: false
data_badge(as.character(badges[[1]]))
```

```{r codeBadge}
#| echo: false
code_badge(as.character(badges[[2]]))
```

```{r openScienceBadge}
#| echo: false
open_science_badge(as.character(badges[[3]]))
```
::: 
 

> **Recommended citation**: `r paste(auth, " ", year, ". ", name, " (ID: ", id, ") ", "v. ", version, ". ecRxiv: ", url, sep="")`



::: {.callout-tip collapse="true"}
## Metadata
```{r tbl-meta2}
#| tbl-cap: 'Indicator metadata'
#| echo: false
#| warning: false
meta |>
  dplyr::filter(Variable %in% c(
    "Indicator ID",
    "Indicator Name",
    "Continent",
    "Country",
    "Ecosystem Condition Typology Class", 
    "Realm",
    "Biome",
    "Ecosystem",
    "Year added", 
    "Last update",
    "Version",
    "Version comment",
    "Normalised",
    "Spatial aggregation pathway")) |>   
  kable()

```
:::

::: {.callout-tip collapse="true"}

## Log

<!--# Update this logg with short messages for each update -->
- 26 Oct. 2025 - Original PR
:::


<hr />

<!--# Document you work below.  -->

## 1. Summary

<!--# 
With a maximum of 300 words, describe the indicator in general terms as you would to a non-expert. Think of this as a kind of common language summary. Follow the four numbers sub-headers below. under point 2, it is possible under  include a bullet point list of the specific steps in the workflow. 
 -->

1. **Background and rationale**:
<!-- What does the metric represent? Why is this relevant for describing ecosystem condition in this ecosystem?
What are the main anthropogenic impact factors? -->
Many non-native or alien tree species are considered to have a high or very high risk for native forest ecosystems.
Intact ecosystems should not contain any such alien species of high ecological risk.
This indicator is specified as the absence (0% volume) of alien coniferous tree species.
Alien coniferous species represent the most abundant alien tree species considered to have a high ecological risk by @artsdatabanken2023-fremmedartslista.
Data for this indicator come from the National Forest Inventory (NFI), where all trees larger than 5 cm at breast height (dbh) have been recorded within the 250 m² NFI plots since the mid-1980s (@viken2021-feltinstruks).
The planting of alien tree species in forestry is the most important anthropogenic driver for this indicator.

2. **Methods**:
<!-- What kind of data is used? How is the data customized (modified, estimated, integrated) to fit its purpose as an indicator? -->
All trees larger than 5 cm at breast height (dbh) are recorded and identified to species for each 250 m² NFI inventory plot.
There are about 12,000 NFI plots in forest ecosystems, distributed on a regular grid.
The indicator value is an unbiased area-weighted estimate of the proportion of alien coniferous tree species (measured as % of volume for cutting class 3-5 and % of crown cover for cutting class 2), for included NFI plots in any selected region.
All NFI plots are sampled over a 5-year period, with a representative sampling scheme every year.
For this indicator, data are included from the last 5 years including the reporting year, currently 2020-2024.

3. **Interpretation**:
<!-- Add a very short description of how the indicator values should be interpreted. Here's an example for a bumblebee indicator: An indicator value of 1 signifies an intact bumblebee community. Values decreasing toward zero reflect negative ecological change, specifically the decline of species expected to be present. This metric does not account for potentially positive changes, such as increases in species' abundance or the arrival of new species. Tip: Add text on the line directly following the subheader, and don't introduce blank lines. This way the whole paragraph renders as a block quote. -->
An indicator value of 1 (100% absence) signifies intact forest ecosystems where alien coniferous tree species are completely absent.
Values decreasing toward zero reflect increasing presence of alien coniferous species, indicating deviation from the natural reference condition.
The relationship between indicator values and ecosystem condition is assumed to be linear at this stage, though non-linear relationships may be more appropriate.

4. **Results and development needs**:
<!-- Briefly, what does the indicator say about the ecosystem condition. What is the current status of  the metric (can it be used or is it still in development), and what immediate tasks remain to improve the indicator or to make the indicator operational -->
The indicator is ready for use but should not be used at finer spatial resolution than counties.
Development needs include: refinement of the relationship between indicator values and ecosystem condition (linear vs. non-linear), and improved quantification of uncertainties related to the setting of the lower reference value.



## 2. About the underlying data

<!--# Give a general introduction the datasets you have used, and provide more specific details in the sub-chapters.  -->

### 2.1 Spatial and temporal resolution and extent

<!--# Describe the temporal and spatial resolution and extent of the data used -->

Data are available from 2000, when the underlying variables (introgran_pr, introfuru_pr) were first recorded.
Annual estimates are possible due to representative sampling every year.
For this indicator, all data from the last 5 years including the reporting year are used.
The data are representative for all forest land within the selected region.
Spatial resolution should be limited to counties.

### 2.2 Sampling design

<!-- How was the data sampled? Describe potential sampling biases -->

All trees larger than 5 cm at breast height (dbh) are recorded and identified to species for each 250 m² NFI inventory plot (@viken2021-feltinstruks).
There are about 12,000 NFI plots in forest ecosystems, distributed on a regular grid, with varying coverage for forest below/above the coniferous forest line and in Finnmark county.
All NFI plots are sampled over a 5-year period, with a representative sampling scheme every year, allowing unbiased estimates from data for each year.

### 2.3 Original units

<!--# What are the original units for the most relevant  variables in the data-->

The indicator is specified as the proportion (%) of forest stand tree volume (cutting class 3-5) or crown cover (cutting class 2) for introduced coniferous species (NFI variables introgran_pr, introfuru_pr).


### 2.4 Instructions for citing, using and accessing data

<!--# Is the data openly available? If not, how can one access it? What are the key references to the datasets?   -->

The data are available upon request from NFI (National Forest Inventory).
Key reference: @viken2021-feltinstruks.

### 2.5 Additional comments about the dataset

<!--# Optional. Text here -->

None

## 3. Indicator properties

### 3.1 Ecosystem Condition Typology Class (ECT)

<!--# Describe the rationale for assigning the indicator to the ECT class. See https://oneecosystem.pensoft.net/article/58218/
This doesnt need to be very long. Maybe just a single sentence. -->

The absence of alien species is considered an aspect of the composition of biodiversity.
Hence, this indicator represents a B1 Biotic compositional characteristic.

### 3.1.1 Other condition typologies

<!--# Optional: Add text about other standards or typologies, such as alternative national condition typologies, and how the indicator relates to these -->

None

### 3.2 Ecosystem condition characteristic

<!--# 

Describe the ecosystem condition characteristic represented in the indicator. See 10.3897/oneeco.6.e58218 for information on what these characteristics might be.
For example, and indicator called 'Trenching in mires' could be made to represent an ecosystem characteristic 'Intact hydrology'. The term 'characteristic' is used similar to the term 'criteria' in Multiple Criteria Decision Making.  

-->

The absence of alien species is considered an aspect of the composition of biodiversity.
The indicator represents a characteristic of Biodiversity.

### 3.3 Collinearities with other indicators

<!--# Describe known collinearities with other metrics (indicators or variables) that could become problematic if they were also included in the same Ecosystem Condition Assessment as the indicator described here. -->

There may be some positive correlation with the indicator for the absence of alien plant species, although the latter indicator is based on species in the field layer.

### 3.4 Impact factors

<!--# Describe the main natural and anthropogenic factors that affecst the metric -->

Natural disturbances and long-term shifts in climate conditions may increase the opportunity for alien species to spread and get established in otherwise intact forest ecosystems.
The planting of alien tree species in forestry is the most important anthropogenic driver for this indicator, although such planting has been reduced lately.
Harvested alien tree species may to some extent be replaced by native species.
Other planting of exotic trees in parks, gardens, as windbreaks etc will establish a source of such species that may spread into forest ecosystems.
Disturbances associated with forestry and other land use will also facilitate the natural establishment of alien species.
Human-induced climate change will also facilitate the spread and establishment of alien species.

### 3.6 Spatial aggregation

<!-- Describe in word the same aggregation pathway presented in the metadata.xlsx. If you have scaled against the reference value, it is especially important to know if you did any avergaing or summations etc. beforehand. An example text for a rather simple case could be: "The variable is scaled at the initial polygon level and the point estimate is a area-weighted arithmetic mean of all polygins. There is no transformation, and truncation is not needed as the indicator becomes naturally bound between 0 and 1".  -->

<!-- Spatial aggregation description to be added -->

## 4. Reference condition and levels

### 4.1 Reference condition

<!--# Define the reference condition (or refer to where it is defined). Note the distinction between reference condition and reference levels 10.3897/oneeco.5.e58216  -->

The reference condition is considered to be intact forest ecosystems, where effects of human activities are clearly subordinate to those of natural ecosystem processes and disturbances.

### 4.2 Reference levels

<!--# 

If relevant (i.e. if you have normalised a variable), describe the reference levels used to normalise the variable. 

Use the terminology where X~0~ refers to the reference level (the variable value) denoting the worst possible condition; X~100~denotes the optimum or best possible condition; and X~*n*~, where in is between 0 and 100, denotes any other anchoring points linking the variable scale to the indicator scale (e.g. the threshold value between good and bad condition X~60^). 

Why was the current option chosen and how were the reference levels quantified? If the reference values are calculated as part of the analyses further down, please repeat the main information here.

 -->

Intact forest ecosystems should not have any alien tree species.
An upper reference value (X~100~) for the absence of alien tree species is therefore 100%.
The lower reference value (X~0~) may be set to 0% (i.e. 100% alien species).
The relationship between indicator values and ecosystem condition is probably non-linear, with relatively more severe effects as the proportion of alien tree species increases.
However, due to lack of better knowledge, a linear relationship is assumed at this stage.
Hence, indicator values are scaled between 0 and 1 based on a linear scaling function between X~0~ and X~100~.

#### 4.2.1 Spatial resolution and validity

<!--# 

Describe the spatial resolution of the reference levels. E.g. is it defined as a fixed value for all areas, or does it vary. Also, at what spatial scale are the reference levels valid? For example, if the reference levels have a regional resolution (varies between regions), it might mean that it is only valid and correct to use for normalising local variable values that are first aggregated to regional scale. However, sometimes the reference levels are insensitive to this and can be used to scale variables at the local (e.g. plot) scale. 

 -->

The reference value will be given as an overall aggregated value for the absence of alien tree species for larger areas such as counties.
Although indicator values from NFI plots may technically be aggregated at finer spatial units than counties, scaling indicator values at such finer spatial levels may result in biases.

## 5. Uncertainties
### 5.1 General uncertainties
<!--# Describe the main reasons why you might not trust 100% the final value to represent the given ecosystem characteristic for the give ecosystem type. What aspects of this condition metric are most sensitive to subjective decitions? Is the spatial sampling sufficient? Does the choice of modeling framework affect the values? Is the metric relevant do describe ecosystem condition for the give ecosystem type?  -->

Uncertainties relate to the variability in the frequency of alien species among NFI plots and recording errors for tree species within NFI plots.
There is also uncertainty related to the setting of the lower reference value and to the shape of the relationship between indicator values and ecosystem condition.

### 5.2 Reported uncertainties
<!-- Describe the nature of the errors you (hopefully) provide alongside the point estimate for the condition metric. It is especially important to clarify if the errors are inferential (referring to the uncertainty of the point estimate) or descriptive (referreing to the data itself). Here' an example text: "What we report as uncertainties in @tbl-finalTable are inferential and refer to the uncertainty around the point estimates. It does not directly describe variation in the data itself. 
However, the variation in the mean is defined by the spatial variation only, and quartiles are obtained by bootstrapping the set of localities within a region, and calculating the indicator for each of 9999 such samples".   -->

Uncertainty is quantified by bootstrapping.
The uncertainties reported here are inferential and refer to the uncertainty around the point estimates, reflecting spatial variation among NFI plots and recording errors.
Additional uncertainties related to the setting of the lower reference value and the shape of the relationship between indicator values and ecosystem condition are not quantified.


## 6. References

::: {#refs}
:::

## 7. Import and prepare datasets

<!--# All the data import and preparation should be done in this chapter, before the analysis chapter. As a minimum, add code for importing data, and describe or show the data structure. You may also explain certain variables, what they represent, and their distributions -->

### 7.1 Alien coniferous tree species

All trees larger than 5 cm dbh are recorded and identified for each 250 m² NFI plot according to methods described in (@viken2021-feltinstruks).
For this indicator, data for the NFI variables introgran_pr and introfuru_pr from the last 5 years including the relevant reporting year are used.
Aggregated area-weighted data must be used for appropriate spatial units such as counties, regions or the whole country.
As the NFI plots vary in density for forest below/above the coniferous forest line and in Finnmark, each type of plot represents a different part of all forest land.
In addition, some NFI plots are divided in two parts in the data.
These variations in plot representativity must be accounted for in aggregated estimates.
Data from NFI contain an area-weighting variable to be used in aggregating NFI data for spatial units larger than individual NFI plots.

```{r load-data}

# Load main data file
lsk_data_raw <- read_csv(here("indicators", "NO_AATS_001", "data", "LSK_data_naturregnskap.csv"), 
                     show_col_types = FALSE,
                     locale = locale(encoding = "UTF-8")) |>
  clean_names()

```

```{r filter-data}

# Define multiple 5-year reporting periods starting from 2010
# Data starts in 2010, so we create 5-year periods: 2010-2014, 2015-2019, 2020-2024
reporting_periods <- list(
  "2010-2014" = 2010:2014,
  "2015-2019" = 2015:2019,
  "2020-2024" = 2020:2024
)

# Filter out Finnmark flats marked for removal (merket_finnm == 1)
# Keep all years for now, we'll filter by period in calculations
lsk_data <- lsk_data_raw |>
  filter(merket_finnm == 0 | is.na(merket_finnm)) |>
  # Keep only data from 2010 onward (start of reporting periods)
  filter(sesong >= 2010)

```

## 8. Spatial units

<!--# Describe the spatial units that you rely on in your analyses. Highlight the spatial units (the resolution) that the indicator values should be interpreted at. Potential spatial delineation data (maksing layers etc.) should be introduced under chapert 7. We recommend using the SEEA EA terminology of Basic Spatial Units (BSU), Ecosystem Asses (EA) and Ecosystem Accounting Area (EAA). -->

Aggregated indicator values should not be applied for spatial units finer than those that allow reliable estimates, probably counties (i.e., de facto Ecosystem Assets).

## 9. Analyses

<!--# 

Use this header for documenting the analyses. Put code in separate code chunks, and annotate the code in between using normal text (i.e. between the chunks, and try to avoid too many hashed out comments inside the code chunks). Add subheaders as needed. 

Code folding is activated, meaning the code will be hidden by default in the html (one can click to expand it).

Caching is also activated (from the top YAML), meaning that rendering to html will be quicker the second time you do it. This will create a folder inside you project folder (called INDICATORID_cache). Sometimes caching created problems because some operations are not rerun when they should be rerun. Try deleting the cash folder and try again.

-->

### 9.1 Create derived variables

This section creates the key derived variables needed for the indicator calculation. We first remove plots with missing data for alien species percentages to ensure reliable calculations.
We then standardise geography fields used throughout the analysis: `region_code` (first digit of `region_fylke`), the readable county name `region_fylke_name` (numeric prefixes removed), and a normalised join key `region_fylke_name_clean`.
Next, we compute the total percentage of alien conifers and derive the absence indicator (100 minus the alien percentage, truncated at 0–100).
Finally, we create area-weighted values by multiplying the indicator by the plot’s area weight.

```{r create-derived-variables}

# Remove rows with NA values for alien species percentages
lsk_data <- lsk_data |>
# IS THIS CORRECT TO REMOVE THE NAS?
  filter(!is.na(intro_gran_pr) & !is.na(intro_furu_pr)) |>
# Calculate derived variables and standardised region/fylke fields
  mutate(
    # Region code: first digit from region_fylke (e.g., '1' in '1-02 Oslo')
    region_code = stringr::str_extract(region_fylke, "^[0-9]"),

    # County/fylke name without numeric prefixes (remove leading digits and separators like '-' or space)
    region_fylke_name = stringr::str_squish(
      stringr::str_replace_all(region_fylke, "^\\d+[- ]*", "")
    ),

    # Cleaned (ascii, lowercase, de-punctuated) version for consistent joins/labels
    region_fylke_name_clean = stringi::stri_trans_general(
      stringr::str_squish(
        tolower(stringr::str_replace_all(region_fylke_name, "[0-9.-]", " ") )
      ),
      "Latin-ASCII"
    ),

    # Total percentage of alien coniferous species
    total_intro_conif = intro_gran_pr + intro_furu_pr,
    
    # Indicator value: % absence of alien species
    # Original units: proportion (%) of forest stand volume/crown cover for alien species
    # Absence = 100% - % alien species
    indicator_continuous = 100 - pmin(total_intro_conif, 100),
    
    # Weighted values: indicator value * au_areal
    indicator_continuous_weighted = indicator_continuous * au_areal
  )

```

### 9.2 Define reference values

This section establishes the reference levels needed for scaling the indicator values.
The reference condition is defined as intact forest ecosystems with no alien tree species.
The upper reference value (X100) is set to 100% absence (0% alien species), representing the best possible condition. 
The lower reference value (X0) is set to 0% absence (100% alien species), representing the worst possible condition. 
These values enable linear scaling of the indicator between 0 and 1.

```{r define-reference-values}

# - Reference condition: Intact forest ecosystems should not have any alien tree species
# - X100 (best condition): 100% absence of alien species (0% alien species)
# - X0 (worst condition): 0% absence (100% alien species)
# - Scaling: Linear relationship assumed between X0 and X100
# - Spatial resolution: Values are aggregated for larger areas (counties)

reference_values <- tibble(
  region = c("all"),
  x0 = 0,      # Worst condition: 0% absence (100% alien species)
  x100 = 100   # Best condition: 100% absence (0% alien species)
)

```

### 9.3 Calculate raw indicator values (non-scaled)

This section calculates area-weighted indicator values at different spatial scales for each 5‑year reporting period. 
We use a tidyverse workflow to iterate over all periods and return a list containing county, region and national results per period.
County results are grouped by `region_fylke_name`, region results by `region_code`, and national by a single overall group.
The national average is the area‑weighted mean across all plots.
Area‑weighting ensures that plots representing larger forest areas have proportionally greater influence on the final estimates.

```{r calculate-all-periods}

# Calculate indicators for all reporting periods (tidyverse/purrr)
all_results <- enframe(reporting_periods, name = "period", value = "years") |>
  mutate(res = map2(years, period, ~ calculate_period_indicators(lsk_data, .y, .x))) |>
  filter(!map_lgl(res, is.null))

# Combine results across all periods
results_county_all_periods  <- map_dfr(all_results$res, "county")
results_national_all_periods <- map_dfr(all_results$res, "national")
results_region_all_periods <- map_dfr(all_results$res, "region")

```

### 9.4 Bootstrap uncertainty estimation (non-scaled)

This section quantifies uncertainty in the non‑scaled indicator estimates for each period using a tidyverse mapping approach.
For each period, we bootstrap the national estimate from all plots and, separately, bootstrap county and region estimates by resampling plots within each county/region.
For testing and faster renders, the bootstrap iteration count is set to 200 (will be changed to 10000 for final reporting).
We then bind the results across periods to produce tidy frames with standard errors and 95% confidence intervals.

```{r bootstrap-all-periods}

# Period-wise bootstrap (non-scaled)
bootstrap_results_tbl <- all_results |>
  transmute(
    period,
    # County uncertainty: bootstrap within each county using the period's plot data
    county_boot = map(res, ~{
      period_data <- .x$data
      .x$county |>
        rowwise() |>
        mutate(
          county_data = list(period_data |> filter(region_fylke_name == cur_data()$region_fylke_name)),
          bootstrap_result = list(bootstrap_indicator(county_data, n_bootstrap = 200)),
          se = bootstrap_result$se,
          ci_lower = bootstrap_result$ci_lower,
          ci_upper = bootstrap_result$ci_upper
        ) |>
        select(-county_data, -bootstrap_result) |>
        ungroup()
    }),
    # Region uncertainty: bootstrap within each region using the period's plot data
    region_boot = map(res, ~{
      period_data <- .x$data
      .x$region |>
        rowwise() |>
        mutate(
          region_data = list(period_data |> filter(region_code == cur_data()$region_code)),
          bootstrap_result = list(bootstrap_indicator(region_data, n_bootstrap = 200)),
          se = bootstrap_result$se,
          ci_lower = bootstrap_result$ci_lower,
          ci_upper = bootstrap_result$ci_upper
        ) |>
        select(-region_data, -bootstrap_result) |>
        ungroup()
    }),
    # National uncertainty: bootstrap from all plots in the period
    national_boot = map(res, ~{
      period_data <- .x$data
      boot_nat <- bootstrap_indicator(period_data, n_bootstrap = 200)
      .x$national |>
        mutate(
          se = boot_nat$se,
          ci_lower = boot_nat$ci_lower,
          ci_upper = boot_nat$ci_upper
        )
    })
  )

# Combine bootstrap results across all periods (non-scaled)
results_county_non_scaled_uncertainty <- purrr::list_rbind(bootstrap_results_tbl$county_boot)
results_region_non_scaled_uncertainty <- purrr::list_rbind(bootstrap_results_tbl$region_boot)
results_national_non_scaled_uncertainty <- purrr::list_rbind(bootstrap_results_tbl$national_boot)

head(results_county_non_scaled_uncertainty)

```

### 9.5 Scale at county, then aggregate scaled to regions and national

In line with the specified workflow, we first scale the county values using the reference levels and then aggregate these scaled county values to the regions and to the national level using area weights.
County‑level uncertainty is obtained by linearly transforming the non‑scaled confidence limits.
For the aggregated levels, we compute uncertainty by mirroring the “scale‑then‑aggregate” workflow under bootstrap (200 iterations for test runs, will be changed to 10000 for final reporting) and then attach the resulting confidence intervals to the aggregated tables.

```{r scale-and-aggregate}

# County scaled values (point estimates) for all periods
county_scaled_all_periods <- results_county_all_periods %>%
  mutate(
    scaled_value = scale_indicator(
      indicator_value,
      reference_values$x0[1],
      reference_values$x100[1]
    )
  )

# Ensure region_code is present by joining from the source data (in case it was dropped upstream)
county_scaled_all_periods <- county_scaled_all_periods %>%
  left_join(
    lsk_data %>% distinct(region_fylke_name, region_code),
    by = "region_fylke_name"
  )

# Aggregate scaled county to regions (point estimates) for all periods
region_scaled_agg_all_periods <- county_scaled_all_periods %>%
  group_by(period, region_code) %>%
  summarise(
    scaled_value = sum(scaled_value * total_area, na.rm = TRUE) / sum(total_area, na.rm = TRUE),
    total_area = sum(total_area, na.rm = TRUE),
    n_plots = sum(n_plots, na.rm = TRUE),
    .groups = "drop"
  )

# Aggregate scaled county to national (point estimates) for all periods
national_scaled_agg_all_periods <- county_scaled_all_periods %>%
  group_by(period) %>%
  summarise(
    region = "National",
    scaled_value = sum(scaled_value * total_area, na.rm = TRUE) /
                   sum(total_area, na.rm = TRUE),
    total_area = sum(total_area, na.rm = TRUE),
    n_plots = sum(n_plots, na.rm = TRUE),
    .groups = "drop"
  )

# Uncertainty for county scaled: apply linear scaling to non-scaled CIs
county_scaled_with_uncertainty <- results_county_non_scaled_uncertainty %>%
  mutate(
    scaled_value = scale_indicator(indicator_value,
                                   reference_values$x0[1],
                                   reference_values$x100[1]),
    scaled_ci_lower = scale_indicator(ci_lower,
                                      reference_values$x0[1],
                                      reference_values$x100[1]),
    scaled_ci_upper = scale_indicator(ci_upper,
                                      reference_values$x0[1],
                                      reference_values$x100[1])
  )

# Bootstrap uncertainty for scaled-then-aggregated regions per period
region_scaled_uncertainty <- all_results |>
  transmute(
    period,
    by_region = map(res, ~ bootstrap_region_scaled_agg(
      .x$data,
      x0 = reference_values$x0[1],
      x100 = reference_values$x100[1],
      n_bootstrap = 200
    ))
  ) |>
  tidyr::unnest(by_region)

# Bootstrap uncertainty for scaled-then-aggregated national per period
national_scaled_uncertainty <- all_results |>
  transmute(
    period,
    bs = map(res, ~ bootstrap_national_scaled_agg(
      .x$data,
      x0 = reference_values$x0[1],
      x100 = reference_values$x100[1],
      n_bootstrap = 200
    ))
  ) |>
  mutate(
    region = "National",
    se = map_dbl(bs, "se"),
    ci_lower = map_dbl(bs, "ci_lower"),
    ci_upper = map_dbl(bs, "ci_upper")
  ) |>
  select(-bs)

# attach uncertainty
region_scaled_agg_with_uncertainty <- region_scaled_agg_all_periods %>%
  left_join(region_scaled_uncertainty, by = c("period", "region_code"))

national_scaled_agg_with_uncertainty <- national_scaled_agg_all_periods %>%
  left_join(national_scaled_uncertainty, by = c("period", "region"))

```

## 10. Results

The following tables present the indicator results at county, regional and national scales for each reporting period. 
All values are scaled between 0 and 1, where 0 represents the worst condition (0% absence of alien species) and 1 represents the best condition (100% absence of alien species).
Where relevant, 95% confidence intervals are shown.

### 10.1 County-level results (scaled with uncertainty)

```{r tbl-county-results-table}
#| tbl-cap: 'County-level indicator values for absence of alien coniferous tree species by reporting period'
#| echo: false

county_tbl_df <- county_scaled_with_uncertainty |>
  select(period, region_fylke_name, indicator_value, scaled_value, se, ci_lower, ci_upper, total_area, n_plots) |>
  mutate(
    indicator_value = round(indicator_value, 2),
    scaled_value = round(scaled_value, 3),
    se = round(se, 2),
    ci_lower = round(ci_lower, 2),
    ci_upper = round(ci_upper, 2),
    total_area = round(total_area, 0)
  ) |>
  rename(
    Period = period,
    County = region_fylke_name,
    `Indicator Value (%)` = indicator_value,
    `Scaled Value` = scaled_value,
    `Standard Error` = se,
    `CI Lower` = ci_lower,
    `CI Upper` = ci_upper,
    `Total Area (ha)` = total_area,
    `Number of Plots` = n_plots
  )

DT::datatable(
  county_tbl_df,
  rownames = FALSE,
  options = list(pageLength = 10, scrollX = TRUE, lengthMenu = c(10, 25, 50, 100))
)
```

#### Map – county-level scaled values across reporting periods

```{r fig-map-county-latest}
#| fig-cap: 'Scaled indicator values by county across reporting periods'
#| warning: false
#| message: false

# Get official county (admin level 1) boundaries for Norway from GADM
# Cache locally in the indicator data folder to avoid repeated downloads
shp_cache_path <- here::here("indicators", "NO_AATS_001", "data", "gadm_NOR_1.rds")
if (file.exists(shp_cache_path)) {
  norway_counties <- readRDS(shp_cache_path)
} else {
  gadm <- geodata::gadm("NOR", level = 1, path = tempdir())
  norway_counties <- sf::st_as_sf(gadm) |> janitor::clean_names()
  saveRDS(norway_counties, shp_cache_path)
}

# Helper to clean names like we did for table
clean_nm <- function(x) {
  stringi::stri_trans_general(
    str_squish(tolower(str_replace_all(x, "[0-9.-]", " "))),
    "Latin-ASCII"
  )
}

# GADM county name field is NAME_1 (cleaned to name_1 by janitor)
geom_key <- "name_1"

# Build cleaned name on geometry too
norway_counties <- norway_counties |>
  dplyr::mutate(
    geom_name_clean = clean_nm(.data[[geom_key]])
  )

# Collapse multipart county polygons to one feature per county name
norway_counties_collapsed <- norway_counties |>
  dplyr::group_by(geom_name_clean) |>
  dplyr::summarise(.groups = "drop") |>
  sf::st_make_valid()

# Prepare county data across all periods (keep only required columns and distinct rows), harmonize names
county_for_join <- county_scaled_all_periods |>
  dplyr::mutate(region_fylke_name_clean = clean_nm(region_fylke_name)) |>
  dplyr::mutate(
    region_fylke_name_clean = dplyr::case_when(
      region_fylke_name_clean %in% c("troms", "finnmark") ~ "troms og finnmark",
      region_fylke_name_clean %in% c("vestfold", "telemark") ~ "vestfold og telemark",
      region_fylke_name_clean %in% c("akershus", "ostfold", "buskerud") ~ "viken",
      TRUE ~ region_fylke_name_clean
    )
  ) |>
  dplyr::select(period, region_fylke_name_clean, scaled_value) |>
  dplyr::distinct()

# Join on cleaned names directly (across all periods)
joined <- norway_counties_collapsed |>
  dplyr::left_join(county_for_join, by = c("geom_name_clean" = "region_fylke_name_clean"))

# Simple choropleth of scaled value (0-1)
ggplot(joined) +
  geom_sf(aes(fill = scaled_value), color = "grey30", size = 0.1) +
  scale_fill_viridis_c(name = "Scaled value", limits = c(0,1), na.value = "#f0f0f0") +
  facet_wrap(~ period) +
  theme_minimal() +
  theme(legend.position = "right")
```


### 10.2 Regional results (aggregated with uncertainty)

```{r tbl-region-results-table}
#| tbl-cap: 'Regional scaled indicator values by reporting period (with 95% CI)'
#| echo: false

region_scaled_agg_with_uncertainty |>
  select(period, region_code, scaled_value, se, ci_lower, ci_upper, total_area, n_plots) |>
  mutate(
    scaled_value = round(scaled_value, 3),
    se = round(se %||% NA_real_, 3),
    ci_lower = round(ci_lower %||% NA_real_, 3),
    ci_upper = round(ci_upper %||% NA_real_, 3),
    total_area = round(total_area, 0)
  ) |>
  rename(
    Period = period,
    Region = region_code,
    `Scaled Value` = scaled_value,
    `Standard Error` = se,
    `CI Lower` = ci_lower,
    `CI Upper` = ci_upper,
    `Total Area (ha)` = total_area,
    `Number of Plots` = n_plots
  ) |>
  kable() |>
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))
```

#### Map – regional scaled values across reporting periods

```{r fig-map-region-periods}
#| fig-cap: 'Scaled indicator values by region across reporting periods'
#| warning: false
#| message: false

# Helper cleaner (same as above)
clean_nm <- function(x) {
  stringi::stri_trans_general(
    str_squish(tolower(str_replace_all(x, "[0-9.-]", " "))),
    "Latin-ASCII"
  )
}

# Load regions layer from NO_ALIE folder (suggested source)
regions_layer <- sf::st_read(
  here::here("indicators", "NO_ALIE_001", "data", "regions.shp"),
  quiet = TRUE
) |> janitor::clean_names()

# Try to detect a name/label column for regions (first character/factor column)
char_cols <- names(regions_layer)[sapply(regions_layer, function(col) is.character(col) || is.factor(col))]
region_name_col <- if (length(char_cols)) char_cols[1] else names(regions_layer)[1]

regions_geom <- regions_layer |>
  dplyr::mutate(
    region_name_raw = .data[[region_name_col]],
    region_name_clean = clean_nm(region_name_raw),
    region_code = dplyr::case_when(
      grepl("^ost|^øst", region_name_clean) ~ "1",
      grepl("^sor|^sør", region_name_clean) ~ "2",
      grepl("^vest", region_name_clean) ~ "3",
      grepl("^midt", region_name_clean) ~ "4",
      grepl("^nord", region_name_clean) ~ "5",
      TRUE ~ region_name_clean
    ),
    region_name = dplyr::case_when(
      region_code == "1" ~ "Øst",
      region_code == "2" ~ "Sør",
      region_code == "3" ~ "Vest",
      region_code == "4" ~ "Midt",
      region_code == "5" ~ "Nord",
      TRUE ~ region_name_raw
    )
  ) |>
  sf::st_make_valid()

# Diagnostics: geometry vs data names and multi-region counties
geom_names <- norway_counties |> dplyr::pull(name_1) |> clean_nm() |> unique()
data_names <- county_scaled_all_periods |>
  dplyr::mutate(region_fylke_name_clean = clean_nm(region_fylke_name)) |>
  dplyr::pull(region_fylke_name_clean) |> unique()

cat("\n[Diag] In geometry but not in data (first 20):\n")
print(utils::head(setdiff(geom_names, data_names), 20))
cat("\n[Diag] In data but not in geometry (first 20):\n")
print(utils::head(setdiff(data_names, geom_names), 20))

multi_region_counties <- lsk_data |>
  dplyr::mutate(region_fylke_name_clean = clean_nm(region_fylke_name)) |>
  dplyr::group_by(region_fylke_name_clean) |>
  dplyr::summarise(n_regions = dplyr::n_distinct(region_code),
                   regions = paste(sort(unique(region_code)), collapse = ","), .groups = "drop") |>
  dplyr::filter(n_regions > 1) |>
  dplyr::arrange(desc(n_regions))
cat("\n[Diag] Counties mapped to multiple regions in data:\n")
print(multi_region_counties)

dominant_region_by_period <- lsk_data |>
  dplyr::filter(sesong %in% unlist(reporting_periods)) |>
  dplyr::mutate(period = dplyr::case_when(
    sesong %in% reporting_periods[[1]] ~ names(reporting_periods)[1],
    sesong %in% reporting_periods[[2]] ~ names(reporting_periods)[2],
    sesong %in% reporting_periods[[3]] ~ names(reporting_periods)[3]
  )) |>
  dplyr::mutate(region_fylke_name_clean = clean_nm(region_fylke_name)) |>
  dplyr::group_by(period, region_fylke_name_clean, region_code) |>
  dplyr::summarise(area_weight = sum(au_areal, na.rm = TRUE), .groups = "drop") |>
  dplyr::group_by(period, region_fylke_name_clean) |>
  dplyr::slice_max(area_weight, n = 1) |>
  dplyr::distinct(period, region_fylke_name_clean, .keep_all = TRUE) |>
  dplyr::ungroup()
cat("\n[Diag] Dominant region per county and period (first 20):\n")
print(utils::head(dominant_region_by_period, 20))

# Prepare values per period
region_values <- region_scaled_agg_all_periods |>
  dplyr::select(period, region_code, scaled_value) |>
  dplyr::distinct()

regions_joined <- regions_geom |>
  dplyr::left_join(region_values, by = "region_code")

ggplot(regions_joined) +
  geom_sf(aes(fill = scaled_value), color = "grey30", size = 0.1) +
  scale_fill_viridis_c(name = "Scaled value", limits = c(0,1), na.value = "#f0f0f0") +
  facet_wrap(~ period) +
  theme_minimal() +
  theme(legend.position = "right")
```

### 10.3 National results (aggregated with uncertainty)

```{r tbl-national-results-table}
#| tbl-cap: 'National scaled indicator values by reporting period (with 95% CI)'
#| echo: false

national_scaled_agg_with_uncertainty |>
  select(period, region, scaled_value, se, ci_lower, ci_upper, total_area, n_plots) |>
  mutate(
    scaled_value = round(scaled_value, 3),
    se = round(se, 3),
    ci_lower = round(ci_lower, 3),
    ci_upper = round(ci_upper, 3),
    total_area = round(total_area, 0)
  ) |>
  rename(
    Period = period,
    `Spatial Level` = region,
    `Scaled Value` = scaled_value,
    `Standard Error` = se,
    `CI Lower` = ci_lower,
    `CI Upper` = ci_upper,
    `Total Area (ha)` = total_area,
    `Number of Plots` = n_plots
  ) |>
  kable() |>
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))
```




<!--# ## 11. Export file -->

<!--# 

Optional: Display the code (don't execute it) or the workflow for exporting the indicator values to file. Ideally the indicator values are exported as a georeferenced shape or raster file with indicators values, reference values and errors. You can also chose to export the raw (un-normalised or unscaled variable) as a separate product. You should not save large sptaial output data on GitHub. You can use eval=FALSE to avoid code from being executed (example below - delete if not relevant) 

-->

<!-- Export code to be added -->

```{r export}
#| eval: false
```

<!-- You can leave this last part as it is, unless you have a good reason to alter it. -->

::: {.callout-tip collapse="true"}
## Session Info

This information is mainly aimed at developers that need to recreate the R environment that produced the html.
Important note: this information is about the R session that was running when the html was rendered, and if some of the code chunks were not evaluated when the html was rendered, they may have been executed in a different environment.  

```{r sessionInfo}
#| echo: false
sessionInfo()
```

:::