---
title: "Dead trees by volume as share of volume of all trees in productive forests"
subtitle: |
  NO_DTVS_001
indicatorID: 
  - NO_DTVS_001
indicatorName: 
  - Dead trees by volume as share of volume of all trees in productive forests
folderName: NO_DTVS_001
country: Norway
continent: Europe
ECT: B1 Biotic compositional characteristic
Realm: 
  - Terrestrial (T)
Biome: 
  - T2 Temperate-boreal forests and woodlands biome
Ecosystem: 
  - T2.1 Boreal/montane forests
yearAdded: 2025
yearLastUpdate: 2025
status: incomplete # options are complete, incomplete, or deprecated
Version: "000.001" # Beta-versions are numbers incrementally with values below 0. Operational versions can be given the version numbers above 0. Use this terms similar as for software versioning,
VersionComment: Initial version # Describe briefly how this version differs from earlier versions 
url: https://github.com/NINAnor/ecRxiv/tree/main/indicators/NO_DTVS_001
# Leave the url as is, but replace XX_YYYY_ZZ with the name of the root folder for the current indicator(s). It should be the same as the indicatorID, but if there are more indicator IDs presented in the same folder, the folder name might be different, e.g. XX_YYYY_AAA-BBB 
Normalised: Yes
SpatialAggregationPathway: Scale - Aggregate - Truncate # e.g. Scale - Transform - Aggregate (length-weighted arithmetic mean) - Truncate
format: 
  html:
    embed-resources: true
    code-fold: true
    toc: true
    toc-title: Contents
    toc-depth: 3
    smooth-scroll: true
execute: 
  cache: true
author:
  - name: Erik Framstad
    email: erik.framstad@nina.no
    affiliations:
      - name: Norwegian Institute for Nature Research
  - name: Ken Olav Storaunet
    affiliations:
      - name: Norwegian Institute of Bioeconomy Research
  - name: Aud Helen Halbritter
    affiliations:
      - name: University of Bergen
AuthorList: Framstad, E., Storaunet, K.O. and Halbritter, A. H.
date: November 8, 2025
data_availability: none
code_reproducibility: silver
open_science_badge: none
callout-icon: false
lightbox: true
css: ../../../style.css
bibliography: bibliography.bib
code-links:
      - text: Add a review
        icon: github
        href: https://github.com/NINAnor/ecRxiv
hide: FALSE
---

<!--# This is a template for how to document the indicator analyses. Make sure also to not change the order, or modify, the headers, unless you really need to. This is because it easier to read if all the indicators are presented using the same layout. If there is one header where you don't have anything to write, just leave the header as is, and don't write anything below it. If you are providing code, be careful to annotate and comment on every step in the analysis. Before starting it is recommended to fill in as much as you can in the metadata file. This file will populate the initial table in your output.-->

<!--# Load all you dependencies here -->

```{r setup}
#| include: false
#| cache: false
library(knitr)
library(tidyverse)
library(kableExtra)
library(here)
library(anybadger)
library(yaml)
library(tibble)
library(conflicted)
library(janitor)
library(stringi)
library(DT)
library(gt)
# weird workarounds for cache issues
conflicts_prefer(dplyr::filter)
conflicts_prefer(dplyr::lag)
conflicts_prefer(dplyr::select)
pull<-dplyr::pull

knitr::opts_chunk$set(echo = TRUE)
```

```{r source}
#| echo: false
#| cache: false
source(here::here("_common.R"))
source(here("indicators/NO_DTVS_001/R/functions.R"))
source(here::here("extract_yaml.R"))
```


<!--# The following parts are autogenerated. Do not edit. -->

::: {layout-ncol="5"}

```{r statusBadge}
#| echo: false
status_badge(as.character(st))
```

```{r versionBadge}
#| echo: false
version_badge(my_version_number = version[[1]],
  folder_name = folder_name)
```

```{r dataBadge}
#| echo: false
data_badge(as.character(badges[[1]]))
```

```{r codeBadge}
#| echo: false
code_badge(as.character(badges[[2]]))
```

```{r openScienceBadge}
#| echo: false
open_science_badge(as.character(badges[[3]]))
```
::: 
 

> **Recommended citation**: `r paste(auth, " ", year, ". ", name, " (ID: ", id, ") ", "v. ", version, ". ecRxiv: ", url, sep="")`



::: {.callout-tip collapse="true"}
## Metadata
```{r tbl-meta2}
#| tbl-cap: 'Indicator metadata'
#| echo: false
#| warning: false
meta |>
  dplyr::filter(Variable %in% c(
    "Indicator ID",
    "Indicator Name",
    "Continent",
    "Country",
    "Ecosystem Condition Typology Class", 
    "Realm",
    "Biome",
    "Ecosystem",
    "Year added", 
    "Last update",
    "Version",
    "Version comment",
    "Normalised",
    "Spatial aggregation pathway")) |>   
  kable()

```
:::

::: {.callout-tip collapse="true"}

## Log

<!--# Update this logg with short messages for each update -->
- 11 Nov. 2025 - Original PR
:::


<hr />

<!--# Document you work below.  -->

## 1. Summary

1. **Background and rationale**:
The volume of dead wood as a share of the volume of all living, dead and harvested wood is a robust measure of the naturalness of forests.
Dead wood is a key resource as substrate or food for a wide range of forest organisms, especially fungi and invertebrates.
However, the expected volumes of both dead and living wood in intact forest ecosystems vary between forest types depending on site productivity, dominating tree species and climate conditions.
By comparing the volume of dead wood to the volume of all wood for the same geographical area, the effects of such site factors may partly be cancelled.

2. **Methods**:
Data for this indicator come from the National Forest Inventory (NFI), where the volume of living and standing dead trees, as well as the cumulative volume of harvested trees have been recorded for each NFI plot since the mid-1990s and lying dead wood since 2010 (by current methods).
The volume of harvested trees does not cover trees harvested before 1986.
Hence, the estimate of the indicator value is a bit too high.

3. **Interpretation**:
Recorded dead wood volume as a share of the volume of all wood is compared to a reference value for all productive forest, based on expert assessments supported by empirical data for near-natural forests and knowledge of ecosystem dynamics in intact forest ecosystems [@storaunet-skarpaas-2022].
The overall reference value for the share of dead wood of all wood is 33% for productive forest (a reference value for unproductive forest has not yet been set).

4. **Results and development needs**:
The indicator is ready for use.
The indicator should not be used at finer spatial resolution than applied to the reference values.

## 2. About the underlying data

The volume of living trees and standing and lying dead wood > 10 cm in diameter is recorded for each NFI inventory plot [@viken2021-feltinstruks]. 
The NFI plot data also include a measure of the cumulative volume of trees harvested since the establishment of permanent inventory plots in the late 1980s.
There are about 12 000 NFI plots in forest ecosystems, distributed on a regular grid, with varying grid density for forest below/above the coniferous forest line and in Finnmark county.
The indicator value is an unbiased area-weighted estimate of the proportion of dead wood volume relative to the volume of all living, harvested and dead wood for included NFI plots in any selected region.
All NFI plots are sampled over a 5-year period, with a representative sampling scheme every year, allowing unbiased estimates from data for each year.
For this indicator data from each full inventory cycle of 5 years are used, starting in 2010, meaning that results reported for 2024 are based on data from the years 2020-2024.
The data are available upon request from NFI. 

### 2.1 Spatial and temporal extent, resolution, and representativity

Data are available from 2010, when the volume of lying dead wood was first recorded based on current methods. A different method for quantifying the volume of dead wood was applied during the 1994-1998 forest inventory. Annual estimates are possible due to representative sampling every year. For this indicator all data from each full inventory cycle of 5 years are used, starting in 2010. The data are representative for all productiver forest land of Norway. Spatial resolution should be limited to the resolution applied to reference values, e.g., regions.

### 2.2 Sampling design


### 2.3 Original units

The indicator is specified as the share (%) of the volume of dead wood to all living, harvested and dead wood.

### 2.3 Instructions for citing, using and accessing data

The data used for this indicator have been made available by the Norwegian National Forest Inventory under a specific data use agreement of 2025-10-20, between NIBIO and the specified users.
Further use of these data requires a separate data user agreement with NIBIO.

### 2.4 Additional comments about the dataset

None

## 3. Indicator properties

### 3.1 Ecosystem Condition Typology Class (ECT)

The indicator represents particularly important structures for species dependent on intact forest ecosystems. Hence, this indicator represents a B2 Biotic structural characteristic.

### 3.1.1 Other condition typologies

None

### 3.2 Ecosystem condition characteristic

The indicator represents functionally important structures in intact forests, and the indicator is characterised as Functionally important species and biophysical structures.

### 3.3 Collinearities with other indicators

Some correlation with other indicators for old or intact forest, such as biologically old forest, may be expected.

### 3.4 Impact factors

Natural disturbances at different temporal and spatial scales, such as fires, floods, windthrows, snow breaks, attacks by pathogens, or tree senescence, will contribute to the production of dead wood.
Forestry may produce dead wood of small dimensions and coarser dead wood to a limited degree. 
Empirical data show a negative relationship between the share of dead wood to all living and dead wood and the number of stumps per hectare, as a measure of logging activity [@storaunet-skarpaas-2022].
Forest fire prevention and salvage logging after fires or windthrows reduce the availability of dead wood.
Human climate change may increase the decomposition rate of dead wood, whereas increased frequency and severity of storms will increase production of dead wood.

### 3.5 Spatial aggregation

...


## 4. Reference condition and levels

### 4.1 Reference condition

The reference condition is considered to be intact forest ecosystems where effects of human activities are clearly subordinate to those of natural ecosystem processes and disturbances. 

### 4.2 Reference levels

The reference value is based on expert assessments of the relationship between the indicator and measures of logging impact, based on reported dead wood data for a range of site conditions and dominating tree species [@storaunet-skarpaas-2022; and references therein].
A proportion of 1/3 dead wood to all living, harvested and dead wood (by volume) is judged to be a robust measure for forests with only minor impact from forestry over the last 100 years for a range of site conditions and dominating tree species. Reference values are expert assessments without estimated uncertainty.
Hence, the upper reference value (X100) is set to 33% and the lower reference value (X0) is set to 0%.
For lack of better knowledge, the relationship between indicator values and ecosystem condition is assumed to be linear for values between X100 and X0.
Hence, indicator values are scaled between 0 and 1 based on a linear scaling function between X0 and X100; scaled indicator values above 1 are truncated to 1.

#### 4.2.1 Spatial resolution and validity

The reference value is given as an overall aggregated value for the share by volume of dead wood to all living, harvested and dead wood for larger areas, such as regions.
Although indicator values from NFI plots may technically be aggregated at finer spatial units than counties, scaling indicator values at such finer spatial levels may result in biases.

### 5.1 General uncertainties

Uncertainties relate to the variability of the volume of living, harvested and dead wood among NFI plots and to the measurements of this volume for each NFI plot.
This combined uncertainty is quantified by bootstrapping.
There is also uncertainty related to the setting of the upper reference value and to the shape of the relationship between indicator values and ecosystem condition.
These uncertainties are not quantified.

## 6. References

::: {#refs}
:::

## 7. Import and prepare datasets

### 7.1 Living, harvested and dead wood volume per hectare

The volumes of living and dead wood per hectare are quantified for each NFI plot according to methods described in [@viken2021-feltinstruks].
Harvested volume within each plot is quantified as the cumulative volume of harvested trees since the establishment of the permanent NFI-plots in the late 1980s.).
For this indicator data from each full 5-yr inventory cycle, starting in 2010, are used. Aggregated area-weighted data must be used for appropriate spatial units such as counties, regions or the whole country.
As the NFI plots vary in density for forest below/above the coniferous forest line and in Finnmark, each type of plot represents a different part of all forest land.
In addition, some NFI plots are divided in two parts in the data.
These variations in plot representativity must be accounted for in aggregated estimates. 
Normally, data from NFI will contain an area-weighting variable to be used in aggregating NFI data for spatial units larger than individual NFI plots. 

```{r load-data}
#| code-summary: "Load data"
#| eval: false

# Load main data file
lsk_data_raw <- read_csv(here("indicators/NO_DTVS_001/data/LSK_data_naturregnskap.csv"), 
                     show_col_types = FALSE,
                     locale = locale(encoding = "UTF-8")) |>
  clean_names()

```


## 8. Spatial units

Aggregated indicator values should not be applied for spatial units finer than those that allow reliable estimates, e.g., regions.

## 9. Analyses

### 9.1 Prepare data and create derived variables

This section prepares the NFI plot data for calculating the indicator.
We retain both productive and unproductive forest plots (`arealtype` 1 and 12), and then create the derived variables used in subsequent aggregation steps.

First we define the 5-year reporting periods that match the temporal structure of the indicator.

```{r reporting-periods}
#| code-summary: "Define reporting periods"
#| eval: false
# Define multiple 5-year reporting periods starting from 2010
reporting_periods <- list(
  "2010-2014" = 2010:2014,
  "2015-2019" = 2015:2019,
  "2020-2024" = 2020:2024
)

```

Next we filter the raw dataset to include only the two relevant forest area types, remove records missing the required volume variables, standardise the geography fields, and compute the share of dead wood volume relative to all wood volume.
The indicator is calculated as `dw_prha / (dw_prha + vm10_prha + kum_avvirka_prha)`, where `dw_prha` is dead wood volume per hectare, `vm10_prha` is living wood volume per hectare, and `kum_avvirka_prha` is cumulative harvested wood volume per hectare.
Area-weighted values are created using `au_areal`.

```{r create-derived-variables}
#| cache: false
#| code-summary: "Create derived variables"
#| eval: false

lsk_data <- lsk_data_raw |>
  filter(
    arealtype %in% c(1, 12)
  ) |>
  filter(!is.na(dw_prha), !is.na(vm10_prha), !is.na(kum_avvirka_prha)) |>
  mutate(
    fylke_name = region_fylke |>
      stringr::str_remove("^\\d+-\\d+\\s+") |>
      stringr::str_remove("^\\d+\\s*") |>
      stringr::str_squish(),
    fylke_name = normalize_county_parts(fylke_name),
    fylke_name_clean = stringi::stri_trans_general(
      stringr::str_squish(
        tolower(stringr::str_replace_all(fylke_name, "[0-9.-]", " "))
      ),
      "Latin-ASCII"
    ),
    region_code = assign_region_code(fylke_name_clean),
    region_name = assign_region_name(region_code),
    
    # Calculate total wood volume (dead + living + harvested)
    total_wood_volume = dw_prha + vm10_prha + kum_avvirka_prha,
    # Indicator value: proportion of dead wood volume to total wood volume
    dead_wood_share = if_else(total_wood_volume > 0, dw_prha / total_wood_volume, 0),
    dead_wood_share_weighted = dead_wood_share * au_areal,
    indicator_continuous = dead_wood_share,
    indicator_continuous_weighted = dead_wood_share_weighted
  )

```

Finally, we retain only the columns required for subsequent aggregation and reporting.

```{r select-downstream-fields}
#| code-summary: "Select downstream fields"
#| eval: false

lsk_data <- lsk_data |>
  dplyr::select(
    sesong,
    au_areal,
    arealtype,
    region_code,
    region_name,
    fylke_name,
    fylke_name_clean,
    dw_prha,
    vm10_prha,
    kum_avvirka_prha,
    total_wood_volume,
    dead_wood_share,
    dead_wood_share_weighted,
    indicator_continuous,
    indicator_continuous_weighted
  )

```

The indicator will be scaled against a reference value of 33% (0.33) for the whole country in subsequent steps.

### 9.2 Calculate non-scaled area-weighted indicator values

With the indicator-specific values we produce area-weighted summaries for each reporting period at county, region, and national scales.

```{r calculate-dtvs-all-periods}
#| code-summary: "Calculate non-scaled values"
#| eval: false

 dtvs_results <- purrr::imap(
   reporting_periods,
   ~ calculate_period_indicators(lsk_data, .y, .x)
 ) |>
   purrr::compact()
 
 dtvs_results_county_all_periods   <- purrr::map_dfr(dtvs_results, "county")
 dtvs_results_region_all_periods   <- purrr::map_dfr(dtvs_results, "region")
 dtvs_results_national_all_periods <- purrr::map_dfr(dtvs_results, "national")

```

### 9.3 Bootstrap uncertainty estimation for non-scaled indicator values

Uncertainty in the non-scaled indicator estimates is quantified using bootstrapping.
For each 5-year period we resample the plot dataset, calculate area-weighted indicator values, and summarise the distribution for counties, regions, and the national aggregate.

```{r bootstrap-dtvs-all-periods}
#| code-summary: "Bootstrap uncertainty"
#| eval: false

# Prepare bootstrap objects per reporting period
 dtvs_bootstrap <- dtvs_results |>
   purrr::imap(
     ~ list(
       period = .y,
       data = .x$data,
       county = .x$county,
       region = .x$region,
       national = .x$national,
      national_boot = bootstrap_indicator(.x$data, n_bootstrap = 1000),
       county_boot = purrr::map(
         split(.x$data, .x$data$fylke_name),
        ~ bootstrap_indicator(.x, n_bootstrap = 1000)
       ),
       region_boot = purrr::map(
         split(.x$data, .x$data$region_code),
        ~ bootstrap_indicator(.x, n_bootstrap = 1000)
       )
     )
   )

# County-level summaries with uncertainty
 dtvs_results_county_non_scaled_uncertainty <- purrr::map_dfr(
   dtvs_bootstrap,
   ~ {
     county_summary <- purrr::imap_dfr(
       .x$county_boot,
       function(boot, county_name) {
         dplyr::tibble(
           fylke_name = county_name,
          mean = boot$mean,
           indicator_value = boot$median,
           se = boot$se,
           ci_lower = boot$ci_lower,
           ci_upper = boot$ci_upper,
           q1 = boot$q1,
           median = boot$median,
           q3 = boot$q3
         )
       }
     )

     .x$county |>
       dplyr::select(fylke_name, period, total_area, n_plots) |>
       dplyr::left_join(county_summary, by = "fylke_name")
   }
 )

# Region-level summaries with uncertainty
 dtvs_results_region_non_scaled_uncertainty <- purrr::map_dfr(
   dtvs_bootstrap,
   ~ {
     region_summary <- purrr::imap_dfr(
       .x$region_boot,
       function(boot, region_code) {
         dplyr::tibble(
           region_code = region_code,
          mean = boot$mean,
           indicator_value = boot$median,
           se = boot$se,
           ci_lower = boot$ci_lower,
           ci_upper = boot$ci_upper,
           q1 = boot$q1,
           median = boot$median,
           q3 = boot$q3
         )
       }
     )

     .x$region |>
       dplyr::select(region_code, period, total_area, n_plots) |>
       dplyr::left_join(region_summary, by = "region_code")
   }
 )

# National-level summaries with uncertainty
 dtvs_results_national_non_scaled_uncertainty <- purrr::map_dfr(
   dtvs_bootstrap,
   ~ .x$national |>
     dplyr::mutate(
      mean = .x$national_boot$mean,
       indicator_value = .x$national_boot$median,
       se = .x$national_boot$se,
       ci_lower = .x$national_boot$ci_lower,
       ci_upper = .x$national_boot$ci_upper,
       q1 = .x$national_boot$q1,
       median = .x$national_boot$median,
       q3 = .x$national_boot$q3
     )
 )

```

### 9.4 Scale indicator values and aggregate to regional and national levels

Since the reference value (33%) is defined at a higher spatial level, we first aggregate non-scaled indicator values to regional and national levels, then scale these aggregated values using the reference levels.
The `scale_indicator` function automatically truncates values above 1 (i.e., values exceeding 33% are scaled to 1).
For uncertainty estimation, we use bootstrap functions that perform scale-then-aggregate to properly account for the scaling operation in the uncertainty propagation.

```{r scale-and-aggregate}
#| code-summary: "Scale and aggregate"
#| eval: false

# Define reference values: x0 = 0% (worst condition), x100 = 33% (best condition)
x0 <- 0
x100 <- 0.33

# Scale county values (point estimates) for all periods
county_scaled_all_periods <- dtvs_results_county_all_periods |>
  dplyr::mutate(
    scaled_value = scale_indicator(indicator_value, x0, x100)
  )

# Uncertainty for county scaled: apply linear scaling to non-scaled CIs and quartiles
county_scaled_with_uncertainty <- dtvs_results_county_non_scaled_uncertainty |>
  dplyr::mutate(
    scaled_mean = scale_indicator(mean, x0, x100),
    scaled_median = scale_indicator(indicator_value, x0, x100),
    scaled_ci_lower = scale_indicator(ci_lower, x0, x100),
    scaled_ci_upper = scale_indicator(ci_upper, x0, x100),
    scaled_q1 = scale_indicator(q1, x0, x100),
    scaled_q3 = scale_indicator(q3, x0, x100)
  )

# Aggregate non-scaled values to regional level (point estimates) for all periods
region_non_scaled_agg_all_periods <- dtvs_results_region_all_periods |>
  dplyr::group_by(period, region_code) |>
  dplyr::summarise(
    indicator_value = sum(indicator_value * total_area, na.rm = TRUE) / sum(total_area, na.rm = TRUE),
    total_area = sum(total_area, na.rm = TRUE),
    n_plots = sum(n_plots, na.rm = TRUE),
    .groups = "drop"
  )

# Scale aggregated regional values
region_scaled_agg_all_periods <- region_non_scaled_agg_all_periods |>
  dplyr::mutate(
    scaled_value = scale_indicator(indicator_value, x0, x100),
    region_name = assign_region_name(region_code)
  )

# Aggregate non-scaled values to national level (point estimates) for all periods
national_non_scaled_agg_all_periods <- dtvs_results_national_all_periods |>
  dplyr::group_by(period) |>
  dplyr::summarise(
    indicator_value = sum(indicator_value * total_area, na.rm = TRUE) / sum(total_area, na.rm = TRUE),
    total_area = sum(total_area, na.rm = TRUE),
    n_plots = sum(n_plots, na.rm = TRUE),
    .groups = "drop"
  )

# Scale aggregated national values
national_scaled_agg_all_periods <- national_non_scaled_agg_all_periods |>
  dplyr::mutate(
    scaled_value = scale_indicator(indicator_value, x0, x100),
    region = "National"
  )

# Check for truncation: count values exceeding 33% (x100)
truncation_summary <- dplyr::bind_rows(
  dtvs_results_county_all_periods |>
    dplyr::mutate(
      level = "County",
      exceeds_threshold = indicator_value > x100,
      original_value_pct = round(indicator_value * 100, 2),
      region_code = NA_character_,
      region_name = NA_character_
    ) |>
    dplyr::select(period, level, region_code, region_name, fylke_name, exceeds_threshold, original_value_pct),
  region_non_scaled_agg_all_periods |>
    dplyr::mutate(
      level = "Region",
      exceeds_threshold = indicator_value > x100,
      original_value_pct = round(indicator_value * 100, 2),
      region_name = assign_region_name(region_code),
      fylke_name = NA_character_
    ) |>
    dplyr::select(period, level, region_code, region_name, fylke_name, exceeds_threshold, original_value_pct),
  national_non_scaled_agg_all_periods |>
    dplyr::mutate(
      level = "National",
      exceeds_threshold = indicator_value > x100,
      original_value_pct = round(indicator_value * 100, 2),
      region_code = NA_character_,
      region_name = "National",
      fylke_name = NA_character_
    ) |>
    dplyr::select(period, level, region_code, region_name, fylke_name, exceeds_threshold, original_value_pct)
)

# Summary of truncation by period and level
truncation_counts <- truncation_summary |>
  dplyr::group_by(period, level) |>
  dplyr::summarise(
    n_total = dplyr::n(),
    n_exceeding_33pct = sum(exceeds_threshold, na.rm = TRUE),
    pct_exceeding_33pct = round(100 * n_exceeding_33pct / n_total, 1),
    .groups = "drop"
  )

# Values that were truncated (for reporting)
truncated_values <- truncation_summary |>
  dplyr::filter(exceeds_threshold) |>
  dplyr::arrange(period, level, dplyr::desc(original_value_pct))

```


Values exceeding the reference value of 33% are truncated to 1.0 in the scaled indicator.
The following table shows the values that were truncated for each period and level.

```{r report-truncation}
#| code-summary: "Report truncation"
#| eval: false

truncation_counts |>
  dplyr::rename(
    Period = period,
    Level = level,
    `Total` = n_total,
    `Exceeding 33%` = n_exceeding_33pct,
    `% Exceeding 33%` = pct_exceeding_33pct
  ) |>
  gt::gt() |>
  gt::tab_style(
    style = gt::cell_text(weight = "bold"),
    locations = gt::cells_column_labels()
  ) |>
  gt::fmt_number(
    columns = `% Exceeding 33%`,
    decimals = 1
  )

if (nrow(truncated_values) > 0) {
  cat("\n### Values that were truncated:\n")
  # Format truncated values for better display
  truncated_display <- truncated_values |>
    dplyr::mutate(
      location = dplyr::case_when(
        level == "County" ~ fylke_name,
        level == "Region" ~ region_name,
        level == "National" ~ "National",
        TRUE ~ NA_character_
      )
    ) |>
    dplyr::select(period, level, location, original_value_pct) |>
    dplyr::rename(
      Period = period,
      Level = level,
      Location = location,
      `Original Value (%)` = original_value_pct
    )
  print(truncated_display)
} else {
  cat("\nNo values exceeded 33% and required truncation.\n")
}

```

```{r bootstrap-scaled-uncertainty}
#| code-summary: "Bootstrap uncertainty for scaled values"
#| eval: false

# Bootstrap uncertainty for scaled-then-aggregated regions per period
region_scaled_uncertainty <- purrr::imap_dfr(
  dtvs_results,
  function(period_result, period_name) {
    period_data <- period_result$data
    
    if (nrow(period_data) == 0) return(NULL)
    
    bootstrap_region_scaled_agg(
      period_data,
      x0 = x0,
      x100 = x100,
      n_bootstrap = 1000
    ) |>
      dplyr::rename(
        boot_mean = mean,
        boot_median = median
      ) |>
      dplyr::mutate(period = period_name)
  }
)

# Bootstrap uncertainty for scaled-then-aggregated national per period
national_scaled_uncertainty <- purrr::imap_dfr(
  dtvs_results,
  function(period_result, period_name) {
    period_data <- period_result$data
    
    if (nrow(period_data) == 0) return(NULL)
    
    boot_result <- bootstrap_national_scaled_agg(
      period_data,
      x0 = x0,
      x100 = x100,
      n_bootstrap = 1000
    )
    
    dplyr::tibble(
      period = period_name,
      region = "National",
      boot_mean = boot_result$mean,
      boot_median = boot_result$median,
      se = boot_result$se,
      ci_lower = boot_result$ci_lower,
      ci_upper = boot_result$ci_upper,
      q1 = boot_result$q1,
      q3 = boot_result$q3
    )
  }
)

# Attach uncertainty to scaled aggregated values and retain both bootstrap mean and median
region_scaled_agg_with_uncertainty <- region_scaled_agg_all_periods |>
  dplyr::left_join(region_scaled_uncertainty, by = c("period", "region_code")) |>
  dplyr::mutate(
    scaled_mean = boot_mean,
    scaled_median = boot_median
  )

national_scaled_agg_with_uncertainty <- national_scaled_agg_all_periods |>
  dplyr::left_join(national_scaled_uncertainty, by = c("period", "region")) |>
  dplyr::mutate(
    scaled_mean = boot_mean,
    scaled_median = boot_median
  )

```


## 10. Results

The following tables present the scaled indicator results at county, regional and national scales for each reporting period.
All values are scaled between 0 and 1, where 0 represents the worst condition (0% dead wood volume) and 1 represents the best condition (33% dead wood volume, the reference value).
Values exceeding 33% are truncated to 1, and we report both bootstrap means and medians together with the associated uncertainty metrics.

### 10.1 County-level results (scaled with uncertainty)

```{r tbl-county-results-table}
#| tbl-cap: 'County-level indicator values for dead wood volume as share of all wood volume by reporting period. Values are scaled to 0-1 (where 0 = worst condition, 1 = best condition at 33% dead wood). The table includes bootstrap mean and median estimates, standard error (SE), 95% confidence intervals (CI Lower, CI Upper), and quartiles (Q1, Q3).'
#| echo: false
#| eval: false

county_scaled_with_uncertainty |>
  dplyr::mutate(
    fylke_name_clean = stringi::stri_trans_general(
      stringr::str_squish(
        tolower(stringr::str_replace_all(fylke_name, "[0-9.-]", " "))
      ),
      "Latin-ASCII"
    ),
    region_code = assign_region_code(fylke_name_clean),
    region_name = assign_region_name(region_code)
  ) |>
  dplyr::select(period, fylke_name, region_name, scaled_mean, scaled_median, se, scaled_ci_lower, scaled_ci_upper, 
         scaled_q1, scaled_q3, total_area, n_plots) |>
  dplyr::mutate(
    scaled_mean = round(scaled_mean, 3),
    scaled_median = round(scaled_median, 3),
    se = round(se, 3),
    scaled_ci_lower = round(scaled_ci_lower, 3),
    scaled_ci_upper = round(scaled_ci_upper, 3),
    scaled_q1 = round(scaled_q1, 3),
    scaled_q3 = round(scaled_q3, 3),
    total_area = round(total_area, 0)
  ) |>
  dplyr::rename(
    Period = period,
    County = fylke_name,
    Region = region_name,
    `Bootstrapped (mean)` = scaled_mean,
    `Bootstrapped (median)` = scaled_median,
    `Standard Error` = se,
    `CI Lower` = scaled_ci_lower,
    `CI Upper` = scaled_ci_upper,
    `Q1` = scaled_q1,
    `Q3` = scaled_q3,
    `Total Area (ha)` = total_area,
    `Number of Plots` = n_plots
  ) |>
  DT::datatable(
    rownames = FALSE,
    options = list(pageLength = 10, scrollX = TRUE, lengthMenu = c(10, 25, 50, 100))
  )
```

### 10.2 Regional results (scaled with uncertainty)

```{r tbl-region-results-table}
#| tbl-cap: 'Regional-level indicator values for dead wood volume as share of all wood volume by reporting period. Values are scaled to 0-1 (where 0 = worst condition, 1 = best condition at 33% dead wood). The table includes the bootstrap mean and median, standard error (SE), 95% confidence intervals (CI Lower, CI Upper), and quartiles (Q1, Q3).'
#| echo: false
#| eval: false

region_scaled_agg_with_uncertainty |>
  dplyr::select(period, region_name, scaled_mean, scaled_median, se, ci_lower, ci_upper, q1, q3, total_area, n_plots) |>
  dplyr::mutate(
    scaled_mean = round(scaled_mean, 3),
    scaled_median = round(scaled_median, 3),
    se = round(se, 3),
    ci_lower = round(ci_lower, 3),
    ci_upper = round(ci_upper, 3),
    q1 = round(q1, 3),
    q3 = round(q3, 3),
    total_area = round(total_area, 0)
  ) |>
  dplyr::rename(
    Period = period,
    Region = region_name,
    `Bootstrapped (mean)` = scaled_mean,
    `Bootstrapped (median)` = scaled_median,
    `Standard Error` = se,
    `CI Lower` = ci_lower,
    `CI Upper` = ci_upper,
    `Q1` = q1,
    `Q3` = q3,
    `Total Area (ha)` = total_area,
    `Number of Plots` = n_plots
  ) |>
  kable() |>
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))
```

![](../img/DTVS_regional.jpg)

### 10.3 National results (scaled with uncertainty)

```{r tbl-national-results-table}
#| tbl-cap: 'National-level indicator values for dead wood volume as share of all wood volume by reporting period. Values are scaled to 0-1 (where 0 = worst condition, 1 = best condition at 33% dead wood). The table includes the bootstrap mean and median, standard error (SE), 95% confidence intervals (CI Lower, CI Upper), and quartiles (Q1, Q3).'
#| echo: false
#| eval: false

national_scaled_agg_with_uncertainty |>
  dplyr::select(period, region, scaled_mean, scaled_median, se, ci_lower, ci_upper, q1, q3, total_area, n_plots) |>
  dplyr::mutate(
    scaled_mean = round(scaled_mean, 3),
    scaled_median = round(scaled_median, 3),
    se = round(se, 3),
    ci_lower = round(ci_lower, 3),
    ci_upper = round(ci_upper, 3),
    q1 = round(q1, 3),
    q3 = round(q3, 3),
    total_area = round(total_area, 0)
  ) |>
  dplyr::rename(
    Period = period,
    `Spatial Level` = region,
    `Bootstrapped (mean)` = scaled_mean,
    `Bootstrapped (median)` = scaled_median,
    `Standard Error` = se,
    `CI Lower` = ci_lower,
    `CI Upper` = ci_upper,
    `Q1` = q1,
    `Q3` = q3,
    `Total Area (ha)` = total_area,
    `Number of Plots` = n_plots
  ) |>
  kable() |>
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))
```

![](../img/DTVS_national.jpg)


<!-- You can leave this last part as it is, unless you have a good reason to alter it. -->

::: {.callout-tip collapse="true"}
## Session Info

This information is mainly aimed at developers that need to recreate the R environment that produced the html.
Important note: this information is about the R session that was running when the html was rendered, and if some of the code chunks were not evaluated when the html was rendered, they may have been executed in a different environment.  

```{r sessionInfo}
#| echo: false
sessionInfo()
```

:::
